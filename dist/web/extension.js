/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.activate = void 0;
const axios_1 = __webpack_require__(1);
const https_1 = __webpack_require__(27);
const vscode = __webpack_require__(65);
const commandRecommendations_1 = __webpack_require__(66);
const extensionDataHolder_1 = __webpack_require__(72);
const commandAlternativeName_1 = __webpack_require__(79);
const constantExtractor = __webpack_require__(80);
const abortScriptRuns = __webpack_require__(81);
const fullScriptRunner = __webpack_require__(82);
const backendRefresher = __webpack_require__(83);
const scriptValidator = __webpack_require__(84);
const singleCommandRunner = __webpack_require__(85);
const snippetExecutor = __webpack_require__(69);
const bpLinter = __webpack_require__(86);
const axiosUtils_1 = __webpack_require__(73);
// use ChromeExample.mrepo
const USE_PATTERN = "(?<Intro>^\\s*use\\s+)(?<Name>[^*&%\\s]+)\\s*$";
const USE_PATTERN_SPACE = "(?<Intro>^\\s*use\\s+\")(?<Name>[^*&%\"]+\\.mrepo)\"\\s*$";
// use ChromeExample.mrepo as repo
const USE_AS_PATTERN = "(?<Intro>^\\s*use\\s+)(?<Name>[^*&%\\s]+)\\s+as\\s+(?<Details>[^*&%\\s\\.]+)\\s*";
const USE_AS_PATTERN_SPACE = "(?<Intro>^\\s*use\\s+\")(?<Name>[^*&%\"]+\\.mrepo)\"\\s+as\\s+(?<Details>[^*&%\\s\\.]+)\\s*";
const BREAKPOINT_PATTERN = "\\s*breakpoint\\(\\)\\s*";
const IF_PATTERN = "^(\\s*)if\\s?(?:\\((.*)\\))?:\\s*$";
const IF_NOT_PATTERN = "^(\\s*)if[n|N]ot\\s?(?:\\(.*\\))?:\\s*$";
const THEN_PATTERN = "^(\\s*)then\\s*:\\s*";
const ELSEIF_PATTERN = "^(\\s*)else[i|I]f\\s*:\\s*";
const ELSE_PATTERN = "^(\\s*)else\\s*:\\s*";
const WHILE_PATTERN = "^(\\s*)while\\s*\\((.*)\\)\\s*:\\s*";
const WHILE_NOT_PATTERN = "^(\\s*)while[n|N]ot\\s*\\((.*)\\)\\s*:\\s*";
const DO_PATTERN = "^(\\s*)do\\s*:\\s*";
const FOR_PATTERN = "(\\s*)for\\s*\\((.*)\\):\\s*";
// case Zu Blogbeitrag navigieren(Message):
const CASE_SUITE_PATTERN = "(?<Intro>(\\s*)(?:case|process|testcase)\\s+)(?<Name>[a-zA-Z0-9äÄöÖüÜß\\s\\-_]+)\\((?<Details>.*)\\)\\s*:\\s*";
// case Zu Blogbeitrag navigieren:
const CASE_SUITE_WITHOUT_ARGS_PATTERN = "(?<Intro>(\\s*)(?:case|process|testcase)\\s+)(?<Name>[a-zA-Z0-9äÄöÖüÜß\\s\\-_]+):\\s*";
// step MateoRepoStep2(Message):
const STEP_SUITE_PATTERN = "(?<Intro>(\\s*)(?:step)\\s+)(?<Name>[a-zA-Z0-9äÄöÖüÜß\\s\\-_\\.]+)\\((?<Details>.*)\\)\\s*:\\s*";
// step MateoRepoStep2:
const STEP_SUITE_WITHOUT_ARGS_PATTERN = "(?<Intro>(\\s*)(?:step)\\s+)(?<Name>[a-zA-Z0-9äÄöÖüÜß\\s\\-_\\.]+):\\s*";
// set MATEO_URL2 = "https://mateo-web.de/"
const SET_VARIABLE_PATTERN = "(?<Intro>\\s*set\\s+)(?<Name>[a-zA-Z0-9\\-_]+)\\s*=\\s*[\"|'](?<Details>.*)[\"|']\\s*";
// set break = getTextFromElementWeb(BY_CRITERIA = "id", ELEMENT_NAME = "breakpoint")
const SET_COMMAND_VARIABLE_PATTERN = "(?<Intro>\\s*set\\s)(?<Name>[a-zA-Z0-9\\-_]+)\\s*=\\s*(?<Details>([a-z][a-zA-Z0-9\\s\\-_]*)\\((.*))\\)\\s*";
// const XPATH_COOKIES_AKZEPTIEREN = "//button[@aria-label="Akzeptieren"]"
const CONSTANT_PATTERN = "(?<Intro>\\s*const\\s+)(?<Name>[a-zA-Z0-9\\-_]+)\\s*=\\s*[\"|'](?<Details>.*)[\"|']\\s*";
const QUALIFIED_REFERENCE_PATTERN = "^(\\s*)([\\wÄÖÜäöüß\\s\\-]+)\\.([a-zäöüA-ZÄÖÜ]+[\\wÄÖÜäöüß\\s\\-]*)\\((.*)\\)\\s*";
const GENERAL_REFERENCE_PATTERN = "^\\s*([a-zäöüA-ZÄÖÜ]+[\\wÄÖÜäöüß\\s\\-]*)\\((.*)\\)\\s*";
const COMMAND_PATTERN = "(\\s+)([a-z][a-zA-Z0-9\\s\\-_]*)\\(((?:.|\\n)*)\\)\\s*";
const COMMAND_WITHOUT_ARGS_PATTERN = "(\\s+)([a-z][a-zA-Z0-9\\s\\-_]*)\\s*$";
const COMMAND_SET_PATTERN = "\\s*set\\s([a-zA-Z0-9\\-_]+)\\s*=\\s*([a-z][a-zA-Z0-9\\s\\-_]*)\\((.*)\\)\\s*";
const OPTION_PATTERN = "\\s*option\\s([a-zA-Z0-9\\-_]+)\\s{0,1}=\\s{0,1}\"(.*)\"";
function activate(context) {
    let hoverProvider = vscode.languages.registerHoverProvider('mateo', {
        provideHover(document, position, token) {
            return __awaiter(this, void 0, void 0, function* () {
                let config = vscode.workspace.getConfiguration('mateo');
                let line = document.lineAt(position);
                let beginIndex = line.firstNonWhitespaceCharacterIndex;
                let indexOfBrace = line.text.indexOf("(");
                let commandName = line.text.substr(beginIndex, (indexOfBrace - beginIndex));
                let tooltip = "";
                if (line.text.match(USE_PATTERN) || line.text.match(USE_PATTERN_SPACE)
                    || line.text.match(USE_AS_PATTERN) || line.text.match(USE_AS_PATTERN_SPACE)) {
                    return getChapterMarkdown("Repositories");
                }
                else if (line.text.match(BREAKPOINT_PATTERN)) {
                    return getChapterMarkdown("Breakpoints");
                }
                else if (line.text.match(IF_PATTERN) || line.text.match(IF_NOT_PATTERN) || line.text.match(THEN_PATTERN)
                    || line.text.match(ELSEIF_PATTERN) || line.text.match(ELSE_PATTERN)) {
                    return getChapterMarkdown("If-Then-Else Bedingung");
                }
                else if (line.text.match(WHILE_PATTERN) || line.text.match(WHILE_NOT_PATTERN) || line.text.match(DO_PATTERN)) {
                    return getChapterMarkdown("While-Schleife");
                }
                else if (line.text.match(FOR_PATTERN)) {
                    return getChapterMarkdown("For-Schleife");
                }
                else if (line.text.match(CASE_SUITE_PATTERN) || line.text.match(CASE_SUITE_WITHOUT_ARGS_PATTERN)) {
                    return getChapterMarkdown("Falldefinition (case/process)");
                }
                else if (line.text.match(STEP_SUITE_PATTERN) || line.text.match(STEP_SUITE_WITHOUT_ARGS_PATTERN)) {
                    return getChapterMarkdown("Schrittdefinition (step)");
                }
                else if (line.text.match(CONSTANT_PATTERN)) {
                    return getChapterMarkdown("Konstanten");
                }
                else if (line.text.match(SET_VARIABLE_PATTERN) || line.text.match(SET_COMMAND_VARIABLE_PATTERN)) {
                    return getChapterMarkdown("Variable");
                }
                else if (line.text.match(COMMAND_SET_PATTERN)) {
                    return getChapterMarkdown("Variable");
                }
                else if (line.text.match(OPTION_PATTERN)) {
                    return getChapterMarkdown("Option");
                }
                else if (!line.text.match(BREAKPOINT_PATTERN) && (line.text.match(COMMAND_PATTERN) || line.text.match(COMMAND_WITHOUT_ARGS_PATTERN))) {
                    return getCommandMarkdown();
                }
                else if (line.text.match(QUALIFIED_REFERENCE_PATTERN)) {
                    return getChapterMarkdown("Repository mit Alias");
                }
                else if (line.text.match(GENERAL_REFERENCE_PATTERN)) {
                    return getChapterMarkdown("Global oder General Repository");
                }
                else {
                    return new vscode.Hover("");
                }
                function getCommandMarkdown() {
                    return __awaiter(this, void 0, void 0, function* () {
                        let commandAlternativeNames = new commandAlternativeName_1.CommandAlternativeName();
                        commandName = commandAlternativeNames.commandNameHasAlternative(commandName);
                        let queryParams = {
                            auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
                            httpsAgent: new https_1.Agent({
                                rejectUnauthorized: vscode.workspace.getConfiguration('mateo').rejectUnauthorized
                            }),
                            params: {
                                "markdownFilename": commandName,
                                "subfolder": "COMMANDS"
                            }
                        };
                        yield axios_1.default.get(config.mateoHostUrl + '/api/documentation/', queryParams)
                            .then(function (response) {
                            tooltip = response.data;
                            // replace all  '>' with new line to avoid markdown quote
                            tooltip = tooltip.split(">").join('\n');
                            console.log("tooltip: " + tooltip);
                        }).catch(function (error) {
                            console.log("Error during execution: " + error.response.data);
                        }).then(undefined, err => {
                            console.log("Something went wrong: " + err);
                        });
                        return new vscode.Hover(tooltip);
                    });
                }
                function getChapterMarkdown(snippetName) {
                    return __awaiter(this, void 0, void 0, function* () {
                        let language = vscode.workspace.getConfiguration("mateo").snippetLanguage;
                        let path = "";
                        if (language === "de") {
                            path = "de/03a Skripte - mateoScript";
                        }
                        else if (language === "en") {
                            path = "en/03a Scripts - mateoScript";
                        }
                        else {
                            vscode.window.showWarningMessage("Language must be set either to 'en' or 'de'");
                            path = "de/03a Skripte - mateoScript";
                        }
                        let queryParams = {
                            auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
                            httpsAgent: new https_1.Agent({
                                rejectUnauthorized: vscode.workspace.getConfiguration('mateo').rejectUnauthorized
                            }),
                            params: {
                                "snippetName": snippetName,
                                "folderPath": "usermanual/" + path,
                            }
                        };
                        yield axios_1.default.get(config.mateoHostUrl + '/api/documentation/snippet', queryParams)
                            .then(function (response) {
                            tooltip = response.data;
                        }).catch(function (error) {
                            console.log("Error during execution: " + error.response.data);
                        }).then(undefined, err => {
                            console.log("Something went wrong: " + err);
                        });
                        return new vscode.Hover(tooltip);
                    });
                }
            });
        }
    });
    let validateOnSaveSubscriber = vscode.workspace.onDidSaveTextDocument(function (activeDocument) {
        var _a;
        if (vscode.workspace.getConfiguration('mateo').validateOnSave && ((_a = vscode.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document.uri.fsPath.match(/.*\.(mateo|mrepo)$/))) {
            vscode.commands.executeCommand("extension.mateo.validateOnSave");
        }
    });
    const dataHolder = extensionDataHolder_1.ExtensionDataHolder.getInstance();
    context.subscriptions.push(dataHolder.diagnosticCollection);
    context.subscriptions.push(commandRecommendations_1.commandRecommendations, hoverProvider, scriptValidator.validate, abortScriptRuns.abort, bpLinter.lintBP, fullScriptRunner.runFullScript, backendRefresher.reloadGlobalRepos, snippetExecutor.runSnippet, constantExtractor.constantExtractor, singleCommandRunner.runSingleCommand, validateOnSaveSubscriber);
    context.subscriptions.push(vscode.languages.registerDocumentSymbolProvider({ language: "mateo" }, new MateoDocumentSymbolProvider()));
}
exports.activate = activate;
class CodeSymbolDefinition {
    /**
     *
     * @param definitionName description string of this definition
     * @param matchRegex regex the element should match to qualify as an element of this type
     * @param symbolKind type of symbol to display for element
     * @param showDetails Should detail for this symbol be shown
     * @param enable Should this symbol type be used?
     * @param appropriateParent The parent element of this symbol (e.g. the 'case' symbol which is the parent to a 'step' symbol)
     */
    constructor(definitionName, matchRegex, symbolKind, showDetails, appropriateParent) {
        this.definitionName = definitionName;
        this.matchRegex = matchRegex;
        this.symbolKind = symbolKind;
        this.showDetails = showDetails;
        this.appropriateParent = appropriateParent;
    }
    createCodeSymbol(line, i) {
        var _a, _b, _c;
        if (vscode.workspace.getConfiguration('mateo').enableOutline) {
            const result = line.text.match(this.matchRegex);
            if (result) {
                const range = new vscode.Range(new vscode.Position(i, result.groups.Intro.length), new vscode.Position(i, result.groups.Intro.length + result.groups.Name.length));
                let symbolName = result.groups.Name.trim();
                let symbolDetails = this.showDetails ? (_c = (_b = (_a = result.groups) === null || _a === void 0 ? void 0 : _a.Details) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "" : "";
                return new vscode.DocumentSymbol(symbolName, symbolDetails, this.symbolKind, range, range);
            }
        }
        return null;
    }
    getSymbolKind() {
        return this.symbolKind;
    }
    getAppropriateParent(symbols) {
        return this.appropriateParent(symbols);
    }
}
class MateoDocumentSymbolProvider {
    provideDocumentSymbols(document, token) {
        // TODO: Maybe add references to storage variables and constants that are being used?
        //       Might be tricky if constants contain storage variables etc...?
        //       Also: Multiple references in one line
        //       Also: Needs to be a set, not a list
        //             But then, how do we do "range"? Should be possible to reference same thing multiple times!
        //       Also: Do a separate parsing run for this, since it's not "line starts with"
        //"§.*?§|AVAILABLE_STORAGE_KEYS": vscode.SymbolKind.Variable,
        //"%.*?%": vscode.SymbolKind.Variable
        const codeSymbolDefinitions = [
            // imports
            new CodeSymbolDefinition("USE_AS_PATTERN", new RegExp(USE_AS_PATTERN, "i"), vscode.SymbolKind.Interface, true, (symbols) => { return symbols; }),
            // imports
            new CodeSymbolDefinition("USE_AS_PATTERN_SPACE", new RegExp(USE_AS_PATTERN_SPACE, "i"), vscode.SymbolKind.Interface, true, (symbols) => { return symbols; }),
            // imports
            new CodeSymbolDefinition("USE_PATTERN", new RegExp(USE_PATTERN, "i"), vscode.SymbolKind.Interface, false, (symbols) => { return symbols; }),
            // imports
            new CodeSymbolDefinition("USE_PATTERN_SPACE", new RegExp(USE_PATTERN_SPACE, "i"), vscode.SymbolKind.Interface, false, (symbols) => { return symbols; }),
            // Constants
            new CodeSymbolDefinition("CONSTANT_PATTERN", new RegExp(CONSTANT_PATTERN, "i"), vscode.SymbolKind.Constant, true, (symbols) => { return symbols; }),
            // Variable
            new CodeSymbolDefinition("SET_VARIABLE_PATTERN", new RegExp(SET_VARIABLE_PATTERN, "i"), vscode.SymbolKind.Variable, true, getSymbolDepthTwo()),
            // Variable Command
            new CodeSymbolDefinition("SET_COMMAND_VARIABLE_PATTERN", new RegExp(SET_COMMAND_VARIABLE_PATTERN, "i"), vscode.SymbolKind.Variable, true, getSymbolDepthTwo()),
            // Cases
            new CodeSymbolDefinition("CASE_SUITE_PATTERN", new RegExp(CASE_SUITE_PATTERN, "i"), vscode.SymbolKind.Class, true, (symbols) => { return symbols; }),
            // Cases No Args
            new CodeSymbolDefinition("CASE_SUITE_WITHOUT_ARGS_PATTERN", new RegExp(CASE_SUITE_WITHOUT_ARGS_PATTERN, "i"), vscode.SymbolKind.Class, false, (symbols) => { return symbols; }),
            // Steps
            new CodeSymbolDefinition("STEP_SUITE_PATTERN", new RegExp(STEP_SUITE_PATTERN, "i"), vscode.SymbolKind.Method, false, getStepSymbol()),
            // Steps without args
            new CodeSymbolDefinition("STEP_SUITE_WITHOUT_ARGS_PATTERN", new RegExp(STEP_SUITE_WITHOUT_ARGS_PATTERN, "i"), vscode.SymbolKind.Method, false, // no details available
            getStepSymbol())
        ];
        return new Promise((resolve, reject) => {
            var symbols = [];
            for (var i = 0; i < document.lineCount; i++) {
                var line = document.lineAt(i);
                codeSymbolDefinitions.forEach(codeSymbolDefinition => {
                    var _a;
                    const result = codeSymbolDefinition.createCodeSymbol(line, i);
                    if (result) {
                        (_a = codeSymbolDefinition.getAppropriateParent(symbols)) === null || _a === void 0 ? void 0 : _a.push(result);
                    }
                });
            }
            resolve(symbols);
        });
        function getSymbolDepthTwo() {
            return (symbols) => {
                if (symbols.length > 0) {
                    const potentialParent = symbols[symbols.length - 1];
                    // TODO: Re-implement codeSymbolDefinitions using subclasses of `CodeSymbolDefintion` instead of passing in "parent determination functions".
                    //       That way, we could point to `CaseCodeSymbolDefintion.getSymbolKind()` here instead of hardcoding `vscode.SymbolKind.<X>`
                    // TODO: rewrite this: Essentially this is level two of a depth search written manually.
                    if (potentialParent.kind == vscode.SymbolKind.Class) {
                        const potentialParent2 = potentialParent.children[potentialParent.children.length - 1];
                        if (potentialParent2) {
                            return potentialParent2.kind == vscode.SymbolKind.Method ? potentialParent2.children : symbols;
                        }
                        else {
                            return symbols;
                        }
                    }
                    else {
                        return potentialParent.kind == vscode.SymbolKind.Method ? potentialParent.children : symbols;
                    }
                }
                else {
                    return symbols;
                }
            };
        }
        function getStepSymbol() {
            return (symbols) => {
                if (symbols.length > 0) {
                    const potentialParent = symbols[symbols.length - 1];
                    // TODO: Re-implement codeSymbolDefinitions using subclasses of `CodeSymbolDefintion` instead of passing in "parent determination functions".
                    //       That way, we could point to `CaseCodeSymbolDefintion.getSymbolKind()` here instead of hardcoding `vscode.SymbolKind.Class`
                    return potentialParent.kind == vscode.SymbolKind.Class ? potentialParent.children : symbols;
                }
                else {
                    return symbols;
                }
            };
        }
    }
}


/***/ }),
/* 1 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(2);

/***/ }),
/* 2 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);
var bind = __webpack_require__(4);
var Axios = __webpack_require__(5);
var mergeConfig = __webpack_require__(23);
var defaults = __webpack_require__(11);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(24);
axios.CancelToken = __webpack_require__(25);
axios.isCancel = __webpack_require__(10);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(26);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),
/* 3 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(4);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function deepMerge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};


/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 5 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);
var buildURL = __webpack_require__(6);
var InterceptorManager = __webpack_require__(7);
var dispatchRequest = __webpack_require__(8);
var mergeConfig = __webpack_require__(23);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 6 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 7 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 8 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);
var transformData = __webpack_require__(9);
var isCancel = __webpack_require__(10);
var defaults = __webpack_require__(11);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 9 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),
/* 10 */
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 11 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);
var normalizeHeaderName = __webpack_require__(12);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(13);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(13);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),
/* 12 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 13 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);
var settle = __webpack_require__(14);
var buildURL = __webpack_require__(6);
var buildFullPath = __webpack_require__(17);
var parseHeaders = __webpack_require__(20);
var isURLSameOrigin = __webpack_require__(21);
var createError = __webpack_require__(15);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(22);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),
/* 14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(15);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 15 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(16);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 16 */
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),
/* 17 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(18);
var combineURLs = __webpack_require__(19);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),
/* 18 */
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 19 */
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 20 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 21 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),
/* 22 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),
/* 23 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(3);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
  var defaultToConfig2Keys = [
    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath'
  ];

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys);

  var otherKeys = Object
    .keys(config2)
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  return config;
};


/***/ }),
/* 24 */
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 25 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(24);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 26 */
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 27 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var http = __webpack_require__(28)
var url = __webpack_require__(59)

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}


/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ClientRequest = __webpack_require__(29)
var response = __webpack_require__(32)
var extend = __webpack_require__(57)
var statusCodes = __webpack_require__(58)
var url = __webpack_require__(59)

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = __webpack_require__.g.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]

/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var capability = __webpack_require__(30)
var inherits = __webpack_require__(31)
var response = __webpack_require__(32)
var stream = __webpack_require__(33)

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null
	self._socketTimeout = null
	self._socketTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	if ('timeout' in opts && opts.timeout !== 0) {
		self.setTimeout(opts.timeout)
	}

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
        body = new Blob(self._body, {
            type: (headersObj['content-type'] || {}).value || ''
        });
    }

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = __webpack_require__.g.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		__webpack_require__.g.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._resetTimers(false)
			self._connect()
		}, function (reason) {
			self._resetTimers(true)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new __webpack_require__.g.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self._resetTimers(true)
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	self._resetTimers(false)

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress(self._resetTimers.bind(self))
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self))
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype._resetTimers = function (done) {
	var self = this

	__webpack_require__.g.clearTimeout(self._socketTimer)
	self._socketTimer = null

	if (done) {
		__webpack_require__.g.clearTimeout(self._fetchTimer)
		self._fetchTimer = null
	} else if (self._socketTimeout) {
		self._socketTimer = __webpack_require__.g.setTimeout(function () {
			self.emit('timeout')
		}, self._socketTimeout)
	}
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {
	var self = this
	self._destroyed = true
	self._resetTimers(true)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()

	if (err)
		self.emit('error', err)
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.setTimeout = function (timeout, cb) {
	var self = this

	if (cb)
		self.once('timeout', cb)

	self._socketTimeout = timeout
	self._resetTimers(false)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]


/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.fetch = isFunction(__webpack_require__.g.fetch) && isFunction(__webpack_require__.g.ReadableStream)

exports.writableStream = isFunction(__webpack_require__.g.WritableStream)

exports.abortController = isFunction(__webpack_require__.g.AbortController)

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (__webpack_require__.g.XMLHttpRequest) {
		xhr = new __webpack_require__.g.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', __webpack_require__.g.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer')

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc


/***/ }),
/* 31 */
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var capability = __webpack_require__(30)
var inherits = __webpack_require__(31)
var stream = __webpack_require__(33)

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					resetTimers(false)
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(Buffer.from(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					resetTimers(true)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					resetTimers(true)
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					resetTimers(true)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				resetTimers(result.done)
				if (result.done) {
					self.push(null)
					return
				}
				self.push(Buffer.from(result.value))
				read()
			}).catch(function (err) {
				resetTimers(true)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text':
			response = xhr.responseText
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = Buffer.alloc(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(Buffer.from(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new __webpack_require__.g.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				resetTimers(true)
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		resetTimers(true)
		self.push(null)
	}
}


/***/ }),
/* 33 */
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(34);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(47);
exports.Duplex = __webpack_require__(46);
exports.Transform = __webpack_require__(54);
exports.PassThrough = __webpack_require__(55);
exports.finished = __webpack_require__(52);
exports.pipeline = __webpack_require__(56);


/***/ }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = (__webpack_require__(35).EventEmitter);
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(36);
/*</replacement>*/

var Buffer = (__webpack_require__(37).Buffer);
var OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = __webpack_require__(40);
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __webpack_require__(41);
var destroyImpl = __webpack_require__(43);
var _require = __webpack_require__(44),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(45).codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__webpack_require__(31)(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(46);
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(49).StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || __webpack_require__(46);
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(49).StringDecoder);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(51);
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(53);
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

/***/ }),
/* 35 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(35).EventEmitter;


/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(38)
const ieee754 = __webpack_require__(39)
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 40 */
/***/ (() => {

/* (ignored) */

/***/ }),
/* 41 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var _require = __webpack_require__(37),
  Buffer = _require.Buffer;
var _require2 = __webpack_require__(42),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();

/***/ }),
/* 42 */
/***/ (() => {

/* (ignored) */

/***/ }),
/* 43 */
/***/ ((module) => {

"use strict";


// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),
/* 44 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ERR_INVALID_OPT_VALUE = (__webpack_require__(45).codes.ERR_INVALID_OPT_VALUE);
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),
/* 45 */
/***/ ((module) => {

"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;


/***/ }),
/* 46 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = __webpack_require__(34);
var Writable = __webpack_require__(47);
__webpack_require__(31)(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),
/* 47 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(48)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(36);
/*</replacement>*/

var Buffer = (__webpack_require__(37).Buffer);
var OurUint8Array = (typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __webpack_require__(43);
var _require = __webpack_require__(44),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = (__webpack_require__(45).codes),
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__webpack_require__(31)(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(46);
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || __webpack_require__(46);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}


/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = (__webpack_require__(50).Buffer);
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 50 */
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(37)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 51 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var finished = __webpack_require__(52);
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;

/***/ }),
/* 52 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).



var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(45).codes.ERR_STREAM_PREMATURE_CLOSE);
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;

/***/ }),
/* 53 */
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};


/***/ }),
/* 54 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;
var _require$codes = (__webpack_require__(45).codes),
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __webpack_require__(46);
__webpack_require__(31)(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),
/* 55 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;
var Transform = __webpack_require__(54);
__webpack_require__(31)(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 56 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).



var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = (__webpack_require__(45).codes),
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(52);
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;

/***/ }),
/* 57 */
/***/ ((module) => {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),
/* 58 */
/***/ ((module) => {

module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}


/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(60);
var util = __webpack_require__(61);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(62);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));


/***/ }),
/* 61 */
/***/ ((module) => {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.decode = exports.parse = __webpack_require__(63);
exports.encode = exports.stringify = __webpack_require__(64);


/***/ }),
/* 63 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 64 */
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),
/* 65 */
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),
/* 66 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commandRecommendations = void 0;
const vscode = __webpack_require__(65);
const paramSortUtils_1 = __webpack_require__(67);
const RepoStepRecommender_1 = __webpack_require__(68);
const ConstantsRecommender_1 = __webpack_require__(78);
const codeUtils_1 = __webpack_require__(70);
// Careful: This file is automatically generated by the backend in the class:
// ExtensionCommandsService.java, or, more precisley, in 
// XmlCommandFileCreator::XmlCommands::createCommandCode().
exports.commandRecommendations = vscode.languages.registerCompletionItemProvider('mateo', {
    provideCompletionItems(document, position) {
        return __awaiter(this, void 0, void 0, function* () {
            let items = [];
            let preprocessedSubdocument = (0, codeUtils_1.removeComments)((0, codeUtils_1.removeLinebreaks)((0, codeUtils_1.cutUntilCaret)(document, position)));
            let repoBuffer = RepoStepRecommender_1.default.getInstance();
            let repoRecommendations = yield repoBuffer.provideRecommendation(preprocessedSubdocument, document.uri.fsPath);
            for (let recommendationIndex = 0; recommendationIndex < repoRecommendations.length; recommendationIndex++) {
                items.push(repoRecommendations[recommendationIndex]);
            }
            let variableRecommender = new ConstantsRecommender_1.ConstantsRecommender();
            let variableRecommendations = yield variableRecommender.provideRecommendation(preprocessedSubdocument, document.uri.fsPath);
            for (let recommendationIndex = 0; recommendationIndex < variableRecommendations.length; recommendationIndex++) {
                items.push(variableRecommendations[recommendationIndex]);
            }
            let line = document.lineAt(position);
            let beginIndex = line.firstNonWhitespaceCharacterIndex;
            let indexOfBrace = line.text.indexOf("(");
            let linePrefix = line.text.substr(beginIndex, indexOfBrace + 1);
            console.log("\n");
            console.log("Line: " + line.text);
            console.log("begin index: " + beginIndex + " linePrefix: " + linePrefix);
            console.log("Position: " + position.character);
            console.log("Index of brace: " + line.text.indexOf('('));
            if (/^\s+(?!case|step|process|testcase)\w+/.test(line.text) && position.character <= (indexOfBrace > 0 ? indexOfBrace : position.character)) {
                const addToTextCommandCompletion = new vscode.CompletionItem('addToText');
                addToTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                addToTextCommandCompletion.insertText = new vscode.SnippetString('addToText(EXISTING_TEXT = "$1", TEXT_TO_ADD = "$2")');
                addToTextCommandCompletion.documentation = new vscode.MarkdownString('Hängt einen Text einem bestimmtes Wort oder einen festen Teilbereich in einem Text an.Das Kommando sucht nach EXISTING_TEXT im Text und hängt bei jedem Vorkommen TEXT_TO_ADD an.Das bedeutet, dass bei mehreren Mal TEXT_TO_ADD angehängt wird.');
                items.push(addToTextCommandCompletion);
                const agentCallJavaCommandCompletion = new vscode.CompletionItem('agentCallJava');
                agentCallJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                agentCallJavaCommandCompletion.insertText = new vscode.SnippetString('agentCallJava(METHOD = "$1")');
                agentCallJavaCommandCompletion.documentation = new vscode.MarkdownString('Basiskommando zur direkten Ansprache des Java Treibers. Dieses Kommando sollte im Regelfall nicht verwendet werden müssen.');
                items.push(agentCallJavaCommandCompletion);
                const attachJavaCommandCompletion = new vscode.CompletionItem('attachJava');
                attachJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                attachJavaCommandCompletion.insertText = new vscode.SnippetString('attachJava(NAME = "$1")');
                attachJavaCommandCompletion.documentation = new vscode.MarkdownString('Wird verwendet den Agenten an eine bestimmte Java Anwendung anzudocken. Dies ist notwendig bevor alle weiteren Kommandos verwendet werden können.');
                items.push(attachJavaCommandCompletion);
                const backupCommandCompletion = new vscode.CompletionItem('backup');
                backupCommandCompletion.kind = vscode.CompletionItemKind.Function;
                backupCommandCompletion.insertText = new vscode.SnippetString('backup(RESULT_LEVEL = "$1")');
                backupCommandCompletion.documentation = new vscode.MarkdownString('Hilfskommando, das eingesetzt werden kann, um ein bestimmtes Ergebnis zu simulieren.');
                items.push(backupCommandCompletion);
                const basicAutoItCommandCommandCompletion = new vscode.CompletionItem('basicAutoItCommand');
                basicAutoItCommandCommandCompletion.kind = vscode.CompletionItemKind.Function;
                basicAutoItCommandCommandCompletion.insertText = new vscode.SnippetString('basicAutoItCommand(PARAM0 = "$1")');
                basicAutoItCommandCommandCompletion.documentation = new vscode.MarkdownString('Basiskommando zur direkten Ansprache des AutoIT Treibers. Dieses Kommando sollte im Regelfall nicht verwendet werden müssen.');
                items.push(basicAutoItCommandCommandCompletion);
                const basicSapCommandCommandCompletion = new vscode.CompletionItem('basicSapCommand');
                basicSapCommandCommandCompletion.kind = vscode.CompletionItemKind.Function;
                basicSapCommandCommandCompletion.insertText = new vscode.SnippetString('basicSapCommand(PARAM0 = "$1")');
                basicSapCommandCommandCompletion.documentation = new vscode.MarkdownString('Generisches Kommando für Aufrufe zum SAP Treiber. Dieses Kommando ist im Regelfall nur für "on-the-fly" Implementierungen von konkreten SAP Aufrufen zu verwenden.');
                items.push(basicSapCommandCommandCompletion);
                const breakCommandCompletion = new vscode.CompletionItem('break');
                breakCommandCompletion.kind = vscode.CompletionItemKind.Function;
                breakCommandCompletion.insertText = new vscode.SnippetString('break()');
                breakCommandCompletion.documentation = new vscode.MarkdownString('Erlaubt das Ausbrechen aus einer Schleife.    Die Ausführung wird am Ende des Ausführungsblocks der Schleife fortgesetzt.');
                items.push(breakCommandCompletion);
                const changeStorageValueCommandCompletion = new vscode.CompletionItem('changeStorageValue');
                changeStorageValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                changeStorageValueCommandCompletion.insertText = new vscode.SnippetString('changeStorageValue(SOURCE_STORAGE_KEY = "$1", OPERATION = "$2")');
                changeStorageValueCommandCompletion.documentation = new vscode.MarkdownString('Verändert den Wert einer Laufzeitvariable. Dies ist ein Wert in der Storage-Datei storageFile. Der Pfad zu storageFile wird über environment.properties gesetzt). Mögliche Operationen: entferne, entferneLeerzeichen, addOrReplace, extractSingleSqlResultFromJson, regex, regex_from_old, get_testscript_dir, replace_char');
                items.push(changeStorageValueCommandCompletion);
                const checkAlertWebCommandCompletion = new vscode.CompletionItem('checkAlertWeb');
                checkAlertWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkAlertWebCommandCompletion.insertText = new vscode.SnippetString('checkAlertWeb()');
                checkAlertWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando überprüft, ob eine Alarm-Meldung (Alert) angezeigt wird.');
                items.push(checkAlertWebCommandCompletion);
                const checkButtonIsSelectableWinEleCommandCompletion = new vscode.CompletionItem('checkButtonIsSelectableWinEle');
                checkButtonIsSelectableWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkButtonIsSelectableWinEleCommandCompletion.insertText = new vscode.SnippetString('checkButtonIsSelectableWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", BUTTON_NAME = "$3", SHOULD_BE = "$4")');
                checkButtonIsSelectableWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt auf einen Button anhand dessen Namen.');
                items.push(checkButtonIsSelectableWinEleCommandCompletion);
                const checkCheckboxIsSelectableWinEleCommandCompletion = new vscode.CompletionItem('checkCheckboxIsSelectableWinEle');
                checkCheckboxIsSelectableWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkCheckboxIsSelectableWinEleCommandCompletion.insertText = new vscode.SnippetString('checkCheckboxIsSelectableWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", SHOULD_BE = "$3")');
                checkCheckboxIsSelectableWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando prüft, ob eine Checkbox selektierbar ist.');
                items.push(checkCheckboxIsSelectableWinEleCommandCompletion);
                const checkCheckboxIsSelectedWinEleCommandCompletion = new vscode.CompletionItem('checkCheckboxIsSelectedWinEle');
                checkCheckboxIsSelectedWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkCheckboxIsSelectedWinEleCommandCompletion.insertText = new vscode.SnippetString('checkCheckboxIsSelectedWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", SHOULD_BE = "$3")');
                checkCheckboxIsSelectedWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando prüft, ob eine Checkbox selektiert ist.');
                items.push(checkCheckboxIsSelectedWinEleCommandCompletion);
                const checkCheckboxSelectedWebCommandCompletion = new vscode.CompletionItem('checkCheckboxSelectedWeb');
                checkCheckboxSelectedWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkCheckboxSelectedWebCommandCompletion.insertText = new vscode.SnippetString('checkCheckboxSelectedWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkCheckboxSelectedWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando überprüft, ob ein Element auf einer Webseite ausgewählt ist.');
                items.push(checkCheckboxSelectedWebCommandCompletion);
                const checkCheckboxWinEleCommandCompletion = new vscode.CompletionItem('checkCheckboxWinEle');
                checkCheckboxWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkCheckboxWinEleCommandCompletion.insertText = new vscode.SnippetString('checkCheckboxWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2")');
                checkCheckboxWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando aktiviert eine Checkbox.');
                items.push(checkCheckboxWinEleCommandCompletion);
                const checkCurrentActivityAndroidCommandCompletion = new vscode.CompletionItem('checkCurrentActivityAndroid');
                checkCurrentActivityAndroidCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkCurrentActivityAndroidCommandCompletion.insertText = new vscode.SnippetString('checkCurrentActivityAndroid(EXPECTED_ACTIVITY_NAME = "$1")');
                checkCurrentActivityAndroidCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando überprüft, ob eine gewisse Activity aktiv ist. ');
                items.push(checkCurrentActivityAndroidCommandCompletion);
                const checkDriverActiveCommandCompletion = new vscode.CompletionItem('checkDriverActive');
                checkDriverActiveCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkDriverActiveCommandCompletion.insertText = new vscode.SnippetString('checkDriverActive(BROWSER_ABBREVIATION = "$1")');
                checkDriverActiveCommandCompletion.documentation = new vscode.MarkdownString('Mit diesem Command kann überprüft werden, ob ein Treiber mit einem entsprechenden Alias bekannt ist. Dies bedeutet nicht zwangsläufig, dass der Treiber noch funktionsfähig ist, falls die Session bereits beendet wurde.');
                items.push(checkDriverActiveCommandCompletion);
                const checkDropDownIsSelectableWinEleCommandCompletion = new vscode.CompletionItem('checkDropDownIsSelectableWinEle');
                checkDropDownIsSelectableWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkDropDownIsSelectableWinEleCommandCompletion.insertText = new vscode.SnippetString('checkDropDownIsSelectableWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", SHOULD_BE = "$3")');
                checkDropDownIsSelectableWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando prüft, ob ein Dropdown Menü selektierbar ist.');
                items.push(checkDropDownIsSelectableWinEleCommandCompletion);
                const checkElementActiveWebCommandCompletion = new vscode.CompletionItem('checkElementActiveWeb');
                checkElementActiveWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementActiveWebCommandCompletion.insertText = new vscode.SnippetString('checkElementActiveWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementActiveWebCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element das gerade aktive Element auf der Seite ist. Das heißt, dass dieses gerade das im Fokus stehende Element ist.');
                items.push(checkElementActiveWebCommandCompletion);
                const checkElementAttributeEqualsWebCommandCompletion = new vscode.CompletionItem('checkElementAttributeEqualsWeb');
                checkElementAttributeEqualsWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementAttributeEqualsWebCommandCompletion.insertText = new vscode.SnippetString('checkElementAttributeEqualsWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2", TEXT_EQUALS = "$3", ATTRIBUTE_NAME = "$4")');
                checkElementAttributeEqualsWebCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element ein Attribut enthält, dessen Wert dem angebenen Wert (TEXT_EQUALS) entsprechen muss.');
                items.push(checkElementAttributeEqualsWebCommandCompletion);
                const checkElementCssEqualsWebCommandCompletion = new vscode.CompletionItem('checkElementCssEqualsWeb');
                checkElementCssEqualsWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementCssEqualsWebCommandCompletion.insertText = new vscode.SnippetString('checkElementCssEqualsWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2", TEXT_EQUALS = "$3", CSS_ATTRIBUTE_NAME = "$4")');
                checkElementCssEqualsWebCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element ein CSS-Attribut enthält, dessen Wert dem angegebenen Wert (TEXT_EQUALS) entsprechen muss.');
                items.push(checkElementCssEqualsWebCommandCompletion);
                const checkElementEnabledWebCommandCompletion = new vscode.CompletionItem('checkElementEnabledWeb');
                checkElementEnabledWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementEnabledWebCommandCompletion.insertText = new vscode.SnippetString('checkElementEnabledWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementEnabledWebCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element auf einer Webseite aktiviert ist. Damit ist es auch vorhanden und sichtbar. Aktiviert heisst, dass das Element z.B. angeklickt werden oder ein Text reingeschrieben werden kann.');
                items.push(checkElementEnabledWebCommandCompletion);
                const checkElementNotPresentCommandCompletion = new vscode.CompletionItem('checkElementNotPresent');
                checkElementNotPresentCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementNotPresentCommandCompletion.insertText = new vscode.SnippetString('checkElementNotPresent(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementNotPresentCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element auf einer Webseite nicht vorhanden ist. Die Überprüfung macht insbesondere dann Sinn, wenn ein Element (z.B. in einer Liste) zuvor vorhanden war.');
                items.push(checkElementNotPresentCommandCompletion);
                const checkElementNotPresentWebCommandCompletion = new vscode.CompletionItem('checkElementNotPresentWeb');
                checkElementNotPresentWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementNotPresentWebCommandCompletion.insertText = new vscode.SnippetString('checkElementNotPresentWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementNotPresentWebCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element auf einer Webseite nicht vorhanden ist. Die Überprüfung macht insbesondere dann Sinn, wenn ein Element (z.B. in einer Liste) zuvor vorhanden war.');
                items.push(checkElementNotPresentWebCommandCompletion);
                const checkElementPresentCommandCompletion = new vscode.CompletionItem('checkElementPresent');
                checkElementPresentCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementPresentCommandCompletion.insertText = new vscode.SnippetString('checkElementPresent(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementPresentCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element auf einer Webseite vorhanden ist. D.h. nicht, dass das Element sichtbar oder aktiv sein muss.');
                items.push(checkElementPresentCommandCompletion);
                const checkElementPresentWebCommandCompletion = new vscode.CompletionItem('checkElementPresentWeb');
                checkElementPresentWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementPresentWebCommandCompletion.insertText = new vscode.SnippetString('checkElementPresentWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementPresentWebCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element auf einer Webseite vorhanden ist. D.h. nicht, dass das Element sichtbar oder aktiv sein muss.');
                items.push(checkElementPresentWebCommandCompletion);
                const checkElementSelectedWebCommandCompletion = new vscode.CompletionItem('checkElementSelectedWeb');
                checkElementSelectedWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementSelectedWebCommandCompletion.insertText = new vscode.SnippetString('checkElementSelectedWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementSelectedWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando überprüft, ob ein Element auf einer Webseite ausgewählt ist.');
                items.push(checkElementSelectedWebCommandCompletion);
                const checkElementTextEqualsWebCommandCompletion = new vscode.CompletionItem('checkElementTextEqualsWeb');
                checkElementTextEqualsWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementTextEqualsWebCommandCompletion.insertText = new vscode.SnippetString('checkElementTextEqualsWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementTextEqualsWebCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element den übergebenen Text enthält.');
                items.push(checkElementTextEqualsWebCommandCompletion);
                const checkElementVisibleWebCommandCompletion = new vscode.CompletionItem('checkElementVisibleWeb');
                checkElementVisibleWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkElementVisibleWebCommandCompletion.insertText = new vscode.SnippetString('checkElementVisibleWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                checkElementVisibleWebCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Element auf einer Webseite sichtbar ist. Damit ist es vorhanden aber nicht zwingend auch aktiv.');
                items.push(checkElementVisibleWebCommandCompletion);
                const checkFileContentCommandCompletion = new vscode.CompletionItem('checkFileContent');
                checkFileContentCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkFileContentCommandCompletion.insertText = new vscode.SnippetString('checkFileContent(FILENAME = "$1", TEXT_EQUALS = "$2")');
                checkFileContentCommandCompletion.documentation = new vscode.MarkdownString('Kommando sucht innerhalb einer Datei zeilenbasiert nach einem bestimmten String.     Zunächst wird die gesamte Datei durchsucht.     Im Nachgang werden für waitTimeMillis noch neue Daten verarbeitet.     Wird der String an irgendeiner Stelle gefunden, so wird die Suche unmittelbar beendet und das Ergebnis "Erfolg" zurückgemeldet.');
                items.push(checkFileContentCommandCompletion);
                const checkFileExistsCommandCompletion = new vscode.CompletionItem('checkFileExists');
                checkFileExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkFileExistsCommandCompletion.insertText = new vscode.SnippetString('checkFileExists(FILENAME = "$1")');
                checkFileExistsCommandCompletion.documentation = new vscode.MarkdownString('Sucht nach einer Datei und schließt mit dem Status "Erfolg" ab, falls diese gefunden wurde.    Das Kommando lässt sich in Bedingungen einsetzen, um Prozesse zu steuern.');
                items.push(checkFileExistsCommandCompletion);
                const checkIfFileExistsCommandCompletion = new vscode.CompletionItem('checkIfFileExists');
                checkIfFileExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkIfFileExistsCommandCompletion.insertText = new vscode.SnippetString('checkIfFileExists(FILENAME = "$1")');
                checkIfFileExistsCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob eine Datei vorhanden ist.');
                items.push(checkIfFileExistsCommandCompletion);
                const checkIfStorageVariableIsSetCommandCompletion = new vscode.CompletionItem('checkIfStorageVariableIsSet');
                checkIfStorageVariableIsSetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkIfStorageVariableIsSetCommandCompletion.insertText = new vscode.SnippetString('checkIfStorageVariableIsSet(STORAGE_VARIABLE = "$1")');
                checkIfStorageVariableIsSetCommandCompletion.documentation = new vscode.MarkdownString('Überprüft ob eine Storage Variable gesetzt ist und ob diese leer bzw. nicht leer ist.');
                items.push(checkIfStorageVariableIsSetCommandCompletion);
                const checkIfWindowExistsCommandCompletion = new vscode.CompletionItem('checkIfWindowExists');
                checkIfWindowExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkIfWindowExistsCommandCompletion.insertText = new vscode.SnippetString('checkIfWindowExists(WINDOW_NAME = "$1")');
                checkIfWindowExistsCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Fenster vorhanden ist.');
                items.push(checkIfWindowExistsCommandCompletion);
                const checkRadioButtonIsSelectableWinEleCommandCompletion = new vscode.CompletionItem('checkRadioButtonIsSelectableWinEle');
                checkRadioButtonIsSelectableWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkRadioButtonIsSelectableWinEleCommandCompletion.insertText = new vscode.SnippetString('checkRadioButtonIsSelectableWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", SHOULD_BE = "$3")');
                checkRadioButtonIsSelectableWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando prüft, ob ein Radio-Button selektierbar ist.');
                items.push(checkRadioButtonIsSelectableWinEleCommandCompletion);
                const checkRadioButtonIsSelectedWinEleCommandCompletion = new vscode.CompletionItem('checkRadioButtonIsSelectedWinEle');
                checkRadioButtonIsSelectedWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkRadioButtonIsSelectedWinEleCommandCompletion.insertText = new vscode.SnippetString('checkRadioButtonIsSelectedWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", SHOULD_BE = "$3")');
                checkRadioButtonIsSelectedWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando prüft, ob ein Radio-Button selektiert ist.');
                items.push(checkRadioButtonIsSelectedWinEleCommandCompletion);
                const checkRadioButtonWinEleCommandCompletion = new vscode.CompletionItem('checkRadioButtonWinEle');
                checkRadioButtonWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkRadioButtonWinEleCommandCompletion.insertText = new vscode.SnippetString('checkRadioButtonWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2")');
                checkRadioButtonWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando aktiviert einen Radio-Button.');
                items.push(checkRadioButtonWinEleCommandCompletion);
                const checkResultByImageCPCommandCompletion = new vscode.CompletionItem('checkResultByImageCP');
                checkResultByImageCPCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkResultByImageCPCommandCompletion.insertText = new vscode.SnippetString('checkResultByImageCP(IMAGE_PATH = "$1")');
                checkResultByImageCPCommandCompletion.documentation = new vscode.MarkdownString('Mit Hilfe dieses Kommandos wird ein Ergebnis anhand eines Bildes sichergestellt. Wenn das angegebene Bild in dem Fenster gefunden wird, ist das Ergebnis der Ueberpruefung positiv.');
                items.push(checkResultByImageCPCommandCompletion);
                const checkResultByImageWinCommandCompletion = new vscode.CompletionItem('checkResultByImageWin');
                checkResultByImageWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkResultByImageWinCommandCompletion.insertText = new vscode.SnippetString('checkResultByImageWin(WINDOW_NAME = "$1", IMAGE_RELATIVE_PATH = "$2")');
                checkResultByImageWinCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob in einem Fenster ein Bild gefunden werden kann.');
                items.push(checkResultByImageWinCommandCompletion);
                const checkResultByTextWinCommandCompletion = new vscode.CompletionItem('checkResultByTextWin');
                checkResultByTextWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkResultByTextWinCommandCompletion.insertText = new vscode.SnippetString('checkResultByTextWin(WINDOW_NAME = "$1", TEXT_EQUALS = "$2")');
                checkResultByTextWinCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob in einem Fenster ein Text enthalten ist. Betrachtet wird das gesamte Fenster.');
                items.push(checkResultByTextWinCommandCompletion);
                const checkResultWebCommandCompletion = new vscode.CompletionItem('checkResultWeb');
                checkResultWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkResultWebCommandCompletion.insertText = new vscode.SnippetString('checkResultWeb(TEXT_EQUALS = "$1")');
                checkResultWebCommandCompletion.documentation = new vscode.MarkdownString('Prüft, ob der übergebene Text mit dem Text des Elements bzw. der Webseite identisch ist.     Wenn nur der Pflichtparameter "TEXT_EQUALS" benutzt wird, wird der Text der gesamten Webseite untersucht.    Wenn BY_CRITERIA und ELEMENT_NAME angegeben wurden, wird in einem konkreten Element gesucht wird.');
                items.push(checkResultWebCommandCompletion);
                const checkTextOnCitrixTextFieldCommandCompletion = new vscode.CompletionItem('checkTextOnCitrixTextField');
                checkTextOnCitrixTextFieldCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkTextOnCitrixTextFieldCommandCompletion.insertText = new vscode.SnippetString('checkTextOnCitrixTextField(WINDOW_NAME = "$1", IMAGE_RELATIVE_PATH = "$2", TEXT_EQUALS = "$3")');
                checkTextOnCitrixTextFieldCommandCompletion.documentation = new vscode.MarkdownString('Prüft mittels AutohotKey den Text eines Textfeldes inhaltlich durch Kopie in die Zwischenablage auf einen Prüf-String');
                items.push(checkTextOnCitrixTextFieldCommandCompletion);
                const checkTextboxReadOnlyFocussedWinEleCommandCompletion = new vscode.CompletionItem('checkTextboxReadOnlyFocussedWinEle');
                checkTextboxReadOnlyFocussedWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                checkTextboxReadOnlyFocussedWinEleCommandCompletion.insertText = new vscode.SnippetString('checkTextboxReadOnlyFocussedWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", SHOULD_BE = "$3")');
                checkTextboxReadOnlyFocussedWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando prüft, ob das fokussierte Textfeld die Eigenschaft "readOnly" besitzt und vergleicht das Ergebnis mit dem Parameter SHOULD_BE (true/false).');
                items.push(checkTextboxReadOnlyFocussedWinEleCommandCompletion);
                const clearFullscreenImageRendererCommandCompletion = new vscode.CompletionItem('clearFullscreenImageRenderer');
                clearFullscreenImageRendererCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clearFullscreenImageRendererCommandCompletion.insertText = new vscode.SnippetString('clearFullscreenImageRenderer()');
                clearFullscreenImageRendererCommandCompletion.documentation = new vscode.MarkdownString('Versteckt alle aktuell angezeigten Bilder. ');
                items.push(clearFullscreenImageRendererCommandCompletion);
                const clearOverlayImageRendererCommandCompletion = new vscode.CompletionItem('clearOverlayImageRenderer');
                clearOverlayImageRendererCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clearOverlayImageRendererCommandCompletion.insertText = new vscode.SnippetString('clearOverlayImageRenderer()');
                clearOverlayImageRendererCommandCompletion.documentation = new vscode.MarkdownString('Versteckt alle aktuell angezeigten Bilder. ');
                items.push(clearOverlayImageRendererCommandCompletion);
                const clearStorageCommandCompletion = new vscode.CompletionItem('clearStorage');
                clearStorageCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clearStorageCommandCompletion.insertText = new vscode.SnippetString('clearStorage()');
                clearStorageCommandCompletion.documentation = new vscode.MarkdownString('Leert die Storage Datei.');
                items.push(clearStorageCommandCompletion);
                const clearStorageValueCommandCompletion = new vscode.CompletionItem('clearStorageValue');
                clearStorageValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clearStorageValueCommandCompletion.insertText = new vscode.SnippetString('clearStorageValue(TARGET_STORAGE_KEY = "$1")');
                clearStorageValueCommandCompletion.documentation = new vscode.MarkdownString('Löscht eine Laufzeitvariable. ');
                items.push(clearStorageValueCommandCompletion);
                const clearTextRendererCommandCompletion = new vscode.CompletionItem('clearTextRenderer');
                clearTextRendererCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clearTextRendererCommandCompletion.insertText = new vscode.SnippetString('clearTextRenderer()');
                clearTextRendererCommandCompletion.documentation = new vscode.MarkdownString('Versteckt alle aktuell angezeigten Texte. ');
                items.push(clearTextRendererCommandCompletion);
                const clearTextWebCommandCompletion = new vscode.CompletionItem('clearTextWeb');
                clearTextWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clearTextWebCommandCompletion.insertText = new vscode.SnippetString('clearTextWeb(ELEMENT_NAME = "$1")');
                clearTextWebCommandCompletion.documentation = new vscode.MarkdownString('Löscht den Inhalt des angegebenen Elements (z. B. Textfeld).');
                items.push(clearTextWebCommandCompletion);
                const clickButtonAutomIdWinEleCommandCompletion = new vscode.CompletionItem('clickButtonAutomIdWinEle');
                clickButtonAutomIdWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickButtonAutomIdWinEleCommandCompletion.insertText = new vscode.SnippetString('clickButtonAutomIdWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", BUTTON_AUTOMATION_ID = "$3")');
                clickButtonAutomIdWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt auf einen Button anhand dessen Automation-ID.');
                items.push(clickButtonAutomIdWinEleCommandCompletion);
                const clickButtonWinEleCommandCompletion = new vscode.CompletionItem('clickButtonWinEle');
                clickButtonWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickButtonWinEleCommandCompletion.insertText = new vscode.SnippetString('clickButtonWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", BUTTON_NAME = "$3")');
                clickButtonWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt auf einen Button anhand dessen Namen.');
                items.push(clickButtonWinEleCommandCompletion);
                const clickByIdWebCommandCompletion = new vscode.CompletionItem('clickByIdWeb');
                clickByIdWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickByIdWebCommandCompletion.insertText = new vscode.SnippetString('clickByIdWeb(ELEMENT_NAME = "$1")');
                clickByIdWebCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf ein Web-Element anhand seiner ID. Achtung! Einige Frameworks erzeugen für Elemente IDs zur Laufzeit. Dadurch sind diese nach Server-Neustarts oder auch nach Seiten-Neuaufrufen unterschiedlich.');
                items.push(clickByIdWebCommandCompletion);
                const clickByTextJavaCommandCompletion = new vscode.CompletionItem('clickByTextJava');
                clickByTextJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickByTextJavaCommandCompletion.insertText = new vscode.SnippetString('clickByTextJava(TARGET = "$1")');
                clickByTextJavaCommandCompletion.documentation = new vscode.MarkdownString('Klickt ein angegebenes Element einer Java Anwendung an.');
                items.push(clickByTextJavaCommandCompletion);
                const clickByTextWebCommandCompletion = new vscode.CompletionItem('clickByTextWeb');
                clickByTextWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickByTextWebCommandCompletion.insertText = new vscode.SnippetString('clickByTextWeb(ELEMENT_NAME = "$1")');
                clickByTextWebCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf einen Link, der anhand seines Linktextes ermittelt wird.');
                items.push(clickByTextWebCommandCompletion);
                const clickCoordinateWinCommandCompletion = new vscode.CompletionItem('clickCoordinateWin');
                clickCoordinateWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickCoordinateWinCommandCompletion.insertText = new vscode.SnippetString('clickCoordinateWin(WINDOW_NAME = "$1", X = "$2", Y = "$3")');
                clickCoordinateWinCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf eine feste Koordinate innerhalb eines Fenster. Sehr schnell und sehr fehleranfällig.');
                items.push(clickCoordinateWinCommandCompletion);
                const clickCursorWinCommandCompletion = new vscode.CompletionItem('clickCursorWin');
                clickCursorWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickCursorWinCommandCompletion.insertText = new vscode.SnippetString('clickCursorWin(WINDOW_NAME = "$1")');
                clickCursorWinCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf die Position in einem Fenster, an der sich der Cursor aktuell befindet.');
                items.push(clickCursorWinCommandCompletion);
                const clickImageCPCommandCompletion = new vscode.CompletionItem('clickImageCP');
                clickImageCPCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickImageCPCommandCompletion.insertText = new vscode.SnippetString('clickImageCP(IMAGE_PATH = "$1")');
                clickImageCPCommandCompletion.documentation = new vscode.MarkdownString('Sucht ein Bild in einem Fenster und klickt bei erfolgreicher Suche auf dessen Mittelpunkt');
                items.push(clickImageCPCommandCompletion);
                const clickImageWinCommandCompletion = new vscode.CompletionItem('clickImageWin');
                clickImageWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickImageWinCommandCompletion.insertText = new vscode.SnippetString('clickImageWin(WINDOW_NAME = "$1", IMAGE_RELATIVE_PATH = "$2")');
                clickImageWinCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf eine Position in einem Fenster, die anhand eines Bildes gefunden wird. Geklickt wird auf die Mitte des Bildes.');
                items.push(clickImageWinCommandCompletion);
                const clickItemByTextJavaCommandCompletion = new vscode.CompletionItem('clickItemByTextJava');
                clickItemByTextJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickItemByTextJavaCommandCompletion.insertText = new vscode.SnippetString('clickItemByTextJava(TARGET = "$1", TEXT = "$2")');
                clickItemByTextJavaCommandCompletion.documentation = new vscode.MarkdownString('Klickt ein angegebenes Element innerhalb einer Liste, Trees oder Tabelle einer Java Anwendung an.');
                items.push(clickItemByTextJavaCommandCompletion);
                const clickJavaCommandCompletion = new vscode.CompletionItem('clickJava');
                clickJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickJavaCommandCompletion.insertText = new vscode.SnippetString('clickJava(TARGET = "$1")');
                clickJavaCommandCompletion.documentation = new vscode.MarkdownString('Klickt ein angegebenes Element einer Java Anwendung an.');
                items.push(clickJavaCommandCompletion);
                const clickMenuAutomIdWinEleCommandCompletion = new vscode.CompletionItem('clickMenuAutomIdWinEle');
                clickMenuAutomIdWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickMenuAutomIdWinEleCommandCompletion.insertText = new vscode.SnippetString('clickMenuAutomIdWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", MENUBAR_NAME = "$3", MENU_AUTOMATION_ID = "$4", MENU_ITEM_AUTOMATION_ID = "$5")');
                clickMenuAutomIdWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt auf eine Menüauswahl anhand der Automation-ID.');
                items.push(clickMenuAutomIdWinEleCommandCompletion);
                const clickMenuWinEleCommandCompletion = new vscode.CompletionItem('clickMenuWinEle');
                clickMenuWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickMenuWinEleCommandCompletion.insertText = new vscode.SnippetString('clickMenuWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", MENUBAR_NAME = "$3", MENU_NAME = "$4", MENU_ITEM_NAME = "$5")');
                clickMenuWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt auf einen Menüpunkt anhand dessen Namen.');
                items.push(clickMenuWinEleCommandCompletion);
                const clickMenuWindowWinCommandCompletion = new vscode.CompletionItem('clickMenuWindowWin');
                clickMenuWindowWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickMenuWindowWinCommandCompletion.insertText = new vscode.SnippetString('clickMenuWindowWin(WINDOW_NAME = "$1", MENU_IMAGE_RELATIVE_PATH = "$2", WAIT_TIME_BETWEEN_CLICKS = "$3", SUBMENU_IMAGE_RELATIVE_PATH = "$4")');
                clickMenuWindowWinCommandCompletion.documentation = new vscode.MarkdownString('Öffnet ein Menü und klickt dann auf einen angegebenen Untermenüpunkt');
                items.push(clickMenuWindowWinCommandCompletion);
                const clickTabWinEleCommandCompletion = new vscode.CompletionItem('clickTabWinEle');
                clickTabWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickTabWinEleCommandCompletion.insertText = new vscode.SnippetString('clickTabWinEle(PROCESS_NAME = "$1", WINDOW_NAME = "$2", TAB_NAME = "$3")');
                clickTabWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt auf einen Tab anhand dessen Namen.');
                items.push(clickTabWinEleCommandCompletion);
                const clickTextInPictureCommandCompletion = new vscode.CompletionItem('clickTextInPicture');
                clickTextInPictureCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickTextInPictureCommandCompletion.insertText = new vscode.SnippetString('clickTextInPicture(WINDOW_NAME = "$1", TEXT_TO_CLICK = "$2")');
                clickTextInPictureCommandCompletion.documentation = new vscode.MarkdownString('Untersucht ein Bild oder einen Ausschnitt und klickt auf die Position des angegebenen Textes.');
                items.push(clickTextInPictureCommandCompletion);
                const clickWebCommandCompletion = new vscode.CompletionItem('clickWeb');
                clickWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickWebCommandCompletion.insertText = new vscode.SnippetString('clickWeb(ELEMENT_NAME = "$1")');
                clickWebCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf ein Element der geöffneten Browser-Seite.');
                items.push(clickWebCommandCompletion);
                const clickWebFastCommandCompletion = new vscode.CompletionItem('clickWebFast');
                clickWebFastCommandCompletion.kind = vscode.CompletionItemKind.Function;
                clickWebFastCommandCompletion.insertText = new vscode.SnippetString('clickWebFast(ELEMENT_NAME = "$1")');
                clickWebFastCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf ein Element, ohne auf seine Existenz zu warten. Ist daher nicht immer stabil!');
                items.push(clickWebFastCommandCompletion);
                const closeApplicationCommandCompletion = new vscode.CompletionItem('closeApplication');
                closeApplicationCommandCompletion.kind = vscode.CompletionItemKind.Function;
                closeApplicationCommandCompletion.insertText = new vscode.SnippetString('closeApplication(TITLE = "$1")');
                closeApplicationCommandCompletion.documentation = new vscode.MarkdownString('Schließt eine Anwendung.');
                items.push(closeApplicationCommandCompletion);
                const closeApplicationCPCommandCompletion = new vscode.CompletionItem('closeApplicationCP');
                closeApplicationCPCommandCompletion.kind = vscode.CompletionItemKind.Function;
                closeApplicationCPCommandCompletion.insertText = new vscode.SnippetString('closeApplicationCP(WINDOW_NAME = "$1")');
                closeApplicationCPCommandCompletion.documentation = new vscode.MarkdownString('Schließt eine Applikation anhand des Fenster-Namens.');
                items.push(closeApplicationCPCommandCompletion);
                const closeApplicationWinCommandCompletion = new vscode.CompletionItem('closeApplicationWin');
                closeApplicationWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                closeApplicationWinCommandCompletion.insertText = new vscode.SnippetString('closeApplicationWin(WINDOW_NAME = "$1")');
                closeApplicationWinCommandCompletion.documentation = new vscode.MarkdownString('Schließt eine Windows-Anwendung');
                items.push(closeApplicationWinCommandCompletion);
                const closeApplicationWinEleCommandCompletion = new vscode.CompletionItem('closeApplicationWinEle');
                closeApplicationWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                closeApplicationWinEleCommandCompletion.insertText = new vscode.SnippetString('closeApplicationWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2")');
                closeApplicationWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando schließt eine Windows-Anwendung.');
                items.push(closeApplicationWinEleCommandCompletion);
                const closeSqlCommandCompletion = new vscode.CompletionItem('closeSql');
                closeSqlCommandCompletion.kind = vscode.CompletionItemKind.Function;
                closeSqlCommandCompletion.insertText = new vscode.SnippetString('closeSql(CONNECTION_NAME = "$1")');
                closeSqlCommandCompletion.documentation = new vscode.MarkdownString('Schließt eine bestehende Datenbankverbindung');
                items.push(closeSqlCommandCompletion);
                const cobol2XmlCommandCompletion = new vscode.CompletionItem('cobol2Xml');
                cobol2XmlCommandCompletion.kind = vscode.CompletionItemKind.Function;
                cobol2XmlCommandCompletion.insertText = new vscode.SnippetString('cobol2Xml(INPUT_BIN = "$1", COPYBOOK = "$2", OUTPUT_XML = "$3")');
                cobol2XmlCommandCompletion.documentation = new vscode.MarkdownString('Kommando zum übersetzen einer Host XML mittels Copybook in eine binär-Datei. Es wird CP037 als Ausgabedialekt verwendet.');
                items.push(cobol2XmlCommandCompletion);
                const comfortClickWinCommandCompletion = new vscode.CompletionItem('comfortClickWin');
                comfortClickWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                comfortClickWinCommandCompletion.insertText = new vscode.SnippetString('comfortClickWin(WINDOW_NAME = "$1", RELATIVE_PATH_IMAGE = "$2")');
                comfortClickWinCommandCompletion.documentation = new vscode.MarkdownString('Zusammenfassung mehrerer Kommandos. Es wird auf ein Fenster gewartet und innerhalb dieses Fensters ein Bild erwartet. Wenn dieses Bild vorhanden ist, wird die entsprechende Position angeklickt. Wird all das nicht innerhalb der angebenen Zeitspanne geschafft, wird ein Fehler ausgegeben.');
                items.push(comfortClickWinCommandCompletion);
                const comfortSendTextWinCommandCompletion = new vscode.CompletionItem('comfortSendTextWin');
                comfortSendTextWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                comfortSendTextWinCommandCompletion.insertText = new vscode.SnippetString('comfortSendTextWin(WINDOW_NAME = "$1", TEXT_TO_SEND = "$2")');
                comfortSendTextWinCommandCompletion.documentation = new vscode.MarkdownString('Ist die Zusammenfassung mehrerer Kommandos. Es wird auf ein Fenster gewartet und innerhalb dieses Fensters ein Bild erwartet. Wenn dieses Bild vorhanden ist, wird die entsprechende Position angeklickt. Danach wird ein Text an das Fenster übergeben. Wird all das nicht innerhalb der angegebenen Zeitspanne geschafft, wird ein Fehler ausgegeben.');
                items.push(comfortSendTextWinCommandCompletion);
                const comfortWaitWindowCommandCompletion = new vscode.CompletionItem('comfortWaitWindow');
                comfortWaitWindowCommandCompletion.kind = vscode.CompletionItemKind.Function;
                comfortWaitWindowCommandCompletion.insertText = new vscode.SnippetString('comfortWaitWindow(WINDOW_NAME = "$1")');
                comfortWaitWindowCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf ein Fenster. Erscheint das Fenster nicht in der angebenen Zeitspanne, wird ein Fehler gemeldet.');
                items.push(comfortWaitWindowCommandCompletion);
                const commentCommandCompletion = new vscode.CompletionItem('comment');
                commentCommandCompletion.kind = vscode.CompletionItemKind.Function;
                commentCommandCompletion.insertText = new vscode.SnippetString('comment(TEXT = "$1")');
                commentCommandCompletion.documentation = new vscode.MarkdownString('Ermöglicht einen kontextbezogenen Kommentar in die Testdokumentation einzufügen. Schließt mit dem Ergebnislevel "NoRun" ab.');
                items.push(commentCommandCompletion);
                const compareChangesSqlCommandCompletion = new vscode.CompletionItem('compareChangesSql');
                compareChangesSqlCommandCompletion.kind = vscode.CompletionItemKind.Function;
                compareChangesSqlCommandCompletion.insertText = new vscode.SnippetString('compareChangesSql(CONNECTION_NAME = "$1", TABLE_BEFORE = "$2", TABLE_AFTER = "$3", PRIMARY_KEYS = "$4")');
                compareChangesSqlCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht zwei Tabellen zeilenweise auf Unterschiede zueinander, z.B. nach einer ETL-Transformation. Beide Tabellen müssen die gleichen Spalten haben.     Die Werte in den Primärschlüsselspalten zwischen zwei miteinander zu vergleichenden Zeilen in den jeweiligen Tabellen dürfen sich nicht voneinander unterscheiden.');
                items.push(compareChangesSqlCommandCompletion);
                const compareTextCommandCompletion = new vscode.CompletionItem('compareText');
                compareTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                compareTextCommandCompletion.insertText = new vscode.SnippetString('compareText(TEXT1 = "$1", TEXT2 = "$2")');
                compareTextCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht zwei Texte/Textdateien und gibt Zeilen mit unterschiedlichem Inhalt zurück. Die Zählung der Zeilen beginnt bei 1.');
                items.push(compareTextCommandCompletion);
                const containsAlphaCommandCompletion = new vscode.CompletionItem('containsAlpha');
                containsAlphaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                containsAlphaCommandCompletion.insertText = new vscode.SnippetString('containsAlpha(TEXT = "$1", VALUE = "$2")');
                containsAlphaCommandCompletion.documentation = new vscode.MarkdownString('Prüft, ob ein Wert in einem Text enthalten ist. Falls ja, gibt er true zurück, sonst false');
                items.push(containsAlphaCommandCompletion);
                const controlClickCommandCompletion = new vscode.CompletionItem('controlClick');
                controlClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlClickCommandCompletion.insertText = new vscode.SnippetString('controlClick(WINDOW_NAME = "$1", CONTROL = "$2")');
                controlClickCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Mausklick-Befehl an das angegebene Control.');
                items.push(controlClickCommandCompletion);
                const controlCommandCommandCompletion = new vscode.CompletionItem('controlCommand');
                controlCommandCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlCommandCommandCompletion.insertText = new vscode.SnippetString('controlCommand(WINDOW_NAME = "$1", CONTROL = "$2", MODE = "$3")');
                controlCommandCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Control Command an das angegebene Control. (https://www.autoitscript.com/autoit3/docs/functions/ControlCommand.htm)');
                items.push(controlCommandCommandCompletion);
                const controlDisableCommandCompletion = new vscode.CompletionItem('controlDisable');
                controlDisableCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlDisableCommandCompletion.insertText = new vscode.SnippetString('controlDisable(WINDOW_NAME = "$1", CONTROL = "$2")');
                controlDisableCommandCompletion.documentation = new vscode.MarkdownString('Deaktiviert ein bestimmtes Control.');
                items.push(controlDisableCommandCompletion);
                const controlDoubleClickCommandCompletion = new vscode.CompletionItem('controlDoubleClick');
                controlDoubleClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlDoubleClickCommandCompletion.insertText = new vscode.SnippetString('controlDoubleClick(WINDOW_NAME = "$1", CONTROL = "$2")');
                controlDoubleClickCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Doppelklick-Befehl an das angegebene Control.');
                items.push(controlDoubleClickCommandCompletion);
                const controlEnableCommandCompletion = new vscode.CompletionItem('controlEnable');
                controlEnableCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlEnableCommandCompletion.insertText = new vscode.SnippetString('controlEnable(WINDOW_NAME = "$1", CONTROL = "$2")');
                controlEnableCommandCompletion.documentation = new vscode.MarkdownString('Aktiviert ein bestimmtes Control.');
                items.push(controlEnableCommandCompletion);
                const controlFocusCommandCompletion = new vscode.CompletionItem('controlFocus');
                controlFocusCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlFocusCommandCompletion.insertText = new vscode.SnippetString('controlFocus(WINDOW_NAME = "$1", CONTROL = "$2")');
                controlFocusCommandCompletion.documentation = new vscode.MarkdownString('Fokussiert ein bestimmtes Control.');
                items.push(controlFocusCommandCompletion);
                const controlGetTextCommandCompletion = new vscode.CompletionItem('controlGetText');
                controlGetTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlGetTextCommandCompletion.insertText = new vscode.SnippetString('controlGetText(WINDOW_NAME = "$1", CONTROL = "$2")');
                controlGetTextCommandCompletion.documentation = new vscode.MarkdownString('Liest den Text eines bestimmten Controls aus.');
                items.push(controlGetTextCommandCompletion);
                const controlHideCommandCompletion = new vscode.CompletionItem('controlHide');
                controlHideCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlHideCommandCompletion.insertText = new vscode.SnippetString('controlHide(WINDOW_NAME = "$1", CONTROL = "$2")');
                controlHideCommandCompletion.documentation = new vscode.MarkdownString('Versteckt ein bestimmtes Control.');
                items.push(controlHideCommandCompletion);
                const controlListViewCommandCompletion = new vscode.CompletionItem('controlListView');
                controlListViewCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlListViewCommandCompletion.insertText = new vscode.SnippetString('controlListView(WINDOW_NAME = "$1", CONTROL = "$2", MODE = "$3")');
                controlListViewCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Control Command an das angegebene ListView32 Control. (https://www.autoitscript.com/autoit3/docs/functions/ControlListView.htm)');
                items.push(controlListViewCommandCompletion);
                const controlSendCommandCompletion = new vscode.CompletionItem('controlSend');
                controlSendCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlSendCommandCompletion.insertText = new vscode.SnippetString('controlSend(WINDOW_NAME = "$1", CONTROL = "$2", TEXT_TO_SEND = "$3")');
                controlSendCommandCompletion.documentation = new vscode.MarkdownString('Sendet eine Tastatureingabe an ein bestimmtes Control. Vgl. Autoit/AutoHotkey Tasteneingaben in der Dokumenation.');
                items.push(controlSendCommandCompletion);
                const controlSetTextCommandCompletion = new vscode.CompletionItem('controlSetText');
                controlSetTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlSetTextCommandCompletion.insertText = new vscode.SnippetString('controlSetText(WINDOW_NAME = "$1", CONTROL = "$2", TEXT_TO_SET = "$3")');
                controlSetTextCommandCompletion.documentation = new vscode.MarkdownString('Setzt den Text eines bestimmten Controls.');
                items.push(controlSetTextCommandCompletion);
                const controlShowCommandCompletion = new vscode.CompletionItem('controlShow');
                controlShowCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlShowCommandCompletion.insertText = new vscode.SnippetString('controlShow(WINDOW_NAME = "$1", CONTROL = "$2")');
                controlShowCommandCompletion.documentation = new vscode.MarkdownString('Zeigt ein bestimmtes Control.');
                items.push(controlShowCommandCompletion);
                const controlTreeViewCommandCompletion = new vscode.CompletionItem('controlTreeView');
                controlTreeViewCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlTreeViewCommandCompletion.insertText = new vscode.SnippetString('controlTreeView(WINDOW_NAME = "$1", CONTROL = "$2", MODE = "$3")');
                controlTreeViewCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Control Command an das angegebene TreeView32 Control. (https://www.autoitscript.com/autoit3/docs/functions/ControlTreeView.htm)');
                items.push(controlTreeViewCommandCompletion);
                const controlWaitForCommandCompletion = new vscode.CompletionItem('controlWaitFor');
                controlWaitForCommandCompletion.kind = vscode.CompletionItemKind.Function;
                controlWaitForCommandCompletion.insertText = new vscode.SnippetString('controlWaitFor(WINDOW_NAME = "$1", CONTROL = "$2", MAX_SECONDS_TO_WAIT = "$3")');
                controlWaitForCommandCompletion.documentation = new vscode.MarkdownString('Wartet bis zu einer bestimmten Wartezeit auf ein Control.');
                items.push(controlWaitForCommandCompletion);
                const convertExcelToCsvCommandCompletion = new vscode.CompletionItem('convertExcelToCsv');
                convertExcelToCsvCommandCompletion.kind = vscode.CompletionItemKind.Function;
                convertExcelToCsvCommandCompletion.insertText = new vscode.SnippetString('convertExcelToCsv(FILENAME = "$1", SHEET_INDEX = "$2", DEST_FILENAME = "$3")');
                convertExcelToCsvCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando konvertiert eine Excel-Datei in eine CSV-Datei.');
                items.push(convertExcelToCsvCommandCompletion);
                const copyFileCommandCompletion = new vscode.CompletionItem('copyFile');
                copyFileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                copyFileCommandCompletion.insertText = new vscode.SnippetString('copyFile(FILENAME_FROM = "$1", FILENAME_TO = "$2")');
                copyFileCommandCompletion.documentation = new vscode.MarkdownString('Kommando kopiert eine Datei.');
                items.push(copyFileCommandCompletion);
                const copyTextCPCommandCompletion = new vscode.CompletionItem('copyTextCP');
                copyTextCPCommandCompletion.kind = vscode.CompletionItemKind.Function;
                copyTextCPCommandCompletion.insertText = new vscode.SnippetString('copyTextCP()');
                copyTextCPCommandCompletion.documentation = new vscode.MarkdownString('Kopiert den Inhalt eines Textfeldes in die Zwischenablage. Das Textfeld wird ueber das mehrfache Betaetigen der Tabulator-Taste erreicht.');
                items.push(copyTextCPCommandCompletion);
                const createDirCommandCompletion = new vscode.CompletionItem('createDir');
                createDirCommandCompletion.kind = vscode.CompletionItemKind.Function;
                createDirCommandCompletion.insertText = new vscode.SnippetString('createDir(DIR_ABSOLUTE_PATH = "$1")');
                createDirCommandCompletion.documentation = new vscode.MarkdownString('Erstellt ein Verzeichnis im übergebenen Pfad, inklusive evtl. notwendiger übergeordneter Verzeichnisse.     Kommando ist auch dann erfolgreich, wenn das gewünschte Verzeichnis bereits existiert.');
                items.push(createDirCommandCompletion);
                const csvToJsonCommandCompletion = new vscode.CompletionItem('csvToJson');
                csvToJsonCommandCompletion.kind = vscode.CompletionItemKind.Function;
                csvToJsonCommandCompletion.insertText = new vscode.SnippetString('csvToJson(CSV = "$1")');
                csvToJsonCommandCompletion.documentation = new vscode.MarkdownString('Erstellt aus einer csv-Datei eine entsprechende JSON-Datei');
                items.push(csvToJsonCommandCompletion);
                const deleteAllCookiesMobileCommandCompletion = new vscode.CompletionItem('deleteAllCookiesMobile');
                deleteAllCookiesMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                deleteAllCookiesMobileCommandCompletion.insertText = new vscode.SnippetString('deleteAllCookiesMobile()');
                deleteAllCookiesMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando löscht alle Cookies der aktuell geöffneten Seite im Browsers. Es werden keine Parameter benötigt (Beispiel: deleteAllCookiesMobile()).');
                items.push(deleteAllCookiesMobileCommandCompletion);
                const deleteCookiesWebCommandCompletion = new vscode.CompletionItem('deleteCookiesWeb');
                deleteCookiesWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                deleteCookiesWebCommandCompletion.insertText = new vscode.SnippetString('deleteCookiesWeb()');
                deleteCookiesWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando löscht alle Cookies/das angegebene Cookie auf der aktuellen/angebenen Seite.');
                items.push(deleteCookiesWebCommandCompletion);
                const deleteDirCommandCompletion = new vscode.CompletionItem('deleteDir');
                deleteDirCommandCompletion.kind = vscode.CompletionItemKind.Function;
                deleteDirCommandCompletion.insertText = new vscode.SnippetString('deleteDir(FILENAME = "$1")');
                deleteDirCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando löscht Dateien');
                items.push(deleteDirCommandCompletion);
                const deleteFileCommandCompletion = new vscode.CompletionItem('deleteFile');
                deleteFileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                deleteFileCommandCompletion.insertText = new vscode.SnippetString('deleteFile(FILENAME = "$1")');
                deleteFileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando löscht die mit FILENAME übergebenen Dateien bzw. alle Dateien im angegebenen Verzeichnis. Ist DELETE_DIRECTORY=true, wird ein Verzeichnis angegeben, das zu löschen ist.');
                items.push(deleteFileCommandCompletion);
                const deleteInTextCommandCompletion = new vscode.CompletionItem('deleteInText');
                deleteInTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                deleteInTextCommandCompletion.insertText = new vscode.SnippetString('deleteInText(TEXT_OR_FILE = "$1", WORD = "$2", TARGET_STORAGE_KEY = "$3")');
                deleteInTextCommandCompletion.documentation = new vscode.MarkdownString('Löscht ein bestimmtes Wort oder einen festen Teilbereich in einem Text.Das Kommando sucht nach WORD im Text und löscht jedes Vorkommen.Das bedeutet, dass bei mehreren Vorkommen des WORD auch mehrere Löschungen stattfinden.');
                items.push(deleteInTextCommandCompletion);
                const deleteMailCommandCompletion = new vscode.CompletionItem('deleteMail');
                deleteMailCommandCompletion.kind = vscode.CompletionItemKind.Function;
                deleteMailCommandCompletion.insertText = new vscode.SnippetString('deleteMail(SERVER = "$1", USER = "$2", PASSWORD = "$3", FOLDER = "$4")');
                deleteMailCommandCompletion.documentation = new vscode.MarkdownString('Löscht entweder E-Mails mit bestimmten Betreff, eines Absenders oder alle E-Mails in einem bestimmten Ordner. Wird kein Betreff und kein Absender zum filtern angegeben, werden alle E-Mails im Ordner gelöscht. Wichtig ist, dass das System korrekt konfiguriert ist. Ggf. muss z. B. eine etwaige Firewall den Zugriff auf den angegebenen Mailserver zulassen.');
                items.push(deleteMailCommandCompletion);
                const doCommandCompletion = new vscode.CompletionItem('do');
                doCommandCompletion.kind = vscode.CompletionItemKind.Function;
                doCommandCompletion.insertText = new vscode.SnippetString('do:');
                doCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(doCommandCompletion);
                const doubleClickImageCPCommandCompletion = new vscode.CompletionItem('doubleClickImageCP');
                doubleClickImageCPCommandCompletion.kind = vscode.CompletionItemKind.Function;
                doubleClickImageCPCommandCompletion.insertText = new vscode.SnippetString('doubleClickImageCP(IMAGE_PATH = "$1")');
                doubleClickImageCPCommandCompletion.documentation = new vscode.MarkdownString('Sucht ein Bild in einem Fenster und klickt doppelt bei erfolgreicher Suche auf dessen Mittelpunkt');
                items.push(doubleClickImageCPCommandCompletion);
                const doubleClickImageWinCommandCompletion = new vscode.CompletionItem('doubleClickImageWin');
                doubleClickImageWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                doubleClickImageWinCommandCompletion.insertText = new vscode.SnippetString('doubleClickImageWin(WINDOW_NAME = "$1", IMAGE_RELATIVE_PATH = "$2")');
                doubleClickImageWinCommandCompletion.documentation = new vscode.MarkdownString('Führ einen Doppelklick anhand eines zu Übergebenden Bildes in einer Anwendung aus.');
                items.push(doubleClickImageWinCommandCompletion);
                const doubleclickWebCommandCompletion = new vscode.CompletionItem('doubleclickWeb');
                doubleclickWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                doubleclickWebCommandCompletion.insertText = new vscode.SnippetString('doubleclickWeb(ELEMENT_NAME = "$1")');
                doubleclickWebCommandCompletion.documentation = new vscode.MarkdownString('Klickt doppelt auf ein Element.');
                items.push(doubleclickWebCommandCompletion);
                const dragAndDropWebCommandCompletion = new vscode.CompletionItem('dragAndDropWeb');
                dragAndDropWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                dragAndDropWebCommandCompletion.insertText = new vscode.SnippetString('dragAndDropWeb(START_ELEMENT_NAME = "$1", END_ELEMENT_NAME = "$2")');
                dragAndDropWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt auf das angegebene Element, anhand eines Suchkriteriums und hält die Maustaste fest. Danach wird die Maus auf ein Ziel mit einem optionalen Offset verschoben und die Maustaste wieder losgelassen.');
                items.push(dragAndDropWebCommandCompletion);
                const dragByCoordinatesCommandCompletion = new vscode.CompletionItem('dragByCoordinates');
                dragByCoordinatesCommandCompletion.kind = vscode.CompletionItemKind.Function;
                dragByCoordinatesCommandCompletion.insertText = new vscode.SnippetString('dragByCoordinates(WINDOW_NAME = "$1", MOVE_FROM_X = "$2", MOVE_FROM_Y = "$3", MOVE_TO_X = "$4", MOVE_TO_Y = "$5")');
                dragByCoordinatesCommandCompletion.documentation = new vscode.MarkdownString('Drag-and-Drop anhand von Start und Zielkoordinaten');
                items.push(dragByCoordinatesCommandCompletion);
                const dragByImageWinCommandCompletion = new vscode.CompletionItem('dragByImageWin');
                dragByImageWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                dragByImageWinCommandCompletion.insertText = new vscode.SnippetString('dragByImageWin(WINDOW_NAME = "$1", START_IMAGE_RELATIVE_PATH = "$2")');
                dragByImageWinCommandCompletion.documentation = new vscode.MarkdownString('Drag-and-Drop anhand eines Bildes und einer Zielposition');
                items.push(dragByImageWinCommandCompletion);
                const elseCommandCompletion = new vscode.CompletionItem('else');
                elseCommandCompletion.kind = vscode.CompletionItemKind.Function;
                elseCommandCompletion.insertText = new vscode.SnippetString('else:');
                elseCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(elseCommandCompletion);
                const elseIfCommandCompletion = new vscode.CompletionItem('elseIf');
                elseIfCommandCompletion.kind = vscode.CompletionItemKind.Function;
                elseIfCommandCompletion.insertText = new vscode.SnippetString('elseIf():');
                elseIfCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(elseIfCommandCompletion);
                const emptyCommandCompletion = new vscode.CompletionItem('empty');
                emptyCommandCompletion.kind = vscode.CompletionItemKind.Function;
                emptyCommandCompletion.insertText = new vscode.SnippetString('empty()');
                emptyCommandCompletion.documentation = new vscode.MarkdownString('Überprüft ob der übergebene Parameter leer ist i.S.v. ob seine Länge gleich 0 ist.');
                items.push(emptyCommandCompletion);
                const emptyOrUndeclaredCommandCompletion = new vscode.CompletionItem('emptyOrUndeclared');
                emptyOrUndeclaredCommandCompletion.kind = vscode.CompletionItemKind.Function;
                emptyOrUndeclaredCommandCompletion.insertText = new vscode.SnippetString('emptyOrUndeclared()');
                emptyOrUndeclaredCommandCompletion.documentation = new vscode.MarkdownString('Überprüft ob der übergebene Parameter leer ist i.S.v. ob der Parameter nur aus einer       Variable besteht, die nicht aufgelöst wurde.');
                items.push(emptyOrUndeclaredCommandCompletion);
                const endsWithAlphaCommandCompletion = new vscode.CompletionItem('endsWithAlpha');
                endsWithAlphaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                endsWithAlphaCommandCompletion.insertText = new vscode.SnippetString('endsWithAlpha(TEXT = "$1", SUFFIX = "$2")');
                endsWithAlphaCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein text mit einem angegebenen Teil-Text endet');
                items.push(endsWithAlphaCommandCompletion);
                const equalsAlphaCommandCompletion = new vscode.CompletionItem('equalsAlpha');
                equalsAlphaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                equalsAlphaCommandCompletion.insertText = new vscode.SnippetString('equalsAlpha()');
                equalsAlphaCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob diese gleich sind. Sofern Zahlen alphanumerisch verglichen werden, werden diese trotzdem wie Zeichen verglichen. Dann gilt z.B. dass 2 größer als 1000 ist. Soll geprüft werden, ob ein Element leer ist, kann für left oder right "BLANK" geschrieben werden.');
                items.push(equalsAlphaCommandCompletion);
                const equalsAlphaIgnoreCaseCommandCompletion = new vscode.CompletionItem('equalsAlphaIgnoreCase');
                equalsAlphaIgnoreCaseCommandCompletion.kind = vscode.CompletionItemKind.Function;
                equalsAlphaIgnoreCaseCommandCompletion.insertText = new vscode.SnippetString('equalsAlphaIgnoreCase()');
                equalsAlphaIgnoreCaseCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob diese gleich sind.Groß und Kleinschreibung wird ignoriert.');
                items.push(equalsAlphaIgnoreCaseCommandCompletion);
                const equalsDateCommandCompletion = new vscode.CompletionItem('equalsDate');
                equalsDateCommandCompletion.kind = vscode.CompletionItemKind.Function;
                equalsDateCommandCompletion.insertText = new vscode.SnippetString('equalsDate()');
                equalsDateCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob diese gleich sind. Sofern keine Datumswerte übergeben werden, liefert das Kommando einen Fehlschlag zurück.');
                items.push(equalsDateCommandCompletion);
                const equalsNumCommandCompletion = new vscode.CompletionItem('equalsNum');
                equalsNumCommandCompletion.kind = vscode.CompletionItemKind.Function;
                equalsNumCommandCompletion.insertText = new vscode.SnippetString('equalsNum()');
                equalsNumCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob diese gleich sind. Sofern keine Zahlen übergeben werden, liefert das Kommando einen Fehlschlag zurück.');
                items.push(equalsNumCommandCompletion);
                const equalsRegexCommandCompletion = new vscode.CompletionItem('equalsRegex');
                equalsRegexCommandCompletion.kind = vscode.CompletionItemKind.Function;
                equalsRegexCommandCompletion.insertText = new vscode.SnippetString('equalsRegex()');
                equalsRegexCommandCompletion.documentation = new vscode.MarkdownString('Sucht im linken String nach einem regulären Ausdruck (rechts)');
                items.push(equalsRegexCommandCompletion);
                const evaluateCommandCompletion = new vscode.CompletionItem('evaluate');
                evaluateCommandCompletion.kind = vscode.CompletionItemKind.Function;
                evaluateCommandCompletion.insertText = new vscode.SnippetString('evaluate(FILEPATH_OR_SCRIPT = "$1")');
                evaluateCommandCompletion.documentation = new vscode.MarkdownString('Führt ein übergebenes Groovy Script aus und speichert das Resultat im TARGET_STORAGE_KEY.');
                items.push(evaluateCommandCompletion);
                const excelWriteCellCommandCompletion = new vscode.CompletionItem('excelWriteCell');
                excelWriteCellCommandCompletion.kind = vscode.CompletionItemKind.Function;
                excelWriteCellCommandCompletion.insertText = new vscode.SnippetString('excelWriteCell(FILENAME = "$1", SHEET_INDEX = "$2", ROW_INDEX = "$3", COLUMN_INDEX = "$4")');
                excelWriteCellCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando schreibt den übergebenen Wert an die gewünschte Stelle in der angegebenen Excel-Datei. Zu beachten ist,    dass die Spalte, anders als in Excel, über ihre Nummer (statt über ihren Buchstaben) angesprochen wird.    Die Nummer "1" entspricht dabei der Spalte "A", Die Nummer "12" der Spalte "L" und so weiter.');
                items.push(excelWriteCellCommandCompletion);
                const excelWriterFromDatabaseCommandCompletion = new vscode.CompletionItem('excelWriterFromDatabase');
                excelWriterFromDatabaseCommandCompletion.kind = vscode.CompletionItemKind.Function;
                excelWriterFromDatabaseCommandCompletion.insertText = new vscode.SnippetString('excelWriterFromDatabase(EXCEL_FILENAME = "$1", SQL_STATEMENT = "$2")');
                excelWriterFromDatabaseCommandCompletion.documentation = new vscode.MarkdownString('Liest Daten aus einer Datenbank und schreibt diese in eine Excel-Datei.');
                items.push(excelWriterFromDatabaseCommandCompletion);
                const executeApplicationWinCommandCompletion = new vscode.CompletionItem('executeApplicationWin');
                executeApplicationWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                executeApplicationWinCommandCompletion.insertText = new vscode.SnippetString('executeApplicationWin(EXECUTABLE_PATH = "$1")');
                executeApplicationWinCommandCompletion.documentation = new vscode.MarkdownString('Führt eine Anwendung aus');
                items.push(executeApplicationWinCommandCompletion);
                const executeJCLCommandCompletion = new vscode.CompletionItem('executeJCL');
                executeJCLCommandCompletion.kind = vscode.CompletionItemKind.Function;
                executeJCLCommandCompletion.insertText = new vscode.SnippetString('executeJCL(JCLFILE = "$1", USER = "$2", PW = "$3", HOST = "$4", RETURNCODE = "$5")');
                executeJCLCommandCompletion.documentation = new vscode.MarkdownString('Kommando zum Ausführen einer JCL auf einen Host.');
                items.push(executeJCLCommandCompletion);
                const executeJCLConnectedCommandCompletion = new vscode.CompletionItem('executeJCLConnected');
                executeJCLConnectedCommandCompletion.kind = vscode.CompletionItemKind.Function;
                executeJCLConnectedCommandCompletion.insertText = new vscode.SnippetString('executeJCLConnected(JCLFILE = "$1", USER = "$2", CONNECTION_NAME = "$3", HOST = "$4", RETURNCODE = "$5")');
                executeJCLConnectedCommandCompletion.documentation = new vscode.MarkdownString('Kommando zum Ausführen einer JCL auf einen Host.');
                items.push(executeJCLConnectedCommandCompletion);
                const executeJavaCommandCompletion = new vscode.CompletionItem('executeJava');
                executeJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                executeJavaCommandCompletion.insertText = new vscode.SnippetString('executeJava(TARGET = "$1", METHOD = "$2")');
                executeJavaCommandCompletion.documentation = new vscode.MarkdownString('Führt eine Methode des Java Agenten aus. ');
                items.push(executeJavaCommandCompletion);
                const executeSQLCommandCompletion = new vscode.CompletionItem('executeSQL');
                executeSQLCommandCompletion.kind = vscode.CompletionItemKind.Function;
                executeSQLCommandCompletion.insertText = new vscode.SnippetString('executeSQL(JDBC_URL = "$1", SQL_STATEMENT_OR_FILE = "$2")');
                executeSQLCommandCompletion.documentation = new vscode.MarkdownString('Führt ein oder mehrere Statement(s) auf einer Datenbank aus.    Achtung: Dieses Kommando ist veraltet und sollte nicht mehr gebraucht werden.     Stattdessen ist das Kommando executeSql im Zusammenhang mit openSql bzw. closeSql (siehe Handbuch) anzuwenden.');
                items.push(executeSQLCommandCompletion);
                const executeSqlCommandCompletion = new vscode.CompletionItem('executeSql');
                executeSqlCommandCompletion.kind = vscode.CompletionItemKind.Function;
                executeSqlCommandCompletion.insertText = new vscode.SnippetString('executeSql(CONNECTION_NAME = "$1")');
                executeSqlCommandCompletion.documentation = new vscode.MarkdownString('Führt ausführende Statements wie Update, delete und insert bei einer bestehenden Datenbankverbindung aus.');
                items.push(executeSqlCommandCompletion);
                const executeWindowsCommandCommandCompletion = new vscode.CompletionItem('executeWindowsCommand');
                executeWindowsCommandCommandCompletion.kind = vscode.CompletionItemKind.Function;
                executeWindowsCommandCommandCompletion.insertText = new vscode.SnippetString('executeWindowsCommand(COMMAND = "$1")');
                executeWindowsCommandCommandCompletion.documentation = new vscode.MarkdownString('Führt ein Kommando in der Windows-Eingabeaufforderung (cmd.exe) aus.    Ein häufiger Anwendungsfall ist das Erzwungene Schließen eines Prozesses. Dazu kann im Vorfeld in cmd.exe mit dem Befehl TASKLIST der Name des Prozesses ermittelt werden (z. B. calc.exe), der anschließend hier im Kommando verwendet wird (z. B. taskkill /IM calc.exe /F)');
                items.push(executeWindowsCommandCommandCompletion);
                const expectAttributeMobileCommandCompletion = new vscode.CompletionItem('expectAttributeMobile');
                expectAttributeMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                expectAttributeMobileCommandCompletion.insertText = new vscode.SnippetString('expectAttributeMobile(EXPRESSION_TEXT = "$1", ATTRIBUTE_NAME = "$2")');
                expectAttributeMobileCommandCompletion.documentation = new vscode.MarkdownString('Prüft, ob ein Element ein bestimmten Attribut Wert besitzt, nachdem es gefunden wurde (Beispiel: expectAttributeMobile()).');
                items.push(expectAttributeMobileCommandCompletion);
                const expectDisplayedMobileCommandCompletion = new vscode.CompletionItem('expectDisplayedMobile');
                expectDisplayedMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                expectDisplayedMobileCommandCompletion.insertText = new vscode.SnippetString('expectDisplayedMobile(EXPRESSION_TEXT = "$1")');
                expectDisplayedMobileCommandCompletion.documentation = new vscode.MarkdownString('Prüft, ob ein Element sichtbar ist, nachdem es gefunden wurde (Beispiel: expectDisplayedMobile("name", "Weiter-Knopf", "true", "500")).');
                items.push(expectDisplayedMobileCommandCompletion);
                const expectEnabledMobileCommandCompletion = new vscode.CompletionItem('expectEnabledMobile');
                expectEnabledMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                expectEnabledMobileCommandCompletion.insertText = new vscode.SnippetString('expectEnabledMobile(EXPRESSION_TEXT = "$1")');
                expectEnabledMobileCommandCompletion.documentation = new vscode.MarkdownString('Prüft, ob ein Element entsperrt ist, nachdem es gefunden wurde (Beispiel: expectEnabledMobile("name", "Weiter-Knopf", "true", "500")).');
                items.push(expectEnabledMobileCommandCompletion);
                const expectNotSelectedMobileCommandCompletion = new vscode.CompletionItem('expectNotSelectedMobile');
                expectNotSelectedMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                expectNotSelectedMobileCommandCompletion.insertText = new vscode.SnippetString('expectNotSelectedMobile(EXPRESSION_TEXT = "$1")');
                expectNotSelectedMobileCommandCompletion.documentation = new vscode.MarkdownString('Prüft, ob ein Element nicht ausgewählt ist, nachdem es gefunden wurde.');
                items.push(expectNotSelectedMobileCommandCompletion);
                const expectPresentMobileCommandCompletion = new vscode.CompletionItem('expectPresentMobile');
                expectPresentMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                expectPresentMobileCommandCompletion.insertText = new vscode.SnippetString('expectPresentMobile(EXPRESSION_TEXT = "$1")');
                expectPresentMobileCommandCompletion.documentation = new vscode.MarkdownString('Dieser Befehl überprüft - analog zu waitMobile - die Verfügbarkeit eines Elements. Er kann aber zusätzlich überprüfen, ob ein Element nicht verfügbar ist (Beispiel: expectPresentMobile()).');
                items.push(expectPresentMobileCommandCompletion);
                const expectSelectedMobileCommandCompletion = new vscode.CompletionItem('expectSelectedMobile');
                expectSelectedMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                expectSelectedMobileCommandCompletion.insertText = new vscode.SnippetString('expectSelectedMobile(EXPRESSION_TEXT = "$1")');
                expectSelectedMobileCommandCompletion.documentation = new vscode.MarkdownString('Prüft, ob ein Element ausgewählt ist, nachdem es gefunden wurde (Beispiel: expectSelectedMobile("name", "Weiter-Knopf", "500")).');
                items.push(expectSelectedMobileCommandCompletion);
                const expectTextMobileCommandCompletion = new vscode.CompletionItem('expectTextMobile');
                expectTextMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                expectTextMobileCommandCompletion.insertText = new vscode.SnippetString('expectTextMobile(EXPRESSION_TEXT = "$1")');
                expectTextMobileCommandCompletion.documentation = new vscode.MarkdownString('Sucht in einem Element nach einem Text, nachdem es gefunden wurde (Beispiel: expectTextMobile("name", "Textfeld1", "Hello World", "500")).');
                items.push(expectTextMobileCommandCompletion);
                const extractTextFromPDFCommandCompletion = new vscode.CompletionItem('extractTextFromPDF');
                extractTextFromPDFCommandCompletion.kind = vscode.CompletionItemKind.Function;
                extractTextFromPDFCommandCompletion.insertText = new vscode.SnippetString('extractTextFromPDF(PDF_PATH = "$1")');
                extractTextFromPDFCommandCompletion.documentation = new vscode.MarkdownString('Extrahiert den Text aus einer gegebenen PDF-Datei.');
                items.push(extractTextFromPDFCommandCompletion);
                const failCommandCompletion = new vscode.CompletionItem('fail');
                failCommandCompletion.kind = vscode.CompletionItemKind.Function;
                failCommandCompletion.insertText = new vscode.SnippetString('fail(MESSAGE = "$1")');
                failCommandCompletion.documentation = new vscode.MarkdownString('Erzeugt einen Fehlschlag mit allen dazugehörigen Konsequenzen unabhängig vom bisherigen Erfolg eines Testfalls oder -schrittes. Ist z.B. sinnvoll einzusetzen nach der Überprüfung von Bedingungen im sonst-Fall.');
                items.push(failCommandCompletion);
                const fileTextDiffCommandCompletion = new vscode.CompletionItem('fileTextDiff');
                fileTextDiffCommandCompletion.kind = vscode.CompletionItemKind.Function;
                fileTextDiffCommandCompletion.insertText = new vscode.SnippetString('fileTextDiff(FILE_ONE = "$1", FILE_TWO = "$2")');
                fileTextDiffCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht zwei Dateien zeilenweise miteinander und gibt die Änderungen als Warnung aus.');
                items.push(fileTextDiffCommandCompletion);
                const findAndClickAndSendWinCommandCompletion = new vscode.CompletionItem('findAndClickAndSendWin');
                findAndClickAndSendWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                findAndClickAndSendWinCommandCompletion.insertText = new vscode.SnippetString('findAndClickAndSendWin(WINDOW_NAME = "$1", IMAGE_RELATIVE_PATH = "$2", TEXT_TO_SEND = "$3")');
                findAndClickAndSendWinCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf ein Position in einem Fenster, die anhand eines Bildes gefunden wird. Geklickt wird auf die Mitte des Bildes. Danach wird der in Parameter angegebene Text an das Fenster gesendet.');
                items.push(findAndClickAndSendWinCommandCompletion);
                const findAndClickWinCommandCompletion = new vscode.CompletionItem('findAndClickWin');
                findAndClickWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                findAndClickWinCommandCompletion.insertText = new vscode.SnippetString('findAndClickWin(WINDOW_NAME = "$1", IMAGE_RELATIVE_PATH = "$2")');
                findAndClickWinCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf ein Position in einem Fenster, die anhand eines Bildes gefunden wird. Geklickt wird auf die Mitte des Bildes. Dieses Kommando wartet nicht auf das Fenster oder das Bild, die nötig sind, um auf das Bild zu klicken.');
                items.push(findAndClickWinCommandCompletion);
                const findPictureLocationCommandCompletion = new vscode.CompletionItem('findPictureLocation');
                findPictureLocationCommandCompletion.kind = vscode.CompletionItemKind.Function;
                findPictureLocationCommandCompletion.insertText = new vscode.SnippetString('findPictureLocation(IMAGE_PATH = "$1")');
                findPictureLocationCommandCompletion.documentation = new vscode.MarkdownString('Sucht die Position eines Bilds');
                items.push(findPictureLocationCommandCompletion);
                const findPictureLocationAndClickCommandCompletion = new vscode.CompletionItem('findPictureLocationAndClick');
                findPictureLocationAndClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                findPictureLocationAndClickCommandCompletion.insertText = new vscode.SnippetString('findPictureLocationAndClick(IMAGE_PATH = "$1")');
                findPictureLocationAndClickCommandCompletion.documentation = new vscode.MarkdownString('Sucht die Position eines Bilds und klickt in die Mitte des gefundenen Bilds');
                items.push(findPictureLocationAndClickCommandCompletion);
                const findPictureLocationAndClickAndSendCommandCompletion = new vscode.CompletionItem('findPictureLocationAndClickAndSend');
                findPictureLocationAndClickAndSendCommandCompletion.kind = vscode.CompletionItemKind.Function;
                findPictureLocationAndClickAndSendCommandCompletion.insertText = new vscode.SnippetString('findPictureLocationAndClickAndSend(IMAGE_PATH = "$1", TEXT_TO_SEND = "$2")');
                findPictureLocationAndClickAndSendCommandCompletion.documentation = new vscode.MarkdownString('Sucht die Position eines Bilds, klickt in die Mitte des gefundenen Bilds und sendet einen Text');
                items.push(findPictureLocationAndClickAndSendCommandCompletion);
                const findTextInPictureCommandCompletion = new vscode.CompletionItem('findTextInPicture');
                findTextInPictureCommandCompletion.kind = vscode.CompletionItemKind.Function;
                findTextInPictureCommandCompletion.insertText = new vscode.SnippetString('findTextInPicture(TEXT_TO_FIND = "$1")');
                findTextInPictureCommandCompletion.documentation = new vscode.MarkdownString('Untersucht ein Bild oder einen Ausschnitt, ob ein zu übergebender Text enthalten ist.');
                items.push(findTextInPictureCommandCompletion);
                const forCommandCompletion = new vscode.CompletionItem('for');
                forCommandCompletion.kind = vscode.CompletionItemKind.Function;
                forCommandCompletion.insertText = new vscode.SnippetString('for(DATA_FILE_PATH = "$1"):');
                forCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(forCommandCompletion);
                const formatJsonCommandCompletion = new vscode.CompletionItem('formatJson');
                formatJsonCommandCompletion.kind = vscode.CompletionItemKind.Function;
                formatJsonCommandCompletion.insertText = new vscode.SnippetString('formatJson(JSONTEXT = "$1", TARGET_STORAGE_KEY = "$2")');
                formatJsonCommandCompletion.documentation = new vscode.MarkdownString('Formatiert eine JSON Datei um');
                items.push(formatJsonCommandCompletion);
                const ftpConnectCommandCompletion = new vscode.CompletionItem('ftpConnect');
                ftpConnectCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpConnectCommandCompletion.insertText = new vscode.SnippetString('ftpConnect(CONNECTION_NAME = "$1", SERVER = "$2")');
                ftpConnectCommandCompletion.documentation = new vscode.MarkdownString('Öffnet eine FTPVerbindung inklusive Login');
                items.push(ftpConnectCommandCompletion);
                const ftpDeleteCommandCompletion = new vscode.CompletionItem('ftpDelete');
                ftpDeleteCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpDeleteCommandCompletion.insertText = new vscode.SnippetString('ftpDelete(SERVER = "$1", USER = "$2", PW = "$3", SERVER_PATH = "$4")');
                ftpDeleteCommandCompletion.documentation = new vscode.MarkdownString('Abbau einer bestehenden FTP-Verbindung');
                items.push(ftpDeleteCommandCompletion);
                const ftpDeleteConnectedCommandCompletion = new vscode.CompletionItem('ftpDeleteConnected');
                ftpDeleteConnectedCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpDeleteConnectedCommandCompletion.insertText = new vscode.SnippetString('ftpDeleteConnected(CONNECTION_NAME = "$1", SERVER_PATH = "$2")');
                ftpDeleteConnectedCommandCompletion.documentation = new vscode.MarkdownString('Abbau einer bestehenden FTP-Verbindung');
                items.push(ftpDeleteConnectedCommandCompletion);
                const ftpDisconnectCommandCompletion = new vscode.CompletionItem('ftpDisconnect');
                ftpDisconnectCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpDisconnectCommandCompletion.insertText = new vscode.SnippetString('ftpDisconnect(CONNECTION_NAME = "$1")');
                ftpDisconnectCommandCompletion.documentation = new vscode.MarkdownString('Abbau einer bestehenden FTP-Verbindung');
                items.push(ftpDisconnectCommandCompletion);
                const ftpGetCommandCompletion = new vscode.CompletionItem('ftpGet');
                ftpGetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpGetCommandCompletion.insertText = new vscode.SnippetString('ftpGet(SERVER = "$1", USER = "$2", PW = "$3", SERVER_PATH = "$4", LOCAL_PATH = "$5")');
                ftpGetCommandCompletion.documentation = new vscode.MarkdownString('Realisiert ein FTP GET unter Angabe der Credentials, der Serveradresse sowie der lokalen Adresse');
                items.push(ftpGetCommandCompletion);
                const ftpGetConnectedCommandCompletion = new vscode.CompletionItem('ftpGetConnected');
                ftpGetConnectedCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpGetConnectedCommandCompletion.insertText = new vscode.SnippetString('ftpGetConnected(CONNECTION_NAME = "$1", SERVER_PATH = "$2", LOCAL_PATH = "$3")');
                ftpGetConnectedCommandCompletion.documentation = new vscode.MarkdownString('Führt den Get-Befehl bei einer bestehenden FTP Verbindung durch');
                items.push(ftpGetConnectedCommandCompletion);
                const ftpPutCommandCompletion = new vscode.CompletionItem('ftpPut');
                ftpPutCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpPutCommandCompletion.insertText = new vscode.SnippetString('ftpPut(SERVER = "$1", USER = "$2", PW = "$3", SERVER_PATH = "$4", LOCAL_PATH = "$5")');
                ftpPutCommandCompletion.documentation = new vscode.MarkdownString('Realisiert ein FTP Put unter Angabe der Credentials, der Serveradresse sowie der lokalen Adresse');
                items.push(ftpPutCommandCompletion);
                const ftpPutConnectedCommandCompletion = new vscode.CompletionItem('ftpPutConnected');
                ftpPutConnectedCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpPutConnectedCommandCompletion.insertText = new vscode.SnippetString('ftpPutConnected(CONNECTION_NAME = "$1", LOCAL_PATH = "$2", SERVER_PATH = "$3")');
                ftpPutConnectedCommandCompletion.documentation = new vscode.MarkdownString('Führt den Put-Befehl bei einer bestehenden FTP Verbindung durch');
                items.push(ftpPutConnectedCommandCompletion);
                const ftpSiteConnectedCommandCompletion = new vscode.CompletionItem('ftpSiteConnected');
                ftpSiteConnectedCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ftpSiteConnectedCommandCompletion.insertText = new vscode.SnippetString('ftpSiteConnected(CONNECTION_NAME = "$1", COMMAND = "$2")');
                ftpSiteConnectedCommandCompletion.documentation = new vscode.MarkdownString('Ausführung von SITE Kommandos ');
                items.push(ftpSiteConnectedCommandCompletion);
                const generateRandomWordsCommandCompletion = new vscode.CompletionItem('generateRandomWords');
                generateRandomWordsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                generateRandomWordsCommandCompletion.insertText = new vscode.SnippetString('generateRandomWords(ROWNUM = "$1", FILENAME = "$2")');
                generateRandomWordsCommandCompletion.documentation = new vscode.MarkdownString('Generiert eine .xlsx-Datei, die eine festgelegte Anzahl auf festgelegte regüläre Ausdrücke zutreffender Wörter enthält. Dieses Kommando dient somit als Vorbereitung für for (siehe oben), um bspw. Formulare auf eine große Zahl von Zufallseingaben zu testen. Da die für for notwendige .xlsx-Datei jedoch vor Ausführung des Testfalls bereits vorhanden sein muss, kann dieses Kommando nicht im gleichen Testlauf ausgeführt werden wie der Testlauf, der die verwendende for-Schleife enthält. Stattdessen ist RandomWordGenerator in einem vorhergehenden Testfall auszuführen.    Jeder hinter ROWNUM und FILENAME aufgeführte weitere Parameter (Anzahl beliebig) beschreibt jeweils einen regulären Ausdruck, auf den alle generierten Einträge in der korrespondierenden Spalte der Zieldatei zutreffen müssen. Die regulären Ausdrücke entsprechen dabei der Java-Syntax. (Erhält z. B. Parameter 3 den Wert [0-9]([a-c]|[e-g]{1,9}), so treffen alle Einträge in der ersten Spalte der Zieldatei auf diesen regulären Ausdruck zu usw. für jeden folgenden Parameter und jede folgende Spalte).');
                items.push(generateRandomWordsCommandCompletion);
                const getAllFilesOfPathCommandCompletion = new vscode.CompletionItem('getAllFilesOfPath');
                getAllFilesOfPathCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getAllFilesOfPathCommandCompletion.insertText = new vscode.SnippetString('getAllFilesOfPath(PATH = "$1", CSV_FILE = "$2")');
                getAllFilesOfPathCommandCompletion.documentation = new vscode.MarkdownString('Liest die Pfade aller Dateien in einem Ordner aus und schreibt diese in einen Storage-Key und/oder eine CSV-Datei.');
                items.push(getAllFilesOfPathCommandCompletion);
                const getAttributeFromElementWebCommandCompletion = new vscode.CompletionItem('getAttributeFromElementWeb');
                getAttributeFromElementWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getAttributeFromElementWebCommandCompletion.insertText = new vscode.SnippetString('getAttributeFromElementWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2", ATTRIBUTE_NAME = "$3")');
                getAttributeFromElementWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando ruft den Wert eines gegebenen Attributs in einem gegebenem Element ab und speichert diesen ggf. unter TARGET_STORAGE_KEY');
                items.push(getAttributeFromElementWebCommandCompletion);
                const getBrowserLogCommandCompletion = new vscode.CompletionItem('getBrowserLog');
                getBrowserLogCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getBrowserLogCommandCompletion.insertText = new vscode.SnippetString('getBrowserLog()');
                getBrowserLogCommandCompletion.documentation = new vscode.MarkdownString('Abruf des Browser-Log. Derzeit nur für Chrome verfügbar. Hierbei müssen Log-Levels festgelegt werden. Zum Einen muss unabhängig vom einzelnen Kommandoaufruf eingestellt werden, was der Browser (bzw. der WebDriver) überhaupt loggt. Dies wird eingestellt in der Konfigurationsdatei "environment.properties" über den Parameter "webDriverLogLevel". Default ist INFO. Mögliche Werte sind: OFF, SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST, ALL. Dabei ist stets die Angabe nur eines dieser Werte erlaubt (keine Liste). Kritischere Log-Levels werden jeweils mit eingeschlossen (z. B. schließt INFO auch SEVERE mit ein). Für die vollständige Hierarchie der Log-Levels, siehe java.util.logging.Level. ACHTUNG: Jeder Aufruf des Kommandos leert den Zwischenspeicher mit den bis zum Aufruf angefallenen Log-Einträgen. Bei zwei hintereinander erfolgenden Aufrufen dieses Kommandos wird der zweite Aufruf nur die Log-Einträge ausgeben, die seit dem vorherigen Aufruf des Kommandos angefallen sind.');
                items.push(getBrowserLogCommandCompletion);
                const getColourFromFocussedWinEleCommandCompletion = new vscode.CompletionItem('getColourFromFocussedWinEle');
                getColourFromFocussedWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getColourFromFocussedWinEleCommandCompletion.insertText = new vscode.SnippetString('getColourFromFocussedWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2")');
                getColourFromFocussedWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando speichert/vergleicht die Farbe eines Elementes im RGB-Format (R-G-B).');
                items.push(getColourFromFocussedWinEleCommandCompletion);
                const getCookiesWebCommandCompletion = new vscode.CompletionItem('getCookiesWeb');
                getCookiesWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getCookiesWebCommandCompletion.insertText = new vscode.SnippetString('getCookiesWeb()');
                getCookiesWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando ruft alle Cookies/das angegebene Cookie auf der aktuellen/angegebenen Seite ab     und speichert diese in der Storage-Variable.');
                items.push(getCookiesWebCommandCompletion);
                const getCurrentTitleWebCommandCompletion = new vscode.CompletionItem('getCurrentTitleWeb');
                getCurrentTitleWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getCurrentTitleWebCommandCompletion.insertText = new vscode.SnippetString('getCurrentTitleWeb()');
                getCurrentTitleWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando gibt den Titel der aktuellen Webseite zurück. Es speichert ihn ggf. unter TARGET_STORAGE_KEY');
                items.push(getCurrentTitleWebCommandCompletion);
                const getCurrentURLMobileCommandCompletion = new vscode.CompletionItem('getCurrentURLMobile');
                getCurrentURLMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getCurrentURLMobileCommandCompletion.insertText = new vscode.SnippetString('getCurrentURLMobile()');
                getCurrentURLMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando ermöglicht den Zugriff auf die URL der gerade im Browser angezeigten Webseite. Die aktuell angezeigte URL kann somit in einer Variable gespeichert werden.');
                items.push(getCurrentURLMobileCommandCompletion);
                const getCurrentURLWebCommandCompletion = new vscode.CompletionItem('getCurrentURLWeb');
                getCurrentURLWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getCurrentURLWebCommandCompletion.insertText = new vscode.SnippetString('getCurrentURLWeb()');
                getCurrentURLWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando gibt die aktuelle URL zurück und speichert diese ggf. unter TARGET_STORAGE_KEY');
                items.push(getCurrentURLWebCommandCompletion);
                const getItemByTextJavaCommandCompletion = new vscode.CompletionItem('getItemByTextJava');
                getItemByTextJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getItemByTextJavaCommandCompletion.insertText = new vscode.SnippetString('getItemByTextJava(TARGET = "$1", TEXT = "$2", INDEX = "$3")');
                getItemByTextJavaCommandCompletion.documentation = new vscode.MarkdownString('Klickt ein angegebenes Element innerhalb einer Tabelle einer Java Anwendung an.');
                items.push(getItemByTextJavaCommandCompletion);
                const getSelectedElementDropDownWinEleCommandCompletion = new vscode.CompletionItem('getSelectedElementDropDownWinEle');
                getSelectedElementDropDownWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getSelectedElementDropDownWinEleCommandCompletion.insertText = new vscode.SnippetString('getSelectedElementDropDownWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2")');
                getSelectedElementDropDownWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando speichert oder prüft das aktuell selektierte Element aus einem Drop-Down-Menü.');
                items.push(getSelectedElementDropDownWinEleCommandCompletion);
                const getTextFromElementWebCommandCompletion = new vscode.CompletionItem('getTextFromElementWeb');
                getTextFromElementWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getTextFromElementWebCommandCompletion.insertText = new vscode.SnippetString('getTextFromElementWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2")');
                getTextFromElementWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando prüft, ob in gegebenem Element ein Text auf der Webseite vorhanden ist und speichert diesen ggf. unter TARGET_STORAGE_KEY');
                items.push(getTextFromElementWebCommandCompletion);
                const getTextFromFocussedWinEleCommandCompletion = new vscode.CompletionItem('getTextFromFocussedWinEle');
                getTextFromFocussedWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getTextFromFocussedWinEleCommandCompletion.insertText = new vscode.SnippetString('getTextFromFocussedWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2")');
                getTextFromFocussedWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando speichert den Wert des fokusssierten Textfeldes in einer Laufzeitvariablen oder vergleicht es mit einem angegebenen String. Das Kommando funktioniert explizit nicht mit Zellen in einer Excel-Datei.');
                items.push(getTextFromFocussedWinEleCommandCompletion);
                const getTextJavaCommandCompletion = new vscode.CompletionItem('getTextJava');
                getTextJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getTextJavaCommandCompletion.insertText = new vscode.SnippetString('getTextJava(TARGET = "$1")');
                getTextJavaCommandCompletion.documentation = new vscode.MarkdownString('Ruft die Methode getText einer Java Swing Komponente auf.');
                items.push(getTextJavaCommandCompletion);
                const getTextMobileCommandCompletion = new vscode.CompletionItem('getTextMobile');
                getTextMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getTextMobileCommandCompletion.insertText = new vscode.SnippetString('getTextMobile(EXPRESSION_TEXT = "$1")');
                getTextMobileCommandCompletion.documentation = new vscode.MarkdownString('Dieses Kommando ermöglicht den Zugriff auf den Text eines Elements (in der Regel ein Textfeld), nachdem es gefunden wurde (Beispiel: getTextMobile("name", "Textfeld1", "Hello World", "Variable1")). ');
                items.push(getTextMobileCommandCompletion);
                const getTextWindowCommandCompletion = new vscode.CompletionItem('getTextWindow');
                getTextWindowCommandCompletion.kind = vscode.CompletionItemKind.Function;
                getTextWindowCommandCompletion.insertText = new vscode.SnippetString('getTextWindow(WINDOW_NAME = "$1", TARGET_STORAGE_KEY = "$2")');
                getTextWindowCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando holt den Text eines Fensters und schreibt ihn in den Speicher.');
                items.push(getTextWindowCommandCompletion);
                const greaterThanAlphaCommandCompletion = new vscode.CompletionItem('greaterThanAlpha');
                greaterThanAlphaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                greaterThanAlphaCommandCompletion.insertText = new vscode.SnippetString('greaterThanAlpha()');
                greaterThanAlphaCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob der linke größer als der rechte Parameter ist. Sofern Zahlen alphanumerisch verglichen werden, werden diese trotzdem wie Zeichen verglichen. Dann gilt z.B. dass 2 größer als 1000 ist.');
                items.push(greaterThanAlphaCommandCompletion);
                const greaterThanDateCommandCompletion = new vscode.CompletionItem('greaterThanDate');
                greaterThanDateCommandCompletion.kind = vscode.CompletionItemKind.Function;
                greaterThanDateCommandCompletion.insertText = new vscode.SnippetString('greaterThanDate()');
                greaterThanDateCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob der linke größer als der rechte Parameter ist. Sofern keine Datumswerte übergeben werden, liefert das Kommando einen Fehlschlag zurück.');
                items.push(greaterThanDateCommandCompletion);
                const greaterThanNumCommandCompletion = new vscode.CompletionItem('greaterThanNum');
                greaterThanNumCommandCompletion.kind = vscode.CompletionItemKind.Function;
                greaterThanNumCommandCompletion.insertText = new vscode.SnippetString('greaterThanNum()');
                greaterThanNumCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob der linke größer als der rechte Parameter ist. Sofern keine Zahlen übergeben werden, liefert das Kommando einen Fehlschlag zurück.');
                items.push(greaterThanNumCommandCompletion);
                const helpCommandCompletion = new vscode.CompletionItem('help');
                helpCommandCompletion.kind = vscode.CompletionItemKind.Function;
                helpCommandCompletion.insertText = new vscode.SnippetString('help(MESSAGE = "$1", FILENAME = "$2")');
                helpCommandCompletion.documentation = new vscode.MarkdownString('Erzeugt oder überschreibt eine Datei und schreibt eine Nachricht in diese Datei.');
                items.push(helpCommandCompletion);
                const hideCommandOverlayCommandCompletion = new vscode.CompletionItem('hideCommandOverlay');
                hideCommandOverlayCommandCompletion.kind = vscode.CompletionItemKind.Function;
                hideCommandOverlayCommandCompletion.insertText = new vscode.SnippetString('hideCommandOverlay()');
                hideCommandOverlayCommandCompletion.documentation = new vscode.MarkdownString('Versteckt das Command-Overlay. ');
                items.push(hideCommandOverlayCommandCompletion);
                const hideKeyboardCommandCompletion = new vscode.CompletionItem('hideKeyboard');
                hideKeyboardCommandCompletion.kind = vscode.CompletionItemKind.Function;
                hideKeyboardCommandCompletion.insertText = new vscode.SnippetString('hideKeyboard()');
                hideKeyboardCommandCompletion.documentation = new vscode.MarkdownString('Blendet die Bildschirmtastatur aus');
                items.push(hideKeyboardCommandCompletion);
                const hoverAndClickWebCommandCompletion = new vscode.CompletionItem('hoverAndClickWeb');
                hoverAndClickWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                hoverAndClickWebCommandCompletion.insertText = new vscode.SnippetString('hoverAndClickWeb(ELEMENT_NAME_HOVER = "$1", ELEMENT_NAME_CLICK = "$2")');
                hoverAndClickWebCommandCompletion.documentation = new vscode.MarkdownString('Bewegt die Maus an einen bestimmten Punkt (Hover) und klickt danach einen anderen bestimmten Punkt (Click).              Dies ist insbesondere bei Menüs, die sich durch ein Hover aufklappen, hilfreich.               Nachdem das Kommando das Fenster zu dem Hover-Punkt bewegt hat, kann es sein, dass die dabei erscheinenden Menüpunkte nicht im Sichtfeld sind.                Eventuell ist dazu ein zusätzliches Verschieben des Sichtbereichs im Fenster notwendig.               Die Koordinaten einer solchen Verschiebung lassen sich über die optionalen Paramter SCROLL_X bzw. SCROLL_Y festlegen.');
                items.push(hoverAndClickWebCommandCompletion);
                const httpDeleteCommandCompletion = new vscode.CompletionItem('httpDelete');
                httpDeleteCommandCompletion.kind = vscode.CompletionItemKind.Function;
                httpDeleteCommandCompletion.insertText = new vscode.SnippetString('httpDelete(URL = "$1", BODY = "$2", CONTENT_TYPE = "$3")');
                httpDeleteCommandCompletion.documentation = new vscode.MarkdownString('Ruft ein HTTP-DELETE auf und speichert das Ergebnis im Storage.');
                items.push(httpDeleteCommandCompletion);
                const httpGetCommandCompletion = new vscode.CompletionItem('httpGet');
                httpGetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                httpGetCommandCompletion.insertText = new vscode.SnippetString('httpGet(URL = "$1")');
                httpGetCommandCompletion.documentation = new vscode.MarkdownString('Ruft ein HTTP-GET auf und speichert das Ergebnis im Storage.');
                items.push(httpGetCommandCompletion);
                const httpPatchCommandCompletion = new vscode.CompletionItem('httpPatch');
                httpPatchCommandCompletion.kind = vscode.CompletionItemKind.Function;
                httpPatchCommandCompletion.insertText = new vscode.SnippetString('httpPatch(URL = "$1", BODY = "$2", CONTENT_TYPE = "$3")');
                httpPatchCommandCompletion.documentation = new vscode.MarkdownString('Ruft ein HTTP-PATCH auf und speichert das Ergebnis im Storage.');
                items.push(httpPatchCommandCompletion);
                const httpPostCommandCompletion = new vscode.CompletionItem('httpPost');
                httpPostCommandCompletion.kind = vscode.CompletionItemKind.Function;
                httpPostCommandCompletion.insertText = new vscode.SnippetString('httpPost(URL = "$1", BODY = "$2", CONTENT_TYPE = "$3")');
                httpPostCommandCompletion.documentation = new vscode.MarkdownString('Ruft ein HTTP-POST auf und speichert das Ergebnis im Storage.');
                items.push(httpPostCommandCompletion);
                const httpPutCommandCompletion = new vscode.CompletionItem('httpPut');
                httpPutCommandCompletion.kind = vscode.CompletionItemKind.Function;
                httpPutCommandCompletion.insertText = new vscode.SnippetString('httpPut(URL = "$1", BODY = "$2", CONTENT_TYPE = "$3")');
                httpPutCommandCompletion.documentation = new vscode.MarkdownString('Ruft ein HTTP-PUT auf und speichert das Ergebnis im Storage.');
                items.push(httpPutCommandCompletion);
                const ifCommandCompletion = new vscode.CompletionItem('if');
                ifCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ifCommandCompletion.insertText = new vscode.SnippetString('if():');
                ifCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(ifCommandCompletion);
                const ifNotCommandCompletion = new vscode.CompletionItem('ifNot');
                ifNotCommandCompletion.kind = vscode.CompletionItemKind.Function;
                ifNotCommandCompletion.insertText = new vscode.SnippetString('ifNot():');
                ifNotCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(ifNotCommandCompletion);
                const inputDialogCommandCompletion = new vscode.CompletionItem('inputDialog');
                inputDialogCommandCompletion.kind = vscode.CompletionItemKind.Function;
                inputDialogCommandCompletion.insertText = new vscode.SnippetString('inputDialog(MESSAGE = "$1", TARGET_STORAGE_KEY = "$2")');
                inputDialogCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando erzeugt ein Dialog zum manuellen Erfassen von Storage Parametern');
                items.push(inputDialogCommandCompletion);
                const lessThanAlphaCommandCompletion = new vscode.CompletionItem('lessThanAlpha');
                lessThanAlphaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                lessThanAlphaCommandCompletion.insertText = new vscode.SnippetString('lessThanAlpha()');
                lessThanAlphaCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob der linke kleiner als der rechte Parameter ist. Sofern Zahlen alphanumerisch verglichen werden, werden diese trotzdem wie Zeichen verglichen. Dann gilt z.B. dass 1000 kleiner als 2 ist.');
                items.push(lessThanAlphaCommandCompletion);
                const lessThanDateCommandCompletion = new vscode.CompletionItem('lessThanDate');
                lessThanDateCommandCompletion.kind = vscode.CompletionItemKind.Function;
                lessThanDateCommandCompletion.insertText = new vscode.SnippetString('lessThanDate()');
                lessThanDateCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob der linke kleiner als der rechte Parameter ist. Sofern keine Datumswerte übergeben werden, liefert das Kommando einen Fehlschlag zurück.');
                items.push(lessThanDateCommandCompletion);
                const lessThanNumCommandCompletion = new vscode.CompletionItem('lessThanNum');
                lessThanNumCommandCompletion.kind = vscode.CompletionItemKind.Function;
                lessThanNumCommandCompletion.insertText = new vscode.SnippetString('lessThanNum()');
                lessThanNumCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob der linke kleiner als der rechte Parameter ist. Sofern keine Zahlen übergeben werden, liefert das Kommando einen Fehlschlag zurück.');
                items.push(lessThanNumCommandCompletion);
                const loadCsvSqlCommandCompletion = new vscode.CompletionItem('loadCsvSql');
                loadCsvSqlCommandCompletion.kind = vscode.CompletionItemKind.Function;
                loadCsvSqlCommandCompletion.insertText = new vscode.SnippetString('loadCsvSql(CONNECTION_NAME = "$1", TARGET_TABLE = "$2", CSV_FILE = "$3")');
                loadCsvSqlCommandCompletion.documentation = new vscode.MarkdownString('Lädt eine CSV Datei in eine SQL Datenbank. Spaltenüberschriften, die Sonderzeichen enthalten oder mit einer Zahl beginnen, werden im SQL-Statement zur Erzeugung von Tabellen mit Anführungszeichen escaped');
                items.push(loadCsvSqlCommandCompletion);
                const logAppendCaseCommandCompletion = new vscode.CompletionItem('logAppendCase');
                logAppendCaseCommandCompletion.kind = vscode.CompletionItemKind.Function;
                logAppendCaseCommandCompletion.insertText = new vscode.SnippetString('logAppendCase(MESSAGE = "$1")');
                logAppendCaseCommandCompletion.documentation = new vscode.MarkdownString('Ermöglicht dem Nutzer eine zusätztliche Nachricht über den Ablauf des Falls im Bericht anzeigen zu lassen ');
                items.push(logAppendCaseCommandCompletion);
                const logAppendSetCommandCompletion = new vscode.CompletionItem('logAppendSet');
                logAppendSetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                logAppendSetCommandCompletion.insertText = new vscode.SnippetString('logAppendSet(MESSAGE = "$1")');
                logAppendSetCommandCompletion.documentation = new vscode.MarkdownString('Ermöglicht dem Nutzer eine zusätzliche Nachricht über den Ablauf des Sets im Bericht anzeigen zu lassen ');
                items.push(logAppendSetCommandCompletion);
                const logAppendStepCommandCompletion = new vscode.CompletionItem('logAppendStep');
                logAppendStepCommandCompletion.kind = vscode.CompletionItemKind.Function;
                logAppendStepCommandCompletion.insertText = new vscode.SnippetString('logAppendStep(MESSAGE = "$1")');
                logAppendStepCommandCompletion.documentation = new vscode.MarkdownString('Ermöglicht dem Nutzer eine zusätztliche Nachricht über den Ablauf des Schrittes im Bericht anzeigen zu lassen ');
                items.push(logAppendStepCommandCompletion);
                const maximizeWindowWinEleCommandCompletion = new vscode.CompletionItem('maximizeWindowWinEle');
                maximizeWindowWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                maximizeWindowWinEleCommandCompletion.insertText = new vscode.SnippetString('maximizeWindowWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2")');
                maximizeWindowWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando maximiert die Größe eines Fensters.');
                items.push(maximizeWindowWinEleCommandCompletion);
                const monkeyClickCommandCompletion = new vscode.CompletionItem('monkeyClick');
                monkeyClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                monkeyClickCommandCompletion.insertText = new vscode.SnippetString('monkeyClick(ITERATIONS = "$1")');
                monkeyClickCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt wahllos auf der Oberfläche herum.');
                items.push(monkeyClickCommandCompletion);
                const mouseMoveToImageInWindowWinCommandCompletion = new vscode.CompletionItem('mouseMoveToImageInWindowWin');
                mouseMoveToImageInWindowWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                mouseMoveToImageInWindowWinCommandCompletion.insertText = new vscode.SnippetString('mouseMoveToImageInWindowWin(WINDOW_NAME = "$1", IMAGE_RELATIVE_PATH = "$2")');
                mouseMoveToImageInWindowWinCommandCompletion.documentation = new vscode.MarkdownString('Bewegt die Maus zu einer Position in einem Fenster, die anhand eines Bildes gefunden wird. Es wird zur Mitte des Bildes bewegt, mittels zusätzlicher Parameter kann die Position angepasst werden.');
                items.push(mouseMoveToImageInWindowWinCommandCompletion);
                const moveFileCommandCompletion = new vscode.CompletionItem('moveFile');
                moveFileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                moveFileCommandCompletion.insertText = new vscode.SnippetString('moveFile(FILENAME_FROM = "$1", FILENAME_TO = "$2")');
                moveFileCommandCompletion.documentation = new vscode.MarkdownString('Kommando verschiebt eine Datei. Durch Angabe eines anderen Dateinames in FILENAME_TO kann die Datei auch umbenannt werden.');
                items.push(moveFileCommandCompletion);
                const moveFilesOlderThanCommandCompletion = new vscode.CompletionItem('moveFilesOlderThan');
                moveFilesOlderThanCommandCompletion.kind = vscode.CompletionItemKind.Function;
                moveFilesOlderThanCommandCompletion.insertText = new vscode.SnippetString('moveFilesOlderThan(FILENAME_FROM = "$1", FILENAME_TO = "$2")');
                moveFilesOlderThanCommandCompletion.documentation = new vscode.MarkdownString('Kommando verschiebt eine Datei. Durch Angabe eines anderen Dateinames in FILENAME_TO kann die Datei auch umbenannt werden.');
                items.push(moveFilesOlderThanCommandCompletion);
                const moveMouseWinCommandCompletion = new vscode.CompletionItem('moveMouseWin');
                moveMouseWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                moveMouseWinCommandCompletion.insertText = new vscode.SnippetString('moveMouseWin(WINDOW = "$1", MOVE_TO_X = "$2", MOVE_TO_Y = "$3")');
                moveMouseWinCommandCompletion.documentation = new vscode.MarkdownString('Bewegt die Maus zu einer Zielposition');
                items.push(moveMouseWinCommandCompletion);
                const moveToWebCommandCompletion = new vscode.CompletionItem('moveToWeb');
                moveToWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                moveToWebCommandCompletion.insertText = new vscode.SnippetString('moveToWeb(ELEMENT_NAME = "$1")');
                moveToWebCommandCompletion.documentation = new vscode.MarkdownString('Im Browser wird zu der Stelle gescrollt, an der das Element für den Benutzer zu sehen ist.');
                items.push(moveToWebCommandCompletion);
                const navigateMobileCommandCompletion = new vscode.CompletionItem('navigateMobile');
                navigateMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                navigateMobileCommandCompletion.insertText = new vscode.SnippetString('navigateMobile()');
                navigateMobileCommandCompletion.documentation = new vscode.MarkdownString('Der Befehl navigiert zu der angegebenen Webseite im Browser. Außerdem kann mit dem Befehl eine Seite vor ("FORWARD") oder eine Seite zurück ("BACK") navigiert werden. Bei der "BACK"-Funktionalität wird der "Back"-Button des Handys benutzt (Beispiel: navigateMobile("", "https://www.viadee.de/", "")). ');
                items.push(navigateMobileCommandCompletion);
                const navigateWebCommandCompletion = new vscode.CompletionItem('navigateWeb');
                navigateWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                navigateWebCommandCompletion.insertText = new vscode.SnippetString('navigateWeb(URL = "$1")');
                navigateWebCommandCompletion.documentation = new vscode.MarkdownString('Öffnet eine angegebene Seite.');
                items.push(navigateWebCommandCompletion);
                const networkAndroidCommandCompletion = new vscode.CompletionItem('networkAndroid');
                networkAndroidCommandCompletion.kind = vscode.CompletionItemKind.Function;
                networkAndroidCommandCompletion.insertText = new vscode.SnippetString('networkAndroid(WIFI = "$1", DATA = "$2", AIRPLANE = "$3")');
                networkAndroidCommandCompletion.documentation = new vscode.MarkdownString('Dieses Kommando stellt bestimmte Netzwerkeinstellungen im Android Device bzw. im Android Emulator ein. Mit dem Kommando ist ein Zugriff auf das WLAN, die Mobile Datennutzung und den Flugzeugmodus möglich. Wird der Flugmodus aktiviert, werden Parameter für Wifi und Data ignoriert, da diese Einstellungen nicht gleichzeitig in einer Android Umgebung aktiv sein können (Beispiel: NetworkAndroid("on", "off", "off")).');
                items.push(networkAndroidCommandCompletion);
                const notCommandCompletion = new vscode.CompletionItem('not');
                notCommandCompletion.kind = vscode.CompletionItemKind.Function;
                notCommandCompletion.insertText = new vscode.SnippetString('not()');
                notCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(notCommandCompletion);
                const notEmptyCommandCompletion = new vscode.CompletionItem('notEmpty');
                notEmptyCommandCompletion.kind = vscode.CompletionItemKind.Function;
                notEmptyCommandCompletion.insertText = new vscode.SnippetString('notEmpty()');
                notEmptyCommandCompletion.documentation = new vscode.MarkdownString('Überprüft ob der übergebene Parameter nicht leer ist i.S.v. ob seine Länge größer 0 ist.');
                items.push(notEmptyCommandCompletion);
                const notEqualsAlphaCommandCompletion = new vscode.CompletionItem('notEqualsAlpha');
                notEqualsAlphaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                notEqualsAlphaCommandCompletion.insertText = new vscode.SnippetString('notEqualsAlpha()');
                notEqualsAlphaCommandCompletion.documentation = new vscode.MarkdownString('Vergleicht die beiden übergebenen Parameter miteinander und ermittelt, ob diese nicht gleich sind. Sofern Zahlen alphanumerisch verglichen werden, werden diese trotzdem wie Zeichen verglichen. Dann gilt z.B. dass 2 größer als 1000 ist.');
                items.push(notEqualsAlphaCommandCompletion);
                const openNotificationAndroidCommandCompletion = new vscode.CompletionItem('openNotificationAndroid');
                openNotificationAndroidCommandCompletion.kind = vscode.CompletionItemKind.Function;
                openNotificationAndroidCommandCompletion.insertText = new vscode.SnippetString('openNotificationAndroid()');
                openNotificationAndroidCommandCompletion.documentation = new vscode.MarkdownString('Öffnet die Notificationbar in Android. Anschließend kann die Notificationbar wie andere Oberflächen untersucht werden. Zum Beispiel kann geprüft werden, ob ein bestimmter Text vorhanden ist. Es können aber auch Taps und Swipes ausgeführt werden. Soll eine Notificationbar geschlossen werden, führen Sie den Back Button Befehl anschließend aus.');
                items.push(openNotificationAndroidCommandCompletion);
                const openSqlCommandCompletion = new vscode.CompletionItem('openSql');
                openSqlCommandCompletion.kind = vscode.CompletionItemKind.Function;
                openSqlCommandCompletion.insertText = new vscode.SnippetString('openSql(CONNECTION_NAME = "$1", JDBC_URL = "$2", JDBC_DRIVER = "$3")');
                openSqlCommandCompletion.documentation = new vscode.MarkdownString('Eröffnet eine Datenbankverbindung');
                items.push(openSqlCommandCompletion);
                const pasteTextCPCommandCompletion = new vscode.CompletionItem('pasteTextCP');
                pasteTextCPCommandCompletion.kind = vscode.CompletionItemKind.Function;
                pasteTextCPCommandCompletion.insertText = new vscode.SnippetString('pasteTextCP()');
                pasteTextCPCommandCompletion.documentation = new vscode.MarkdownString('Fügt Text aus der Zwischenablage an der markierten Stelle ein.');
                items.push(pasteTextCPCommandCompletion);
                const pickNumericalFromPickerRollCommandCompletion = new vscode.CompletionItem('pickNumericalFromPickerRoll');
                pickNumericalFromPickerRollCommandCompletion.kind = vscode.CompletionItemKind.Function;
                pickNumericalFromPickerRollCommandCompletion.insertText = new vscode.SnippetString('pickNumericalFromPickerRoll(ELEMENT_NAME = "$1", TARGET_VALUE = "$2")');
                pickNumericalFromPickerRollCommandCompletion.documentation = new vscode.MarkdownString('Wählt einen numerischen Wert von einer Picker-Roll aus.');
                items.push(pickNumericalFromPickerRollCommandCompletion);
                const pinchMobileCommandCompletion = new vscode.CompletionItem('pinchMobile');
                pinchMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                pinchMobileCommandCompletion.insertText = new vscode.SnippetString('pinchMobile(X_POSITION = "$1", Y_POSITION = "$2")');
                pinchMobileCommandCompletion.documentation = new vscode.MarkdownString('Führt eine Pinch-Geste (Gegenteil einer Zoom-Geste) am definierten Punkt durch (Beispiel: pinchMobile("", "150", "150")). Warnung: Es sollte immer vermieden werden, Befehle auf dem Screen auszuführen, da Pixel angaben Device- und Auflösungsabhängig sind.');
                items.push(pinchMobileCommandCompletion);
                const queryJsonCommandCompletion = new vscode.CompletionItem('queryJson');
                queryJsonCommandCompletion.kind = vscode.CompletionItemKind.Function;
                queryJsonCommandCompletion.insertText = new vscode.SnippetString('queryJson(JSONTEXT = "$1", QUERY = "$2")');
                queryJsonCommandCompletion.documentation = new vscode.MarkdownString('Führt eine Suche auf einen JSON-Text durch und schreibt das Ergebnis ggf. in eine csv Datei');
                items.push(queryJsonCommandCompletion);
                const querySqlCommandCompletion = new vscode.CompletionItem('querySql');
                querySqlCommandCompletion.kind = vscode.CompletionItemKind.Function;
                querySqlCommandCompletion.insertText = new vscode.SnippetString('querySql(CONNECTION_NAME = "$1")');
                querySqlCommandCompletion.documentation = new vscode.MarkdownString('Setzt eine Query an bestehende Datenbankverbindung ab');
                items.push(querySqlCommandCompletion);
                const queryXMLCommandCompletion = new vscode.CompletionItem('queryXML');
                queryXMLCommandCompletion.kind = vscode.CompletionItemKind.Function;
                queryXMLCommandCompletion.insertText = new vscode.SnippetString('queryXML(XMLTEXT = "$1", EXPRESSION = "$2")');
                queryXMLCommandCompletion.documentation = new vscode.MarkdownString('Führt eine Suche auf einen XML-Text durch und schreibt das Ergebnis ggf. in eine csv Datei');
                items.push(queryXMLCommandCompletion);
                const readFileToStorageCommandCompletion = new vscode.CompletionItem('readFileToStorage');
                readFileToStorageCommandCompletion.kind = vscode.CompletionItemKind.Function;
                readFileToStorageCommandCompletion.insertText = new vscode.SnippetString('readFileToStorage(FILENAME = "$1", TARGET_STORAGE_KEY = "$2")');
                readFileToStorageCommandCompletion.documentation = new vscode.MarkdownString('Liest den Inhalt einer Datei in eine Storage-Variable ein.');
                items.push(readFileToStorageCommandCompletion);
                const readTextInPictureCommandCompletion = new vscode.CompletionItem('readTextInPicture');
                readTextInPictureCommandCompletion.kind = vscode.CompletionItemKind.Function;
                readTextInPictureCommandCompletion.insertText = new vscode.SnippetString('readTextInPicture(TARGET_STORAGE_KEY = "$1")');
                readTextInPictureCommandCompletion.documentation = new vscode.MarkdownString('Untersucht ein Bild oder einen Ausschnitt, und schreibt die gefundenen Worte in die Storage-Datei.');
                items.push(readTextInPictureCommandCompletion);
                const receiveMailCommandCompletion = new vscode.CompletionItem('receiveMail');
                receiveMailCommandCompletion.kind = vscode.CompletionItemKind.Function;
                receiveMailCommandCompletion.insertText = new vscode.SnippetString('receiveMail(SERVER = "$1", USER = "$2", PASSWORD = "$3", FOLDER = "$4", SUBJECT = "$5", SEARCH = "$6", LOCATION = "$7", TARGET_STORAGE_KEY = "$8")');
                receiveMailCommandCompletion.documentation = new vscode.MarkdownString('Fragt EINE E-Mail in einem bestimmten Ordner mit bestimmtem Betreff ab.    Es kann im Betreff oder im Textkörper der E-Mail mit einem regulären Ausdruck nach Inhalten gesucht  werden. Das Ergebnis dieser Suche wird in der Variable gespeichert, die mit TARGET_STORAGE_KEY benannt wird.    Anhänge der E-Mail können an einen gewünschten Ort abgespeichert werden. Die Namen der vorhandenen Anhänge können in ATTACHMENT_NAME_TARGET_STORAGE_KEY gespeichert werden. Ist mehr als    eine Datei angehangen, werden die Dateinamen in der angegebenen Storage-Variable mit Semikola (";") getrennt. Wichtig ist, dass das System korrekt konfiguriert ist. Ggf. muss z. B. eine etwaige Firewall    den Zugriff auf den angegebenen Mailserver zulassen.');
                items.push(receiveMailCommandCompletion);
                const receiveUnseenMailsSaveAttachmentCommandCompletion = new vscode.CompletionItem('receiveUnseenMailsSaveAttachment');
                receiveUnseenMailsSaveAttachmentCommandCompletion.kind = vscode.CompletionItemKind.Function;
                receiveUnseenMailsSaveAttachmentCommandCompletion.insertText = new vscode.SnippetString('receiveUnseenMailsSaveAttachment(SERVER = "$1", USER = "$2", PASSWORD = "$3", SUBJECT = "$4", FOLDER = "$5", ATTACHMENT_NAME_TARGET_STORAGE_KEY = "$6")');
                receiveUnseenMailsSaveAttachmentCommandCompletion.documentation = new vscode.MarkdownString('Fragt alle ungelesenen Mails ab.   Anhänge der E-Mail können an einen gewünschten Ort abgespeichert werden. Die Namen der vorhandenen Anhänge können in ATTACHMENT_NAME_TARGET_STORAGE_KEY gespeichert werden. Ist mehr als    eine Datei angehangen, werden die Dateinamen in der angegebenen Storage-Variable mit Semikola (";") getrennt. Wichtig ist, dass das System korrekt konfiguriert ist. Ggf. muss z. B. eine etwaige Firewall    den Zugriff auf den angegebenen Mailserver zulassen.');
                items.push(receiveUnseenMailsSaveAttachmentCommandCompletion);
                const refreshWebCommandCompletion = new vscode.CompletionItem('refreshWeb');
                refreshWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                refreshWebCommandCompletion.insertText = new vscode.SnippetString('refreshWeb()');
                refreshWebCommandCompletion.documentation = new vscode.MarkdownString('Aktualisiert die aktuelle Seite.');
                items.push(refreshWebCommandCompletion);
                const removeDuplicatesCommandCompletion = new vscode.CompletionItem('removeDuplicates');
                removeDuplicatesCommandCompletion.kind = vscode.CompletionItemKind.Function;
                removeDuplicatesCommandCompletion.insertText = new vscode.SnippetString('removeDuplicates(TEXT = "$1")');
                removeDuplicatesCommandCompletion.documentation = new vscode.MarkdownString('Unterteilt einem Text, z.B. eine Auflistung, anhand von Kommata oder Zeilenbrüchenund entfernt alle mehrfach vorkommenden Teile.');
                items.push(removeDuplicatesCommandCompletion);
                const renderFullscreenImageCommandCompletion = new vscode.CompletionItem('renderFullscreenImage');
                renderFullscreenImageCommandCompletion.kind = vscode.CompletionItemKind.Function;
                renderFullscreenImageCommandCompletion.insertText = new vscode.SnippetString('renderFullscreenImage()');
                renderFullscreenImageCommandCompletion.documentation = new vscode.MarkdownString('Rendert ein Bild als Vollbild. Es kann immer nur ein derartiges Bild gleichzeitig angezeigt werden.');
                items.push(renderFullscreenImageCommandCompletion);
                const renderOverlayImageCommandCompletion = new vscode.CompletionItem('renderOverlayImage');
                renderOverlayImageCommandCompletion.kind = vscode.CompletionItemKind.Function;
                renderOverlayImageCommandCompletion.insertText = new vscode.SnippetString('renderOverlayImage()');
                renderOverlayImageCommandCompletion.documentation = new vscode.MarkdownString('Rendert ein Bild über der Zielanwendung. Standardmäßig wird dieses dauerhaft angezeigt. Es kann immer nur ein derartiges Bild gleichzeitig angezeigt werden. Mit dem Parameter "DURATION" kann eine benutzerdefinierte Anzeigedauer festgelegt werden. Ohne die Angabe einer benutzerdefinierten Anzeigedauer wird das Bild dauerhaft angezeigt. Mittels der Parameter "WIDTH" und "HEIGHT" kann die Breite sowie die Höhe des anzuzeigenden Bildes festgelegt werden. Ohne die Angabe einer benutzerdefinierten Breite bzw. Höhe wird die Original-Breite bzw. -Höhe des Bildes genutzt. Falls nur ein Parameter ("WIDTH" oder "HEIGHT") angegeben wurde, wird das anzuzeigende Bild entsprechend gestreckt. Dabei wird das originale Seitenverhältnis außer Kraft gesetzt. ');
                items.push(renderOverlayImageCommandCompletion);
                const renderTextCommandCompletion = new vscode.CompletionItem('renderText');
                renderTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                renderTextCommandCompletion.insertText = new vscode.SnippetString('renderText()');
                renderTextCommandCompletion.documentation = new vscode.MarkdownString('Zeigt einen einzelnen Text auf dem Bildschirm an. Es kann immer nur ein derartiger Text gleichzeitig angezeigt werden. Die Anzeigedauer wird anhand des anzuzeigenden Textes berechnet, oder mittels des Parameters "DURATION" benutzerdefiniert festgelegt. ');
                items.push(renderTextCommandCompletion);
                const replaceInTextCommandCompletion = new vscode.CompletionItem('replaceInText');
                replaceInTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                replaceInTextCommandCompletion.insertText = new vscode.SnippetString('replaceInText(TEXT_OR_FILE = "$1", TARGET_STORAGE_KEY = "$2")');
                replaceInTextCommandCompletion.documentation = new vscode.MarkdownString('Ersetzt ein bestimmtes Wort oder einen festen Teilbereich in einem Text mit einem beliebigen Text.              Das Kommando sucht nach WORD_TO_REPLACE im Text und ersetzt jedes Vorkommen mit SUBSTITUTE.              Das bedeutet, dass bei mehreren Vorkommen des WORD_TO_REPLACE auch mehrere Ersetzungen stattfinden.               Werden die Parameter POS_FROM und POS_TO gesetzt, wird nicht nach WORD_TO_REPLACE gesucht, sondern der Text              zwischen den Positionen mit SUBSTITUTE ersetzt.');
                items.push(replaceInTextCommandCompletion);
                const replaceStringInStorageValueCommandCompletion = new vscode.CompletionItem('replaceStringInStorageValue');
                replaceStringInStorageValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                replaceStringInStorageValueCommandCompletion.insertText = new vscode.SnippetString('replaceStringInStorageValue(SOURCE_KEY = "$1", REGEX_TO_FIND = "$2")');
                replaceStringInStorageValueCommandCompletion.documentation = new vscode.MarkdownString('Ersetzt eine Regex in einer Variable. ');
                items.push(replaceStringInStorageValueCommandCompletion);
                const resetContextCommandCompletion = new vscode.CompletionItem('resetContext');
                resetContextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                resetContextCommandCompletion.insertText = new vscode.SnippetString('resetContext()');
                resetContextCommandCompletion.documentation = new vscode.MarkdownString('Re-initialisiert den TestContext. Dadurch werden unter anderem in Laufzeit-Properties gelöscht, die in Kommandos, die außerhalb von Testsets gestartet wurden (z.B. direkt aus dem Excel-Testsheet). Dieses Kommando darf nur einzeln aufgerufen werden (z.B. über die "Kommando ausühren"-Schaltfläche im Excel-Testsheet), nicht jedoch als Teil der Ausführung eines gesamten Testsets.');
                items.push(resetContextCommandCompletion);
                const rotateMobileCommandCompletion = new vscode.CompletionItem('rotateMobile');
                rotateMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                rotateMobileCommandCompletion.insertText = new vscode.SnippetString('rotateMobile(ORIENTATION = "$1")');
                rotateMobileCommandCompletion.documentation = new vscode.MarkdownString('Rotiert das Gerät bzw. den Simulator (Beispiel: RotateMobile("LANDSCAPE")).');
                items.push(rotateMobileCommandCompletion);
                const runAppInBackgroundMobileCommandCompletion = new vscode.CompletionItem('runAppInBackgroundMobile');
                runAppInBackgroundMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                runAppInBackgroundMobileCommandCompletion.insertText = new vscode.SnippetString('runAppInBackgroundMobile(WAIT_SECONDS = "$1")');
                runAppInBackgroundMobileCommandCompletion.documentation = new vscode.MarkdownString('Die aktuell geöffnete App wird für eine gewisse Zeit in den Hintergrund geschoben. Nach Ablauf dieser Zeit wird die App wieder in den Vordergrund geholt. Dieser Befehl ist notwenig, wenn simuliert werden soll, dass der Benutzer die aktive App wechselt, um zwischen verschiedenen Apps hin- und herzuspringen. Nachdem eine App anschließend wieder geöffnet wird, sollte der alte Zustand der App vorhanden sein, öffnet man aber die Applikation über das Kommando "startAndroid" wird eine neue Activitiy aufgebaut und der alte Zustand wird nicht beibehalten (Beispiel: runAppInBackgroundMobile("", "", "", "500")).');
                items.push(runAppInBackgroundMobileCommandCompletion);
                const runJavascriptAndroidCommandCompletion = new vscode.CompletionItem('runJavascriptAndroid');
                runJavascriptAndroidCommandCompletion.kind = vscode.CompletionItemKind.Function;
                runJavascriptAndroidCommandCompletion.insertText = new vscode.SnippetString('runJavascriptAndroid(JAVASCRIPT_TO_RUN = "$1")');
                runJavascriptAndroidCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando führt ein Java-Skript auf dem mobilen Gerät durch (Beispiel: runJavascriptAndroid("window.scrollTo(0,100);"). Im Beispiel wird im aktuellen Fenster 100 Pixel nach oben gescrollt.).');
                items.push(runJavascriptAndroidCommandCompletion);
                const runJavascriptWebCommandCompletion = new vscode.CompletionItem('runJavascriptWeb');
                runJavascriptWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                runJavascriptWebCommandCompletion.insertText = new vscode.SnippetString('runJavascriptWeb(JS_SCRIPT_OR_FILE = "$1")');
                runJavascriptWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando führt Javascript aus.');
                items.push(runJavascriptWebCommandCompletion);
                const sapConnectionNumberClearCommandCompletion = new vscode.CompletionItem('sapConnectionNumberClear');
                sapConnectionNumberClearCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapConnectionNumberClearCommandCompletion.insertText = new vscode.SnippetString('sapConnectionNumberClear()');
                sapConnectionNumberClearCommandCompletion.documentation = new vscode.MarkdownString('Leert die Connection Nr der aktuell zu steuernden SAP Session. Dadurch wird wieder über alle vorhandenen Sessions gesucht.');
                items.push(sapConnectionNumberClearCommandCompletion);
                const sapConnectionNumberSetCommandCompletion = new vscode.CompletionItem('sapConnectionNumberSet');
                sapConnectionNumberSetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapConnectionNumberSetCommandCompletion.insertText = new vscode.SnippetString('sapConnectionNumberSet(CONNECTION_NR = "$1")');
                sapConnectionNumberSetCommandCompletion.documentation = new vscode.MarkdownString('Setzt die Connection Nr der aktuell zu steuernden SAP Session. Dies wird benötigt, wenn mehr als eine SAP Instanz gesteuert werden soll.');
                items.push(sapConnectionNumberSetCommandCompletion);
                const sapContextMenuCommandCompletion = new vscode.CompletionItem('sapContextMenu');
                sapContextMenuCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapContextMenuCommandCompletion.insertText = new vscode.SnippetString('sapContextMenu(OBJECT_ID = "$1")');
                sapContextMenuCommandCompletion.documentation = new vscode.MarkdownString('Öffnet des Kontext Menü eines Objekts.');
                items.push(sapContextMenuCommandCompletion);
                const sapDoubleClickCommandCompletion = new vscode.CompletionItem('sapDoubleClick');
                sapDoubleClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapDoubleClickCommandCompletion.insertText = new vscode.SnippetString('sapDoubleClick(OBJECT_ID = "$1")');
                sapDoubleClickCommandCompletion.documentation = new vscode.MarkdownString('Doppelklickt ein Objekt');
                items.push(sapDoubleClickCommandCompletion);
                const sapFindStringInTreeAndDoubleClickCommandCompletion = new vscode.CompletionItem('sapFindStringInTreeAndDoubleClick');
                sapFindStringInTreeAndDoubleClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapFindStringInTreeAndDoubleClickCommandCompletion.insertText = new vscode.SnippetString('sapFindStringInTreeAndDoubleClick(OBJECT_ID = "$1", SUBSTRING = "$2")');
                sapFindStringInTreeAndDoubleClickCommandCompletion.documentation = new vscode.MarkdownString('Sucht einen Ausdruck innerhalb eines Objekt-Containers (z.B.: shell) und führt einen doubleClickNode aus.');
                items.push(sapFindStringInTreeAndDoubleClickCommandCompletion);
                const sapFindStringInTreeAndSelectCommandCompletion = new vscode.CompletionItem('sapFindStringInTreeAndSelect');
                sapFindStringInTreeAndSelectCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapFindStringInTreeAndSelectCommandCompletion.insertText = new vscode.SnippetString('sapFindStringInTreeAndSelect(OBJECT_ID = "$1", SUBSTRING = "$2")');
                sapFindStringInTreeAndSelectCommandCompletion.documentation = new vscode.MarkdownString('Sucht einen Ausdruck innerhalb eines Objekt-Containers (z.B.: shell) und führt ein selectNode aus.');
                items.push(sapFindStringInTreeAndSelectCommandCompletion);
                const sapFindStringInTreeByRegexAndDoubleClickCommandCompletion = new vscode.CompletionItem('sapFindStringInTreeByRegexAndDoubleClick');
                sapFindStringInTreeByRegexAndDoubleClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapFindStringInTreeByRegexAndDoubleClickCommandCompletion.insertText = new vscode.SnippetString('sapFindStringInTreeByRegexAndDoubleClick(OBJECT_ID = "$1", SUBSTRING = "$2")');
                sapFindStringInTreeByRegexAndDoubleClickCommandCompletion.documentation = new vscode.MarkdownString('Sucht einen regulären Ausdruck innerhalb eines Objekt-Containers (z.B.: shell) und führt ein doubleClickNode aus.');
                items.push(sapFindStringInTreeByRegexAndDoubleClickCommandCompletion);
                const sapFindStringInTreeByRegexAndSelectCommandCompletion = new vscode.CompletionItem('sapFindStringInTreeByRegexAndSelect');
                sapFindStringInTreeByRegexAndSelectCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapFindStringInTreeByRegexAndSelectCommandCompletion.insertText = new vscode.SnippetString('sapFindStringInTreeByRegexAndSelect(OBJECT_ID = "$1", SUBSTRING = "$2")');
                sapFindStringInTreeByRegexAndSelectCommandCompletion.documentation = new vscode.MarkdownString('Sucht einen regulären Ausdruck innerhalb eines Objekt-Containers (z.B.: shell) und führt ein selectNode aus.');
                items.push(sapFindStringInTreeByRegexAndSelectCommandCompletion);
                const sapFindStringInTreeUseFunctionCommandCompletion = new vscode.CompletionItem('sapFindStringInTreeUseFunction');
                sapFindStringInTreeUseFunctionCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapFindStringInTreeUseFunctionCommandCompletion.insertText = new vscode.SnippetString('sapFindStringInTreeUseFunction(OBJECT_ID = "$1", SUBSTRING = "$2", FUNCTION = "$3")');
                sapFindStringInTreeUseFunctionCommandCompletion.documentation = new vscode.MarkdownString('Sucht nach einem String in einer Tree und führt eine Funktion im Kontextmenü aus.');
                items.push(sapFindStringInTreeUseFunctionCommandCompletion);
                const sapGetCellValueCommandCompletion = new vscode.CompletionItem('sapGetCellValue');
                sapGetCellValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapGetCellValueCommandCompletion.insertText = new vscode.SnippetString('sapGetCellValue(OBJECT_ID = "$1", ROW_NUMBER = "$2", COLUMN_NAME = "$3", TARGET_STORAGE_KEY = "$4")');
                sapGetCellValueCommandCompletion.documentation = new vscode.MarkdownString('Erfassen des Wertes einer Zelle in einer SAP-Tabelle.');
                items.push(sapGetCellValueCommandCompletion);
                const sapGetRowNrWithRegexCommandCompletion = new vscode.CompletionItem('sapGetRowNrWithRegex');
                sapGetRowNrWithRegexCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapGetRowNrWithRegexCommandCompletion.insertText = new vscode.SnippetString('sapGetRowNrWithRegex(OBJECT_ID = "$1", COLUMN_NAME = "$2", REGEX = "$3", TARGET_STORAGE_KEY = "$4")');
                sapGetRowNrWithRegexCommandCompletion.documentation = new vscode.MarkdownString('Liest den Wert einer Spalte anhand einer Regex aus ');
                items.push(sapGetRowNrWithRegexCommandCompletion);
                const sapGetValueOfRowWithRegexCommandCompletion = new vscode.CompletionItem('sapGetValueOfRowWithRegex');
                sapGetValueOfRowWithRegexCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapGetValueOfRowWithRegexCommandCompletion.insertText = new vscode.SnippetString('sapGetValueOfRowWithRegex(OBJECT_ID = "$1", COLUMN_NAME = "$2", REGEX = "$3", TARGET_STORAGE_KEY = "$4")');
                sapGetValueOfRowWithRegexCommandCompletion.documentation = new vscode.MarkdownString('Liest den Wert einer Spalte anhand einer Regex aus ');
                items.push(sapGetValueOfRowWithRegexCommandCompletion);
                const sapNodeCollapseByKeyCommandCompletion = new vscode.CompletionItem('sapNodeCollapseByKey');
                sapNodeCollapseByKeyCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapNodeCollapseByKeyCommandCompletion.insertText = new vscode.SnippetString('sapNodeCollapseByKey(OBJECT_ID = "$1", NODE = "$2")');
                sapNodeCollapseByKeyCommandCompletion.documentation = new vscode.MarkdownString('Ein Node innerhalb eines SAP Objekt-Containers (z.B. shell) wird zusammengeklappt.');
                items.push(sapNodeCollapseByKeyCommandCompletion);
                const sapNodeContextMenuCommandCompletion = new vscode.CompletionItem('sapNodeContextMenu');
                sapNodeContextMenuCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapNodeContextMenuCommandCompletion.insertText = new vscode.SnippetString('sapNodeContextMenu(OBJECT_ID = "$1", NODE = "$2")');
                sapNodeContextMenuCommandCompletion.documentation = new vscode.MarkdownString('Wählt eine Node eines SAP Kontext Menüs aus');
                items.push(sapNodeContextMenuCommandCompletion);
                const sapNodeDoubleClickCommandCompletion = new vscode.CompletionItem('sapNodeDoubleClick');
                sapNodeDoubleClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapNodeDoubleClickCommandCompletion.insertText = new vscode.SnippetString('sapNodeDoubleClick(OBJECT_ID = "$1", NODE = "$2")');
                sapNodeDoubleClickCommandCompletion.documentation = new vscode.MarkdownString('Doppelklickt eine Node eines SAP Kontext Menüs aus');
                items.push(sapNodeDoubleClickCommandCompletion);
                const sapNodeExpandByKeyCommandCompletion = new vscode.CompletionItem('sapNodeExpandByKey');
                sapNodeExpandByKeyCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapNodeExpandByKeyCommandCompletion.insertText = new vscode.SnippetString('sapNodeExpandByKey(OBJECT_ID = "$1", NODE = "$2")');
                sapNodeExpandByKeyCommandCompletion.documentation = new vscode.MarkdownString('Ein Node innerhalb eines SAP Objekt-Containers (z.B. shell) wird erweitert bzw. aufgeklappt.');
                items.push(sapNodeExpandByKeyCommandCompletion);
                const sapObjDeselectCommandCompletion = new vscode.CompletionItem('sapObjDeselect');
                sapObjDeselectCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjDeselectCommandCompletion.insertText = new vscode.SnippetString('sapObjDeselect(OBJECT_ID = "$1")');
                sapObjDeselectCommandCompletion.documentation = new vscode.MarkdownString('Unselektiert ein Objekt');
                items.push(sapObjDeselectCommandCompletion);
                const sapObjFindByRegexCommandCompletion = new vscode.CompletionItem('sapObjFindByRegex');
                sapObjFindByRegexCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjFindByRegexCommandCompletion.insertText = new vscode.SnippetString('sapObjFindByRegex(REGEX = "$1", TARGET_STORAGE_KEY = "$2")');
                sapObjFindByRegexCommandCompletion.documentation = new vscode.MarkdownString('Sucht ein ein Objekt anhand eines regulären Ausdrucks (regex) und gibt die Id des gefundenen Elements zurück.');
                items.push(sapObjFindByRegexCommandCompletion);
                const sapObjFindByValueCommandCompletion = new vscode.CompletionItem('sapObjFindByValue');
                sapObjFindByValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjFindByValueCommandCompletion.insertText = new vscode.SnippetString('sapObjFindByValue(OBJECT_VALUE = "$1", TARGET_STORAGE_KEY = "$2")');
                sapObjFindByValueCommandCompletion.documentation = new vscode.MarkdownString('Sucht ein ein Objekt anhand des Values. Gibt die Id des gefundenen Elements zurück.');
                items.push(sapObjFindByValueCommandCompletion);
                const sapObjPressCommandCompletion = new vscode.CompletionItem('sapObjPress');
                sapObjPressCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjPressCommandCompletion.insertText = new vscode.SnippetString('sapObjPress(OBJECT_ID = "$1")');
                sapObjPressCommandCompletion.documentation = new vscode.MarkdownString('Führt die Press Methode auf dem Zielelement aus.');
                items.push(sapObjPressCommandCompletion);
                const sapObjPropertyGetCommandCompletion = new vscode.CompletionItem('sapObjPropertyGet');
                sapObjPropertyGetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjPropertyGetCommandCompletion.insertText = new vscode.SnippetString('sapObjPropertyGet(OBJECT_ID = "$1", OBJECT_PROPERTY = "$2", TARGET_STORAGE_KEY = "$3")');
                sapObjPropertyGetCommandCompletion.documentation = new vscode.MarkdownString('Liest den Wert eines Attributs eines Objekts aus.');
                items.push(sapObjPropertyGetCommandCompletion);
                const sapObjPropertySetCommandCompletion = new vscode.CompletionItem('sapObjPropertySet');
                sapObjPropertySetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjPropertySetCommandCompletion.insertText = new vscode.SnippetString('sapObjPropertySet(OBJECT_ID = "$1", OBJECT_PROPERTY = "$2", OBJECT_VALUE = "$3")');
                sapObjPropertySetCommandCompletion.documentation = new vscode.MarkdownString('Setzt den Wert eines Attributs eines Objekts.');
                items.push(sapObjPropertySetCommandCompletion);
                const sapObjSelectCommandCompletion = new vscode.CompletionItem('sapObjSelect');
                sapObjSelectCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjSelectCommandCompletion.insertText = new vscode.SnippetString('sapObjSelect(OBJECT_ID = "$1")');
                sapObjSelectCommandCompletion.documentation = new vscode.MarkdownString('Selektiert/Clickt ein Objekt.');
                items.push(sapObjSelectCommandCompletion);
                const sapObjSelectColumnCommandCompletion = new vscode.CompletionItem('sapObjSelectColumn');
                sapObjSelectColumnCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjSelectColumnCommandCompletion.insertText = new vscode.SnippetString('sapObjSelectColumn(OBJECT_ID = "$1", COLUMN_ID = "$2")');
                sapObjSelectColumnCommandCompletion.documentation = new vscode.MarkdownString('Eine Spalte innerhalb eines Objekt-Containers (z.B. shell) wird anhand der technischen Spaltenbezeichnung ausgewählt. Die technische Spaltenbezeichnung kann z.B. über einen SAP Scripting Tracker mittels des DumpState ausgelesen werden.');
                items.push(sapObjSelectColumnCommandCompletion);
                const sapObjSelectKeyCommandCompletion = new vscode.CompletionItem('sapObjSelectKey');
                sapObjSelectKeyCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjSelectKeyCommandCompletion.insertText = new vscode.SnippetString('sapObjSelectKey(OBJECT_ID = "$1", KEY_VALUE = "$2")');
                sapObjSelectKeyCommandCompletion.documentation = new vscode.MarkdownString('Selektiert den Objekt-Schlüssel eines Objekt-Containers (z.B.: von SAP-Shell-Objekten).');
                items.push(sapObjSelectKeyCommandCompletion);
                const sapObjSetFocusCommandCompletion = new vscode.CompletionItem('sapObjSetFocus');
                sapObjSetFocusCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjSetFocusCommandCompletion.insertText = new vscode.SnippetString('sapObjSetFocus(OBJECT_ID = "$1")');
                sapObjSetFocusCommandCompletion.documentation = new vscode.MarkdownString('Setzt den Fokus auf ein Zielelement');
                items.push(sapObjSetFocusCommandCompletion);
                const sapObjValueGetCommandCompletion = new vscode.CompletionItem('sapObjValueGet');
                sapObjValueGetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjValueGetCommandCompletion.insertText = new vscode.SnippetString('sapObjValueGet(OBJECT_ID = "$1", TARGET_STORAGE_KEY = "$2")');
                sapObjValueGetCommandCompletion.documentation = new vscode.MarkdownString('Liest den Wert eines Objekts aus.');
                items.push(sapObjValueGetCommandCompletion);
                const sapObjValueSetCommandCompletion = new vscode.CompletionItem('sapObjValueSet');
                sapObjValueSetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapObjValueSetCommandCompletion.insertText = new vscode.SnippetString('sapObjValueSet(OBJECT_ID = "$1", OBJECT_VALUE = "$2")');
                sapObjValueSetCommandCompletion.documentation = new vscode.MarkdownString('Setzt den Wert eines Objekts.');
                items.push(sapObjValueSetCommandCompletion);
                const sapPressContextButtonCommandCompletion = new vscode.CompletionItem('sapPressContextButton');
                sapPressContextButtonCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapPressContextButtonCommandCompletion.insertText = new vscode.SnippetString('sapPressContextButton(OBJECT_ID = "$1", BUTTON = "$2")');
                sapPressContextButtonCommandCompletion.documentation = new vscode.MarkdownString('Führt die Press Methode für einen Context-Button aus.');
                items.push(sapPressContextButtonCommandCompletion);
                const sapSelectComboBoxEntryByValueCommandCompletion = new vscode.CompletionItem('sapSelectComboBoxEntryByValue');
                sapSelectComboBoxEntryByValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapSelectComboBoxEntryByValueCommandCompletion.insertText = new vscode.SnippetString('sapSelectComboBoxEntryByValue(OBJECT_ID = "$1", SEARCHSTRING = "$2")');
                sapSelectComboBoxEntryByValueCommandCompletion.documentation = new vscode.MarkdownString('Wählt einen Combo-Box Eintrag anhand des Wertes aus');
                items.push(sapSelectComboBoxEntryByValueCommandCompletion);
                const sapSelectContextMenuItemCommandCompletion = new vscode.CompletionItem('sapSelectContextMenuItem');
                sapSelectContextMenuItemCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapSelectContextMenuItemCommandCompletion.insertText = new vscode.SnippetString('sapSelectContextMenuItem(OBJECT_ID = "$1", ITEM = "$2")');
                sapSelectContextMenuItemCommandCompletion.documentation = new vscode.MarkdownString('Selektiert ein Kontext Menü Item (Wählt dieses nicht notwendigerweise aus, in dem Fall noch SapNodeContextMenu oder SapNodeDoubleClick verwenden).');
                items.push(sapSelectContextMenuItemCommandCompletion);
                const sapSelectContextMenuItemByPositionCommandCompletion = new vscode.CompletionItem('sapSelectContextMenuItemByPosition');
                sapSelectContextMenuItemByPositionCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapSelectContextMenuItemByPositionCommandCompletion.insertText = new vscode.SnippetString('sapSelectContextMenuItemByPosition(OBJECT_ID = "$1", POSITION = "$2")');
                sapSelectContextMenuItemByPositionCommandCompletion.documentation = new vscode.MarkdownString('Selektiert ein Kontext Menü Item anhand der Position.');
                items.push(sapSelectContextMenuItemByPositionCommandCompletion);
                const sapSessAttachCommandCompletion = new vscode.CompletionItem('sapSessAttach');
                sapSessAttachCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapSessAttachCommandCompletion.insertText = new vscode.SnippetString('sapSessAttach(WINDOW_NAME = "$1")');
                sapSessAttachCommandCompletion.documentation = new vscode.MarkdownString('Wird verwendet um den SAP Treiber an eine bestimmte Session anzudocken. Dies ist notwendig bevor alle weiteren Kommandos verwendet werden können.');
                items.push(sapSessAttachCommandCompletion);
                const sapSessCreateCommandCompletion = new vscode.CompletionItem('sapSessCreate');
                sapSessCreateCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapSessCreateCommandCompletion.insertText = new vscode.SnippetString('sapSessCreate()');
                sapSessCreateCommandCompletion.documentation = new vscode.MarkdownString('Erzeugt eine neue Sap Session. Es muss vorher bereits an eine Session angedockt worden sein mittels SapSessAttach.');
                items.push(sapSessCreateCommandCompletion);
                const sapSetCurrentCellFocusCommandCompletion = new vscode.CompletionItem('sapSetCurrentCellFocus');
                sapSetCurrentCellFocusCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapSetCurrentCellFocusCommandCompletion.insertText = new vscode.SnippetString('sapSetCurrentCellFocus(OBJECT_ID = "$1", COLUMN_NAME = "$2", ROW_NUMBER = "$3")');
                sapSetCurrentCellFocusCommandCompletion.documentation = new vscode.MarkdownString('Es wird eine Zelle in einer SAP-Tabelle fokussiert.');
                items.push(sapSetCurrentCellFocusCommandCompletion);
                const sapShowContextMenuCommandCompletion = new vscode.CompletionItem('sapShowContextMenu');
                sapShowContextMenuCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapShowContextMenuCommandCompletion.insertText = new vscode.SnippetString('sapShowContextMenu(OBJECT_ID = "$1")');
                sapShowContextMenuCommandCompletion.documentation = new vscode.MarkdownString('Öffnet das Context Menü für ein Objekt');
                items.push(sapShowContextMenuCommandCompletion);
                const sapVKeysSendCommandCompletion = new vscode.CompletionItem('sapVKeysSend');
                sapVKeysSendCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapVKeysSendCommandCompletion.insertText = new vscode.SnippetString('sapVKeysSend(VKEYS_TO_SEND = "$1")');
                sapVKeysSendCommandCompletion.documentation = new vscode.MarkdownString('Versendet VKeys an die aktuelle SAP Session. Verfügbar sind folgende Tasten bzw. Tastenkombinationen:  Enter, F1 bis F12, Shift+F1 bis F12, Shift+Ctrl+0, Ctrl+F1 bis F12, Ctrl+Shift+F1 bis F12, Ctrl+E, Ctrl+F, Ctrl+A, Ctrl+D, Ctrl+N, Ctrl+O, Shift+D, Ctrl+I, Shift+I, Alt+B, Ctrl+Page up, Page up, Page down, Ctrl+Page down, Ctrl+G, Ctrl+R, Ctrl+P');
                items.push(sapVKeysSendCommandCompletion);
                const sapVKeysSendUntilWinExistsCommandCompletion = new vscode.CompletionItem('sapVKeysSendUntilWinExists');
                sapVKeysSendUntilWinExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapVKeysSendUntilWinExistsCommandCompletion.insertText = new vscode.SnippetString('sapVKeysSendUntilWinExists(VKEYS_TO_SEND = "$1", WIN_TITLE = "$2")');
                sapVKeysSendUntilWinExistsCommandCompletion.documentation = new vscode.MarkdownString('Versendet VKeys an die aktuelle SAP Session bis ein Zielfenster existiert. ACHTUNG: KANN ENDLOSSCHLEIFEN ERZEUGEN!');
                items.push(sapVKeysSendUntilWinExistsCommandCompletion);
                const sapVerticalScrollbarPositionCommandCompletion = new vscode.CompletionItem('sapVerticalScrollbarPosition');
                sapVerticalScrollbarPositionCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapVerticalScrollbarPositionCommandCompletion.insertText = new vscode.SnippetString('sapVerticalScrollbarPosition(OBJECT_ID = "$1", POSITION = "$2")');
                sapVerticalScrollbarPositionCommandCompletion.documentation = new vscode.MarkdownString('Setzt die Position der vertikalen Scrollbar für ein Objekt');
                items.push(sapVerticalScrollbarPositionCommandCompletion);
                const sapVerticalScrollbarPositionIncreaseCommandCompletion = new vscode.CompletionItem('sapVerticalScrollbarPositionIncrease');
                sapVerticalScrollbarPositionIncreaseCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapVerticalScrollbarPositionIncreaseCommandCompletion.insertText = new vscode.SnippetString('sapVerticalScrollbarPositionIncrease(OBJECT_ID = "$1", INCREASE = "$2")');
                sapVerticalScrollbarPositionIncreaseCommandCompletion.documentation = new vscode.MarkdownString('Verändert die Position der vertikalen Scrollbar für ein Objekt');
                items.push(sapVerticalScrollbarPositionIncreaseCommandCompletion);
                const sapWinCloseCommandCompletion = new vscode.CompletionItem('sapWinClose');
                sapWinCloseCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapWinCloseCommandCompletion.insertText = new vscode.SnippetString('sapWinClose(WIN_TITLE = "$1")');
                sapWinCloseCommandCompletion.documentation = new vscode.MarkdownString('Schließt ein SAP Fenster');
                items.push(sapWinCloseCommandCompletion);
                const sapWinExistsCommandCompletion = new vscode.CompletionItem('sapWinExists');
                sapWinExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapWinExistsCommandCompletion.insertText = new vscode.SnippetString('sapWinExists(WIN_TITLE = "$1")');
                sapWinExistsCommandCompletion.documentation = new vscode.MarkdownString('Prüft ob ein SAP Fenster mit einem bestimmten Namen existiert.');
                items.push(sapWinExistsCommandCompletion);
                const sapWinNumberSetCommandCompletion = new vscode.CompletionItem('sapWinNumberSet');
                sapWinNumberSetCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sapWinNumberSetCommandCompletion.insertText = new vscode.SnippetString('sapWinNumberSet(WINDOW_NR = "$1")');
                sapWinNumberSetCommandCompletion.documentation = new vscode.MarkdownString('Setzt die Fensternummer des aktuell zu steuernden SAP Fensters. Dies wird benötigt, wenn z.B. PopUps erscheinen.');
                items.push(sapWinNumberSetCommandCompletion);
                const savePictureWebCommandCompletion = new vscode.CompletionItem('savePictureWeb');
                savePictureWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                savePictureWebCommandCompletion.insertText = new vscode.SnippetString('savePictureWeb(ELEMENT_NAME = "$1", TARGET_PATH = "$2")');
                savePictureWebCommandCompletion.documentation = new vscode.MarkdownString('Lädt ein Bild von einer Webseite.');
                items.push(savePictureWebCommandCompletion);
                const scrollDownMobileCommandCompletion = new vscode.CompletionItem('scrollDownMobile');
                scrollDownMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                scrollDownMobileCommandCompletion.insertText = new vscode.SnippetString('scrollDownMobile()');
                scrollDownMobileCommandCompletion.documentation = new vscode.MarkdownString('Der Befehl scrollt herunter.');
                items.push(scrollDownMobileCommandCompletion);
                const scrollMobileCommandCompletion = new vscode.CompletionItem('scrollMobile');
                scrollMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                scrollMobileCommandCompletion.insertText = new vscode.SnippetString('scrollMobile(FROM_X = "$1", FROM_Y = "$2", TO_X = "$3", TO_Y = "$4")');
                scrollMobileCommandCompletion.documentation = new vscode.MarkdownString('Der Befehl scrollt von einem Startpunkt zu einem Endpunkt.');
                items.push(scrollMobileCommandCompletion);
                const scrollMouseWheelCommandCompletion = new vscode.CompletionItem('scrollMouseWheel');
                scrollMouseWheelCommandCompletion.kind = vscode.CompletionItemKind.Function;
                scrollMouseWheelCommandCompletion.insertText = new vscode.SnippetString('scrollMouseWheel(WHEEL_DIRECTION = "$1", NUMBER_OF_WHEEL_TURNS = "$2")');
                scrollMouseWheelCommandCompletion.documentation = new vscode.MarkdownString('Bewegt das Mausrad (Scrollen)');
                items.push(scrollMouseWheelCommandCompletion);
                const scrollToElementInGridWebCommandCompletion = new vscode.CompletionItem('scrollToElementInGridWeb');
                scrollToElementInGridWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                scrollToElementInGridWebCommandCompletion.insertText = new vscode.SnippetString('scrollToElementInGridWeb(BY_CRITERIA_GRID = "$1", ELEMENT_NAME_GRID = "$2", BY_CRITERIA_ELEMENT = "$3", ELEMENT_NAME_ELEMENT = "$4")');
                scrollToElementInGridWebCommandCompletion.documentation = new vscode.MarkdownString('Scrollt ein Element innerhalb eines Grids in den sichtbaren Bereich');
                items.push(scrollToElementInGridWebCommandCompletion);
                const scrollToElementWebCommandCompletion = new vscode.CompletionItem('scrollToElementWeb');
                scrollToElementWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                scrollToElementWebCommandCompletion.insertText = new vscode.SnippetString('scrollToElementWeb(ELEMENT_NAME = "$1")');
                scrollToElementWebCommandCompletion.documentation = new vscode.MarkdownString('Scrollt ein Element in den sichtbaren Bereich.');
                items.push(scrollToElementWebCommandCompletion);
                const scrollToWebCommandCompletion = new vscode.CompletionItem('scrollToWeb');
                scrollToWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                scrollToWebCommandCompletion.insertText = new vscode.SnippetString('scrollToWeb(X = "$1", Y = "$2")');
                scrollToWebCommandCompletion.documentation = new vscode.MarkdownString('Scollt auf einer Webseite zu einem mit den Pixel-Werte angegebenen absoluten Punkt (JavaScript-Funktion scrollTo()).');
                items.push(scrollToWebCommandCompletion);
                const scrollUpMobileCommandCompletion = new vscode.CompletionItem('scrollUpMobile');
                scrollUpMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                scrollUpMobileCommandCompletion.insertText = new vscode.SnippetString('scrollUpMobile()');
                scrollUpMobileCommandCompletion.documentation = new vscode.MarkdownString('Der Befehl scrollt hoch.');
                items.push(scrollUpMobileCommandCompletion);
                const scrollWebCommandCompletion = new vscode.CompletionItem('scrollWeb');
                scrollWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                scrollWebCommandCompletion.insertText = new vscode.SnippetString('scrollWeb(SCROLL_AMOUNT_X = "$1", SCROLL_AMOUNT_Y = "$2")');
                scrollWebCommandCompletion.documentation = new vscode.MarkdownString('Scrollt auf einer Webseite relativ vom aktuellen Punkt anhand der angegebenen Pixel-Werte (JavaScript-Funktion scrollBy()).');
                items.push(scrollWebCommandCompletion);
                const selectElementDropDownWinEleCommandCompletion = new vscode.CompletionItem('selectElementDropDownWinEle');
                selectElementDropDownWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                selectElementDropDownWinEleCommandCompletion.insertText = new vscode.SnippetString('selectElementDropDownWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", ELEMENT_NAME = "$3")');
                selectElementDropDownWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando selektiert ein definiertes Element aus einem Dropdown Menü.');
                items.push(selectElementDropDownWinEleCommandCompletion);
                const selectItemByTextJavaCommandCompletion = new vscode.CompletionItem('selectItemByTextJava');
                selectItemByTextJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                selectItemByTextJavaCommandCompletion.insertText = new vscode.SnippetString('selectItemByTextJava(TARGET = "$1", TEXT = "$2")');
                selectItemByTextJavaCommandCompletion.documentation = new vscode.MarkdownString('Selektiert ein angegebenes Element innerhalb einer Tabelle einer Java Anwendung an.');
                items.push(selectItemByTextJavaCommandCompletion);
                const selectJavaCommandCompletion = new vscode.CompletionItem('selectJava');
                selectJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                selectJavaCommandCompletion.insertText = new vscode.SnippetString('selectJava(TARGET = "$1", INDEX = "$2")');
                selectJavaCommandCompletion.documentation = new vscode.MarkdownString('Setzt den auszuwählenden Index innerhalb einer Liste');
                items.push(selectJavaCommandCompletion);
                const selectMobileCommandCompletion = new vscode.CompletionItem('selectMobile');
                selectMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                selectMobileCommandCompletion.insertText = new vscode.SnippetString('selectMobile(EXPRESSION_TEXT = "$1", SELECT_LABEL = "$2")');
                selectMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando selektiert ein Element einer Liste, nachdem es gefunden wurde (Beispiel: selectMobile("name", "Radiobutton1", "", "")).');
                items.push(selectMobileCommandCompletion);
                const selectWebCommandCompletion = new vscode.CompletionItem('selectWeb');
                selectWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                selectWebCommandCompletion.insertText = new vscode.SnippetString('selectWeb(BY_CRITERIA = "$1", ELEMENT_NAME = "$2", SELECT_LABEL = "$3")');
                selectWebCommandCompletion.documentation = new vscode.MarkdownString('Wählt aus einem Select-Element (wie z.B. einer Drop-Down-Box) ein Element aus.');
                items.push(selectWebCommandCompletion);
                const sendMailCommandCompletion = new vscode.CompletionItem('sendMail');
                sendMailCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendMailCommandCompletion.insertText = new vscode.SnippetString('sendMail(SERVER = "$1", USER = "$2", PASSWORD = "$3", SUBJECT = "$4", CONTENT = "$5", SENDER = "$6", RECEIVER = "$7", PORT = "$8")');
                sendMailCommandCompletion.documentation = new vscode.MarkdownString('Versendet E-Mails');
                items.push(sendMailCommandCompletion);
                const sendTextAutomIdWinEleCommandCompletion = new vscode.CompletionItem('sendTextAutomIdWinEle');
                sendTextAutomIdWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextAutomIdWinEleCommandCompletion.insertText = new vscode.SnippetString('sendTextAutomIdWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", TEXT_TO_SEND = "$3", TEXT_BOX_AUTOMATION_ID = "$4")');
                sendTextAutomIdWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando sendet einen Text an ein Eingabeelement anhand einer eindeutigen ID.');
                items.push(sendTextAutomIdWinEleCommandCompletion);
                const sendTextByPasteCommandCompletion = new vscode.CompletionItem('sendTextByPaste');
                sendTextByPasteCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextByPasteCommandCompletion.insertText = new vscode.SnippetString('sendTextByPaste()');
                sendTextByPasteCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Text');
                items.push(sendTextByPasteCommandCompletion);
                const sendTextCPCommandCompletion = new vscode.CompletionItem('sendTextCP');
                sendTextCPCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextCPCommandCompletion.insertText = new vscode.SnippetString('sendTextCP(TEXT_TO_SEND = "$1")');
                sendTextCPCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Text durch Tastatur-Simulation.');
                items.push(sendTextCPCommandCompletion);
                const sendTextClassnameWinEleCommandCompletion = new vscode.CompletionItem('sendTextClassnameWinEle');
                sendTextClassnameWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextClassnameWinEleCommandCompletion.insertText = new vscode.SnippetString('sendTextClassnameWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", CLASS_NAME = "$3")');
                sendTextClassnameWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando sendet einen Text an ein Eingabeelement anhand der übergebenen Klasse. Wird kein text angegeben, wird das Feld fokussiert.');
                items.push(sendTextClassnameWinEleCommandCompletion);
                const sendTextJavaCommandCompletion = new vscode.CompletionItem('sendTextJava');
                sendTextJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextJavaCommandCompletion.insertText = new vscode.SnippetString('sendTextJava(TARGET = "$1", TEXT = "$2")');
                sendTextJavaCommandCompletion.documentation = new vscode.MarkdownString('Sucht eine Java Swing Komponente und übergibt einen Text über die Zwischenablage. Um Tastaturbefehle auszuführen verwenden Sie bitte SendTextWin oder SendTextCP');
                items.push(sendTextJavaCommandCompletion);
                const sendTextMobileCommandCompletion = new vscode.CompletionItem('sendTextMobile');
                sendTextMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextMobileCommandCompletion.insertText = new vscode.SnippetString('sendTextMobile(EXPRESSION_TEXT = "$1", TEXT_TO_SEND = "$2")');
                sendTextMobileCommandCompletion.documentation = new vscode.MarkdownString('Schreibt einen Text in ein Element (in der Regel ein Textfeld), nachdem es gefunden wurde (Beispiel: sendTextMobile("name", "Textfeld1", "Hello World", "500", "true")).');
                items.push(sendTextMobileCommandCompletion);
                const sendTextRawCommandCompletion = new vscode.CompletionItem('sendTextRaw');
                sendTextRawCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextRawCommandCompletion.insertText = new vscode.SnippetString('sendTextRaw(TEXT_TO_SEND = "$1")');
                sendTextRawCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen ungeparsten Text (Sequenzen wie {DATE} oder {ENTER} werden nicht interpretiert sondern als Strings Übernommen)');
                items.push(sendTextRawCommandCompletion);
                const sendTextWebCommandCompletion = new vscode.CompletionItem('sendTextWeb');
                sendTextWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextWebCommandCompletion.insertText = new vscode.SnippetString('sendTextWeb(ELEMENT_NAME = "$1")');
                sendTextWebCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Text an ein Element.');
                items.push(sendTextWebCommandCompletion);
                const sendTextWebByPasteCommandCompletion = new vscode.CompletionItem('sendTextWebByPaste');
                sendTextWebByPasteCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextWebByPasteCommandCompletion.insertText = new vscode.SnippetString('sendTextWebByPaste(ELEMENT_NAME = "$1", TEXT_TO_SEND = "$2")');
                sendTextWebByPasteCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Text an ein Web-Element. Das Kommando verhält sich ähnlich zu sendTextWeb.     Allerdings wird der Text intern zunächst in die Zwischenablage kopiert und dann aus der Zwischenablage in das Web-Element eingefügt.');
                items.push(sendTextWebByPasteCommandCompletion);
                const sendTextWebFastCommandCompletion = new vscode.CompletionItem('sendTextWebFast');
                sendTextWebFastCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextWebFastCommandCompletion.insertText = new vscode.SnippetString('sendTextWebFast(ELEMENT_NAME = "$1", TEXT_TO_SEND = "$2")');
                sendTextWebFastCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Text an ein Element. Im Gegensatz zu SendTextWEb wird dabei vorher nicht überprüft, ob das Element vorhanden ist. Das Kommando ist daher nicht immer stabil!');
                items.push(sendTextWebFastCommandCompletion);
                const sendTextWinCommandCompletion = new vscode.CompletionItem('sendTextWin');
                sendTextWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextWinCommandCompletion.insertText = new vscode.SnippetString('sendTextWin()');
                sendTextWinCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Text an ein Fenster (bzw. ein darin enthaltenes Textfeld)');
                items.push(sendTextWinCommandCompletion);
                const sendTextWinEleCommandCompletion = new vscode.CompletionItem('sendTextWinEle');
                sendTextWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextWinEleCommandCompletion.insertText = new vscode.SnippetString('sendTextWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", TEXT_TO_SEND = "$3", TEXT_BOX_NAME = "$4")');
                sendTextWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando sendet einen Text an ein Eingabeelement anhand dessen Namen.');
                items.push(sendTextWinEleCommandCompletion);
                const sendTextWindowWinCommandCompletion = new vscode.CompletionItem('sendTextWindowWin');
                sendTextWindowWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                sendTextWindowWinCommandCompletion.insertText = new vscode.SnippetString('sendTextWindowWin(WINDOW_NAME = "$1", TEXT_TO_SEND = "$2")');
                sendTextWindowWinCommandCompletion.documentation = new vscode.MarkdownString('Sendet einen Text an ein explizit anzugebendes Fenster');
                items.push(sendTextWindowWinCommandCompletion);
                const setActiveWindowJavaCommandCompletion = new vscode.CompletionItem('setActiveWindowJava');
                setActiveWindowJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                setActiveWindowJavaCommandCompletion.insertText = new vscode.SnippetString('setActiveWindowJava(TITLE = "$1")');
                setActiveWindowJavaCommandCompletion.documentation = new vscode.MarkdownString('Setzt ein Fenster als aktives Java Fenster. Es kann vorkommen, dass vorher mittels z.B. winActivate das Fenster fokussiert werden muss.');
                items.push(setActiveWindowJavaCommandCompletion);
                const setAllStorageFromInputCommandCompletion = new vscode.CompletionItem('setAllStorageFromInput');
                setAllStorageFromInputCommandCompletion.kind = vscode.CompletionItemKind.Function;
                setAllStorageFromInputCommandCompletion.insertText = new vscode.SnippetString('setAllStorageFromInput()');
                setAllStorageFromInputCommandCompletion.documentation = new vscode.MarkdownString('Schreibt alle übergebenen Parameter in den Storage');
                items.push(setAllStorageFromInputCommandCompletion);
                const setClipboardValueCommandCompletion = new vscode.CompletionItem('setClipboardValue');
                setClipboardValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                setClipboardValueCommandCompletion.insertText = new vscode.SnippetString('setClipboardValue(VALUE = "$1")');
                setClipboardValueCommandCompletion.documentation = new vscode.MarkdownString('Verändert den Wert der Zwischenablage auf einen neuen String.');
                items.push(setClipboardValueCommandCompletion);
                const setCookieWebCommandCompletion = new vscode.CompletionItem('setCookieWeb');
                setCookieWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                setCookieWebCommandCompletion.insertText = new vscode.SnippetString('setCookieWeb(COOKIE_NAME = "$1", COOKIE_VALUE = "$2")');
                setCookieWebCommandCompletion.documentation = new vscode.MarkdownString('Setzt ein Cookies auf der aktuellen Website.');
                items.push(setCookieWebCommandCompletion);
                const setPropertyCommandCompletion = new vscode.CompletionItem('setProperty');
                setPropertyCommandCompletion.kind = vscode.CompletionItemKind.Function;
                setPropertyCommandCompletion.insertText = new vscode.SnippetString('setProperty(KEY = "$1", VALUE = "$2")');
                setPropertyCommandCompletion.documentation = new vscode.MarkdownString('Setzt eine Laufzeit-Property (testrun property)');
                items.push(setPropertyCommandCompletion);
                const setStorageFromInputCommandCompletion = new vscode.CompletionItem('setStorageFromInput');
                setStorageFromInputCommandCompletion.kind = vscode.CompletionItemKind.Function;
                setStorageFromInputCommandCompletion.insertText = new vscode.SnippetString('setStorageFromInput(KEY = "$1")');
                setStorageFromInputCommandCompletion.documentation = new vscode.MarkdownString('Schreibt ein übergebenen Parameter in den Storage, wenn ein Wert gesetzt wurde, ansonsten den angegebenen Default Wert');
                items.push(setStorageFromInputCommandCompletion);
                const setStorageValueCommandCompletion = new vscode.CompletionItem('setStorageValue');
                setStorageValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                setStorageValueCommandCompletion.insertText = new vscode.SnippetString('setStorageValue(TARGET_STORAGE_KEY = "$1")');
                setStorageValueCommandCompletion.documentation = new vscode.MarkdownString('Verändert den Wert einer Laufzeitvariable. ');
                items.push(setStorageValueCommandCompletion);
                const showCommandOverlayCommandCompletion = new vscode.CompletionItem('showCommandOverlay');
                showCommandOverlayCommandCompletion.kind = vscode.CompletionItemKind.Function;
                showCommandOverlayCommandCompletion.insertText = new vscode.SnippetString('showCommandOverlay()');
                showCommandOverlayCommandCompletion.documentation = new vscode.MarkdownString('Zeigt das Command-Overlay. ');
                items.push(showCommandOverlayCommandCompletion);
                const soapRequestCommandCompletion = new vscode.CompletionItem('soapRequest');
                soapRequestCommandCompletion.kind = vscode.CompletionItemKind.Function;
                soapRequestCommandCompletion.insertText = new vscode.SnippetString('soapRequest(URL = "$1", SOAP_ACTION = "$2")');
                soapRequestCommandCompletion.documentation = new vscode.MarkdownString('Ruft einen Web-Service auf und speichert das Ergebnis im Storage.');
                items.push(soapRequestCommandCompletion);
                const startActivityAndroidCommandCompletion = new vscode.CompletionItem('startActivityAndroid');
                startActivityAndroidCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startActivityAndroidCommandCompletion.insertText = new vscode.SnippetString('startActivityAndroid(PACKAGE_CONTAINING_APP = "$1", ACTIVITY_TO_START = "$2")');
                startActivityAndroidCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando startet eine neue Activity. ');
                items.push(startActivityAndroidCommandCompletion);
                const startAndroidCommandCompletion = new vscode.CompletionItem('startAndroid');
                startAndroidCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startAndroidCommandCompletion.insertText = new vscode.SnippetString('startAndroid(URL = "$1")');
                startAndroidCommandCompletion.documentation = new vscode.MarkdownString('Startet eine Applikation auf einem mobilen Gerät mit Betriebssystem Android (Beispiel: startAndroid("bestellbar.apk" , "de.garcon.bestellbar" , "CheckInActivity"), Beispiel2: startAndroid("bestellbar.apk" , "de.garcon.bestellbar" , ".CheckInActivity"), Beispiel3: startAndroid("bestellbar.apk" , "de.garcon.bestellbar" , "WaitActivity" , "", "", ") Plattform Besonderheiten: Android: Short Android Element Access Hintergrund: Um ein Android UI Element per ID zu finden, muss der voll qualifizierte Name angegeben werden (Package + ID). Wird ein Package beim Starten mit angegeben, so kann der vollqualifizierte Name ignoriert werden. Beispiel: Anstatt immer de.garcon.bestellbar:id/elementId zu schreiben, kann einfach "elementId" benutzt werden.');
                items.push(startAndroidCommandCompletion);
                const startAndroidWebCommandCompletion = new vscode.CompletionItem('startAndroidWeb');
                startAndroidWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startAndroidWebCommandCompletion.insertText = new vscode.SnippetString('startAndroidWeb(URL = "$1")');
                startAndroidWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando startet den Browser eines mobilen Geräts, auf dem das Betriebssystem Android installiert ist (Beispiel: startAndroidWeb("https://www.viadee.de/", "Device", "Keine Netzwerkverbindung")).');
                items.push(startAndroidWebCommandCompletion);
                const startApplicationCommandCompletion = new vscode.CompletionItem('startApplication');
                startApplicationCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startApplicationCommandCompletion.insertText = new vscode.SnippetString('startApplication(EXECUTABLE = "$1")');
                startApplicationCommandCompletion.documentation = new vscode.MarkdownString('Startet eine Anwendung.');
                items.push(startApplicationCommandCompletion);
                const startApplicationCPCommandCompletion = new vscode.CompletionItem('startApplicationCP');
                startApplicationCPCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startApplicationCPCommandCompletion.insertText = new vscode.SnippetString('startApplicationCP(WINDOW_NAME = "$1", SHELL_SCRIPT_PATH = "$2")');
                startApplicationCPCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando startet eine Applikation.');
                items.push(startApplicationCPCommandCompletion);
                const startApplicationWinCommandCompletion = new vscode.CompletionItem('startApplicationWin');
                startApplicationWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startApplicationWinCommandCompletion.insertText = new vscode.SnippetString('startApplicationWin(EXECUTABLE_PATH = "$1")');
                startApplicationWinCommandCompletion.documentation = new vscode.MarkdownString('Startet eine Applikation');
                items.push(startApplicationWinCommandCompletion);
                const startApplicationWinEleCommandCompletion = new vscode.CompletionItem('startApplicationWinEle');
                startApplicationWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startApplicationWinEleCommandCompletion.insertText = new vscode.SnippetString('startApplicationWinEle(EXPECTED_WINDOW_NAME = "$1", APPLICATION_PATH = "$2")');
                startApplicationWinEleCommandCompletion.documentation = new vscode.MarkdownString('Startet Windows-Applikation.');
                items.push(startApplicationWinEleCommandCompletion);
                const startIOSCommandCompletion = new vscode.CompletionItem('startIOS');
                startIOSCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startIOSCommandCompletion.insertText = new vscode.SnippetString('startIOS()');
                startIOSCommandCompletion.documentation = new vscode.MarkdownString('Startet eine Applikation auf einem mobilen Gerät mit Betriebssystem IOS (Beispiel: startIOS("./apps/bestellbar.app", "IOS", ""), startIOS("http://viadee.de/bestellbar.apk", "ANDROID", ""), startIOS("http://www.viadee.de", IOS_SAFARI, ""), startIOS("./apps/bestellbar.apk", "ANDROID" , "de.garcon.bestellbar"). Plattform Besonderheiten: Wird ein Package beim Starten mit angegeben, so kann der vollqualifizierte Name ignoriert werden (Beispiel: Anstatt immer de.garcon.bestellbar:id/elementId zu schreiben, kann einfach "elementId" benutzt werden).');
                items.push(startIOSCommandCompletion);
                const startIOSWebCommandCompletion = new vscode.CompletionItem('startIOSWeb');
                startIOSWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startIOSWebCommandCompletion.insertText = new vscode.SnippetString('startIOSWeb(URL = "$1")');
                startIOSWebCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando startet den Safari-Browser eines mobilen iOS-Geräts oder Simulator (Beispiel: startIOSWeb("www.viadee.de", "")).');
                items.push(startIOSWebCommandCompletion);
                const startSapDriverCommandCompletion = new vscode.CompletionItem('startSapDriver');
                startSapDriverCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startSapDriverCommandCompletion.insertText = new vscode.SnippetString('startSapDriver()');
                startSapDriverCommandCompletion.documentation = new vscode.MarkdownString('Startet den entsprechenden Treiber zum bedienen der Anwendung');
                items.push(startSapDriverCommandCompletion);
                const startScreenRecordingCommandCompletion = new vscode.CompletionItem('startScreenRecording');
                startScreenRecordingCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startScreenRecordingCommandCompletion.insertText = new vscode.SnippetString('startScreenRecording()');
                startScreenRecordingCommandCompletion.documentation = new vscode.MarkdownString('Startet die Bildschirmaufnahme. Falls dieses Kommando nach Aufruf eines startWeb-Kommando aufgerufen wird, durch das eine Browser-Instanz gestartet wurde, wird der Aufnahmebereich auf die Browser-Instanz beschränkt. Andernfalls wird der gesamte Bildschirm aufgenommen. Durch das "StopScreenRecording"-Kommando kann die aktuelle Aufnahme beendet werden. Erfolgt dieses Beenden nicht innerhalb des Scripts (z.B. durch unerwarteten Abbruch oder vergessenes "StopScreenRecording"-Kommando), wird nach Ablauf des Scripts alle 5 Sekunden überprüft, ob die Aufnahme noch aktiv ist, obwohl kein Script ausgeführt wird. Beginnt jedoch schon vorher ein neues Script, so kann es sein, dass die Aufnahme auch im neuen Script noch aktiv ist. Aus diesem Grund wird empfohlen, die Aufnahme durch das "StopScreenRecording"-Kommando explizit zu beenden.');
                items.push(startScreenRecordingCommandCompletion);
                const startWebCommandCompletion = new vscode.CompletionItem('startWeb');
                startWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startWebCommandCompletion.insertText = new vscode.SnippetString('startWeb(URL = "$1", BROWSER_NAME = "$2")');
                startWebCommandCompletion.documentation = new vscode.MarkdownString('Startet einen Web-Browser und öffnet eine angegebene Seite.');
                items.push(startWebCommandCompletion);
                const startWebRemoteCommandCompletion = new vscode.CompletionItem('startWebRemote');
                startWebRemoteCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startWebRemoteCommandCompletion.insertText = new vscode.SnippetString('startWebRemote(URL = "$1", BROWSER_NAME = "$2", REMOTE_WEB_DRIVER_SERVER_URL = "$3")');
                startWebRemoteCommandCompletion.documentation = new vscode.MarkdownString('Startet einen Web-Browser auf einem entfernten Rechner, der einen Selenium-RemoteWebDriverServer implementiert und öffnet dort eine angegebene Seite.    (siehe auch https://github.com/SeleniumHQ/selenium/wiki/RemoteWebDriverServer)');
                items.push(startWebRemoteCommandCompletion);
                const startsWithAlphaCommandCompletion = new vscode.CompletionItem('startsWithAlpha');
                startsWithAlphaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                startsWithAlphaCommandCompletion.insertText = new vscode.SnippetString('startsWithAlpha(TEXT = "$1", PREFIX = "$2")');
                startsWithAlphaCommandCompletion.documentation = new vscode.MarkdownString('Überprüft, ob ein Text mit einem angegebenen Teil-Text beginnt');
                items.push(startsWithAlphaCommandCompletion);
                const stopMobileCommandCompletion = new vscode.CompletionItem('stopMobile');
                stopMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                stopMobileCommandCompletion.insertText = new vscode.SnippetString('stopMobile()');
                stopMobileCommandCompletion.documentation = new vscode.MarkdownString('Beendet die Ausführung der Mobil-Application');
                items.push(stopMobileCommandCompletion);
                const stopSapDriverCommandCompletion = new vscode.CompletionItem('stopSapDriver');
                stopSapDriverCommandCompletion.kind = vscode.CompletionItemKind.Function;
                stopSapDriverCommandCompletion.insertText = new vscode.SnippetString('stopSapDriver()');
                stopSapDriverCommandCompletion.documentation = new vscode.MarkdownString('Stopt den entsprechenden Treiber');
                items.push(stopSapDriverCommandCompletion);
                const stopScreenRecordingCommandCompletion = new vscode.CompletionItem('stopScreenRecording');
                stopScreenRecordingCommandCompletion.kind = vscode.CompletionItemKind.Function;
                stopScreenRecordingCommandCompletion.insertText = new vscode.SnippetString('stopScreenRecording()');
                stopScreenRecordingCommandCompletion.documentation = new vscode.MarkdownString('Stoppt das Recording. ');
                items.push(stopScreenRecordingCommandCompletion);
                const stopWebCommandCompletion = new vscode.CompletionItem('stopWeb');
                stopWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                stopWebCommandCompletion.insertText = new vscode.SnippetString('stopWeb()');
                stopWebCommandCompletion.documentation = new vscode.MarkdownString('Beendet eine Web-Browser-Session.');
                items.push(stopWebCommandCompletion);
                const successCommandCompletion = new vscode.CompletionItem('success');
                successCommandCompletion.kind = vscode.CompletionItemKind.Function;
                successCommandCompletion.insertText = new vscode.SnippetString('success(MESSAGE = "$1")');
                successCommandCompletion.documentation = new vscode.MarkdownString('Erzeugt ein positives Ergebnis. Sofern an anderer Stelle ein Fehler vorliegt, wird dieser nicht(!) überschrieben. Das Kommando ist i.d.R. nur für Testzwecke sinnvoll.');
                items.push(successCommandCompletion);
                const swipeElementMobileCommandCompletion = new vscode.CompletionItem('swipeElementMobile');
                swipeElementMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                swipeElementMobileCommandCompletion.insertText = new vscode.SnippetString('swipeElementMobile(EXPRESSION_TEXT = "$1", GESTURE_DIRECTION = "$2")');
                swipeElementMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando führt eine Swipe-Geste über den kompletten Bildschirm aus, die an einem bestimmten Element startet. Dieses Kommando ist unabhängig von der Auflösung und Bildschirmgröße Ihres Testgerätes. Um die Richtung des Swipes anzugeben, gibt es folgende Optionen: LEFT_TO_RIGHT: Führt einen Swipe vom Element bis zum rechten Rand aus, RIGHT_TO_LEFT: Führt einen Swipe vom Element bis zum linken Rand aus, BOTTOM_TO_TOP: Führt einen Swipe vom Element bis zum oberen Rand aus, TOP_TO_BOTTOM: Führt einen Swipe vom Element bis zum unteren Rand aus. Zu der Bildschirmgröße wird ein Innenabstand berechnet, damit der Swipe Effekt nicht komplett am Rand, ausgeführt wird (dies kann zu Problemen führen). Bevor der Swipe Befehl ausgeführt wird, wird eine Sekunde gewartet. Beispiel: Bei einer Größe von 1080x1900 Pixel wird bei einem Swipe von Rechts nach Links folgende Pixelwerte berechnet: Pixelwerte:     XStart: 1070     YStart: 950     XEnd: 10     YEnd: 950 (Beispiel: SwipeElementMobile("name", "Auflegen-Knopf", "RIGHT_TO_LEFT", "500", "500")).');
                items.push(swipeElementMobileCommandCompletion);
                const swipeMobileCommandCompletion = new vscode.CompletionItem('swipeMobile');
                swipeMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                swipeMobileCommandCompletion.insertText = new vscode.SnippetString('swipeMobile(X_START_SWIPE = "$1", Y_START_SWIPE = "$2", X_END_SWIPE = "$3", Y_END_SWIPE = "$4")');
                swipeMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando führt eine Swipe-Geste auf dem Bildschirm aus (Beispiel: swipeMobile("1000","1000", "1500", "1000", "500")). Warnung: Es sollte immer vermieden werden, Befehle auf dem Screen auszuführen, da Pixel angaben Device- und Auflösungsabhängig sind.');
                items.push(swipeMobileCommandCompletion);
                const swipeScreenMobileCommandCompletion = new vscode.CompletionItem('swipeScreenMobile');
                swipeScreenMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                swipeScreenMobileCommandCompletion.insertText = new vscode.SnippetString('swipeScreenMobile(GESTURE_DIRECTION = "$1")');
                swipeScreenMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando führt eine Swipe-Geste über den kompletten Bildschirm aus und soll eine Vereinfachung des normalen Swipes sein. Dieses Kommando ist unabhängig von der Auflösung und Bildschirmgröße Ihres Testgerätes. Um die Richtung des Swipes anzugeben, gibt es folgende Optionen: LEFT_TO_RIGHT: Führt einen Swipe vom linken Rand bis zum rechten Rand aus, RIGHT_TO_LEFT: Führt einen Swipe vom rechten Rand bis zum linken Rand aus, BOTTOM_TO_TOP: Führt einen Swipe vom unteren Rand bis zum oberen Rand aus, TOP_TO_BOTTOM: Führt einen Swipe vom oberen Rand bis zum unteren Rand aus. Zu der Bildschirmgröße wird ein Innenabstand berechnet, damit der Swipe Effekt nicht komplett am Rand ausgeführt wird (dies kann zu Problemen führen). Bevor der Swipe Befehl ausgeführt wird, wird eine Sekunde gewartet. Beispiel: Bei einer Größe von 1080x1900 Pixel wird bei einem Swipe von Rechts nach Links folgende Pixelwerte berechnet: Pixelwerte:     XStart: 1070     YStart: 950     XEnd: 10     YEnd: 950 (Beispiel: SwipeScreenMobile("RIGHT_TO_LEFT", "500")).');
                items.push(swipeScreenMobileCommandCompletion);
                const switchContextMobileCommandCompletion = new vscode.CompletionItem('switchContextMobile');
                switchContextMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                switchContextMobileCommandCompletion.insertText = new vscode.SnippetString('switchContextMobile()');
                switchContextMobileCommandCompletion.documentation = new vscode.MarkdownString('Wechselt den Context des Treibers, anschließend können beispielsweise spezifische Webview Ausdrücke wie XPATH: \\div\li[...] genutzt werden (Beispiel: switchContextMobile("WEBVIEW")).');
                items.push(switchContextMobileCommandCompletion);
                const switchDriverCommandCompletion = new vscode.CompletionItem('switchDriver');
                switchDriverCommandCompletion.kind = vscode.CompletionItemKind.Function;
                switchDriverCommandCompletion.insertText = new vscode.SnippetString('switchDriver(BROWSER_ABBREVIATION = "$1")');
                switchDriverCommandCompletion.documentation = new vscode.MarkdownString('Wechselt vom aktuell gesteuerten zu einem anderen Web-Driver, der ebenfalls zuvor mit startWeb gestartet wurde, um nunmehr diesen zu steuern.     Wird startWeb zweimal für denselben Browser aufgerufen, ohne dass dieser Browser in der Zwischenzeit mit stopWeb beendet wird,     wird beim zweiten Mal kein neues Browser-Fenster geöffnet.     Für dieses Kommando ist es daher zwingend erforderlich, dass mit BROWSER_ABBREVIATION einen anderen Browser handelt.');
                items.push(switchDriverCommandCompletion);
                const switchFrameMobileCommandCompletion = new vscode.CompletionItem('switchFrameMobile');
                switchFrameMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                switchFrameMobileCommandCompletion.insertText = new vscode.SnippetString('switchFrameMobile(EXPRESSION_TEXT = "$1")');
                switchFrameMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando wechselt den Frame des Browsers.');
                items.push(switchFrameMobileCommandCompletion);
                const switchFrameWebCommandCompletion = new vscode.CompletionItem('switchFrameWeb');
                switchFrameWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                switchFrameWebCommandCompletion.insertText = new vscode.SnippetString('switchFrameWeb(ELEMENT_NAME = "$1")');
                switchFrameWebCommandCompletion.documentation = new vscode.MarkdownString('Dieses Kommando wechselt innerhalb einer Seite ein Frame.  Der Framewechsel ist also eine dauerhafte Einstellung, solange der Frame nicht gewechselt wird oder zum Standard zurückgesetzt wird.   Es wird ebenfalls der INDEX des Frame unterstützt.  Um in den Hauptframe zurück zu wechseln ist es notwendig, als Ziel #default# anzugeben.Alternativ zu diesem Kommando kann auch mit dem Laufzeitparameter "searchAcrossFrames" gearbeitet werden (siehe Anwenderdokumentation), bei dem ein manuelles wechseln des Frames nicht länger notwendig ist.');
                items.push(switchFrameWebCommandCompletion);
                const switchWindowWebCommandCompletion = new vscode.CompletionItem('switchWindowWeb');
                switchWindowWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                switchWindowWebCommandCompletion.insertText = new vscode.SnippetString('switchWindowWeb()');
                switchWindowWebCommandCompletion.documentation = new vscode.MarkdownString('Kommando um innerhalb eines Browsers das Fenster bzw. Tab zu wechseln und das aktuelle Fenster bei Bedarf vorher zu schließen. Dieses Kommando muss auch dann aufgerufen werden, wenn ein Tab über einen Browserlink geöffnet wird und das sichtbare Browserfenster automatisch in das neue Tab wechselt. Andernfalls versucht der WebDriver weiterhin, Kommandos im ursprünglichen Tab auszuführen.      Das Ziel-Fenster muss für den aktuell genutzten Web-Treiber erreichbar sein. Es kann maximal ein Web-Treiber pro Browseranwendung (Chrome, Firefox,...) gleichzeitig aktiv sein.     Wird das Ziel-Fenster durch einen anderen Web-Treiber gesteuert als den aktuellen     (befindet sich also z.B. in einer Firefox-Instanz, während der aktuelle Treiber Chrome steuert), ist vorher mit switchDriver der Web-Treiber zu wechseln.');
                items.push(switchWindowWebCommandCompletion);
                const takeScreenshotCommandCompletion = new vscode.CompletionItem('takeScreenshot');
                takeScreenshotCommandCompletion.kind = vscode.CompletionItemKind.Function;
                takeScreenshotCommandCompletion.insertText = new vscode.SnippetString('takeScreenshot()');
                takeScreenshotCommandCompletion.documentation = new vscode.MarkdownString('Erzeugt einen Screenshot. Wenn WINDOW_NAME leer ist, wird der gesamte Bildschirm fotografiert.');
                items.push(takeScreenshotCommandCompletion);
                const takeScreenshotElementWebCommandCompletion = new vscode.CompletionItem('takeScreenshotElementWeb');
                takeScreenshotElementWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                takeScreenshotElementWebCommandCompletion.insertText = new vscode.SnippetString('takeScreenshotElementWeb()');
                takeScreenshotElementWebCommandCompletion.documentation = new vscode.MarkdownString('Erstellt einen Screenshot eines bestimmten WebElement auf der aktuellen Webseite.');
                items.push(takeScreenshotElementWebCommandCompletion);
                const takeScreenshotFullWebCommandCompletion = new vscode.CompletionItem('takeScreenshotFullWeb');
                takeScreenshotFullWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                takeScreenshotFullWebCommandCompletion.insertText = new vscode.SnippetString('takeScreenshotFullWeb()');
                takeScreenshotFullWebCommandCompletion.documentation = new vscode.MarkdownString('Erstellt einen Screenshot der gesamten Webseite. Scrollt dazu einmal von oben nach unten und wieder zurück an den Ausgangspunkt. Details zur Bedienung sind im Handbuch beschrieben.');
                items.push(takeScreenshotFullWebCommandCompletion);
                const takeScreenshotWebCommandCompletion = new vscode.CompletionItem('takeScreenshotWeb');
                takeScreenshotWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                takeScreenshotWebCommandCompletion.insertText = new vscode.SnippetString('takeScreenshotWeb()');
                takeScreenshotWebCommandCompletion.documentation = new vscode.MarkdownString('Erstellt einen Screenshot von der Webseite.');
                items.push(takeScreenshotWebCommandCompletion);
                const tapMobileCommandCompletion = new vscode.CompletionItem('tapMobile');
                tapMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                tapMobileCommandCompletion.insertText = new vscode.SnippetString('tapMobile(EXPRESSION_TEXT = "$1")');
                tapMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando klickt auf ein Element anhand eines Kriteriums, nachdem es gefunden wurde (Beispiel: tapMobile("name", "Ok-Knopf", "", "10")).');
                items.push(tapMobileCommandCompletion);
                const tapPositionMobileCommandCompletion = new vscode.CompletionItem('tapPositionMobile');
                tapPositionMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                tapPositionMobileCommandCompletion.insertText = new vscode.SnippetString('tapPositionMobile(X = "$1", Y = "$2")');
                tapPositionMobileCommandCompletion.documentation = new vscode.MarkdownString('Klickt auf einen Punkt anhand seiner Koordinaten (Beispiel: tapPositionMobile("1000", "1000")). Warnung: Es sollte nach Möglichkeit immer vermieden werden, Befehle auf dem Screen auszuführen, da Pixelangaben Device- und Auflösungsabhängig sind.');
                items.push(tapPositionMobileCommandCompletion);
                const thenCommandCompletion = new vscode.CompletionItem('then');
                thenCommandCompletion.kind = vscode.CompletionItemKind.Function;
                thenCommandCompletion.insertText = new vscode.SnippetString('then:');
                thenCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(thenCommandCompletion);
                const timeoutCommandCompletion = new vscode.CompletionItem('timeout');
                timeoutCommandCompletion.kind = vscode.CompletionItemKind.Function;
                timeoutCommandCompletion.insertText = new vscode.SnippetString('timeout(MESSAGE = "$1")');
                timeoutCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando erzeugt einen Timeout-Status. (Achtung: Der Timeout-Status gilt dann nur für das Kommando, nicht für das gesamte Testset!)');
                items.push(timeoutCommandCompletion);
                const touchMobileCommandCompletion = new vscode.CompletionItem('touchMobile');
                touchMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                touchMobileCommandCompletion.insertText = new vscode.SnippetString('touchMobile(X_POSITION = "$1", Y_POSITION = "$2")');
                touchMobileCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando berüht einen Punkt auf dem Bildschirm (Beispiel: touchMobile("1","1000", "1000", "", "500")). Warnung: Es sollte immer vermieden werden, Befehle auf dem Screen auszuführen, da Pixel angaben Device- und Auflösungsabhängig sind.');
                items.push(touchMobileCommandCompletion);
                const uiActionCommandCompletion = new vscode.CompletionItem('uiAction');
                uiActionCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiActionCommandCompletion.insertText = new vscode.SnippetString('uiAction(UIA_SELECTOR = "$1", ACTION = "$2")');
                uiActionCommandCompletion.documentation = new vscode.MarkdownString('Wrapper Kommando für den UIA Treiber.');
                items.push(uiActionCommandCompletion);
                const uiClickCommandCompletion = new vscode.CompletionItem('uiClick');
                uiClickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiClickCommandCompletion.insertText = new vscode.SnippetString('uiClick(UIA_SELECTOR = "$1")');
                uiClickCommandCompletion.documentation = new vscode.MarkdownString('Führt einen Mausklick auf ein bestimmtes Element in einem Fenster aus');
                items.push(uiClickCommandCompletion);
                const uiDoubleclickCommandCompletion = new vscode.CompletionItem('uiDoubleclick');
                uiDoubleclickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiDoubleclickCommandCompletion.insertText = new vscode.SnippetString('uiDoubleclick(UIA_SELECTOR = "$1")');
                uiDoubleclickCommandCompletion.documentation = new vscode.MarkdownString('Führt einen Doppelklick auf ein bestimmtes Element in einem Fenster aus');
                items.push(uiDoubleclickCommandCompletion);
                const uiGetPropertyCommandCompletion = new vscode.CompletionItem('uiGetProperty');
                uiGetPropertyCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiGetPropertyCommandCompletion.insertText = new vscode.SnippetString('uiGetProperty(UIA_SELECTOR = "$1", PROPERTYNAME = "$2")');
                uiGetPropertyCommandCompletion.documentation = new vscode.MarkdownString('Liefert die Property von einem Element in einem Fenster');
                items.push(uiGetPropertyCommandCompletion);
                const uiGetValueCommandCompletion = new vscode.CompletionItem('uiGetValue');
                uiGetValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiGetValueCommandCompletion.insertText = new vscode.SnippetString('uiGetValue(UIA_SELECTOR = "$1")');
                uiGetValueCommandCompletion.documentation = new vscode.MarkdownString('Liefert einen Wert von einem Element in einem Fenster');
                items.push(uiGetValueCommandCompletion);
                const uiMoveCommandCompletion = new vscode.CompletionItem('uiMove');
                uiMoveCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiMoveCommandCompletion.insertText = new vscode.SnippetString('uiMove(WINDOW_NAME = "$1", UIA_SELECTOR = "$2", X = "$3", Y = "$4")');
                uiMoveCommandCompletion.documentation = new vscode.MarkdownString('Verschiebt ein Fenster.');
                items.push(uiMoveCommandCompletion);
                const uiMoveMouseCommandCompletion = new vscode.CompletionItem('uiMoveMouse');
                uiMoveMouseCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiMoveMouseCommandCompletion.insertText = new vscode.SnippetString('uiMoveMouse(UIA_SELECTOR = "$1", X = "$2", Y = "$3")');
                uiMoveMouseCommandCompletion.documentation = new vscode.MarkdownString('Bewegt den Mauszeiger innerhalb eines angegebenen Elements');
                items.push(uiMoveMouseCommandCompletion);
                const uiRightclickCommandCompletion = new vscode.CompletionItem('uiRightclick');
                uiRightclickCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiRightclickCommandCompletion.insertText = new vscode.SnippetString('uiRightclick(UIA_SELECTOR = "$1")');
                uiRightclickCommandCompletion.documentation = new vscode.MarkdownString('Führt einen Rechtsklick auf ein bestimmtes Element in einem Fenster aus');
                items.push(uiRightclickCommandCompletion);
                const uiSendCommandCompletion = new vscode.CompletionItem('uiSend');
                uiSendCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiSendCommandCompletion.insertText = new vscode.SnippetString('uiSend(UIA_SELECTOR = "$1")');
                uiSendCommandCompletion.documentation = new vscode.MarkdownString('Schickt eine Tastenfolge an ein Element.');
                items.push(uiSendCommandCompletion);
                const uiSetValueCommandCompletion = new vscode.CompletionItem('uiSetValue');
                uiSetValueCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiSetValueCommandCompletion.insertText = new vscode.SnippetString('uiSetValue(UIA_SELECTOR = "$1")');
                uiSetValueCommandCompletion.documentation = new vscode.MarkdownString('Setzt einen Wert in einem Element.');
                items.push(uiSetValueCommandCompletion);
                const uiWaitForCommandCompletion = new vscode.CompletionItem('uiWaitFor');
                uiWaitForCommandCompletion.kind = vscode.CompletionItemKind.Function;
                uiWaitForCommandCompletion.insertText = new vscode.SnippetString('uiWaitFor(UIA_SELECTOR = "$1")');
                uiWaitForCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf ein Element.');
                items.push(uiWaitForCommandCompletion);
                const verifyNameByAutomationIdWinEleCommandCompletion = new vscode.CompletionItem('verifyNameByAutomationIdWinEle');
                verifyNameByAutomationIdWinEleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                verifyNameByAutomationIdWinEleCommandCompletion.insertText = new vscode.SnippetString('verifyNameByAutomationIdWinEle(WINDOW_NAME = "$1", PROCESS_NAME = "$2", AUTOMATION_ID = "$3", ELEMENT_NAME = "$4")');
                verifyNameByAutomationIdWinEleCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando überprüft den Namen eines Elements. Dabei kann es sich bei Eingabe-Elementen auch um deren Inhalt handeln.');
                items.push(verifyNameByAutomationIdWinEleCommandCompletion);
                const waitCommandCompletion = new vscode.CompletionItem('wait');
                waitCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitCommandCompletion.insertText = new vscode.SnippetString('wait(WAIT_MILLISECONDS = "$1")');
                waitCommandCompletion.documentation = new vscode.MarkdownString('Wartet die angegebene Zeit in Millisekunden.');
                items.push(waitCommandCompletion);
                const waitForAjaxCommandCompletion = new vscode.CompletionItem('waitForAjax');
                waitForAjaxCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForAjaxCommandCompletion.insertText = new vscode.SnippetString('waitForAjax()');
                waitForAjaxCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando überprüft, ob Ajax-Kommunikation stattfindet.     Ist dies der Fall, wartet es maximal WAIT_SECONDS Sekunden bis keine Ajax-Kommunikation mehr stattfindet.');
                items.push(waitForAjaxCommandCompletion);
                const waitForElementNotVisibleWebCommandCompletion = new vscode.CompletionItem('waitForElementNotVisibleWeb');
                waitForElementNotVisibleWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForElementNotVisibleWebCommandCompletion.insertText = new vscode.SnippetString('waitForElementNotVisibleWeb(ELEMENT_NAME = "$1")');
                waitForElementNotVisibleWebCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf das Verschwinden eines Web-Element.');
                items.push(waitForElementNotVisibleWebCommandCompletion);
                const waitForElementVisibleWebCommandCompletion = new vscode.CompletionItem('waitForElementVisibleWeb');
                waitForElementVisibleWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForElementVisibleWebCommandCompletion.insertText = new vscode.SnippetString('waitForElementVisibleWeb(ELEMENT_NAME = "$1")');
                waitForElementVisibleWebCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf ein Web-Element bis es sichtbar ist. Sichtbar bedeutet, dass das Element verfügbar ist und eine Höhe und Breite von mehr als 0 hat.');
                items.push(waitForElementVisibleWebCommandCompletion);
                const waitForElementWebCommandCompletion = new vscode.CompletionItem('waitForElementWeb');
                waitForElementWebCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForElementWebCommandCompletion.insertText = new vscode.SnippetString('waitForElementWeb(ELEMENT_NAME = "$1")');
                waitForElementWebCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf ein Web-Element bis es anklickbar ist.');
                items.push(waitForElementWebCommandCompletion);
                const waitForElementWebVisibleCommandCompletion = new vscode.CompletionItem('waitForElementWebVisible');
                waitForElementWebVisibleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForElementWebVisibleCommandCompletion.insertText = new vscode.SnippetString('waitForElementWebVisible(ELEMENT_NAME = "$1")');
                waitForElementWebVisibleCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf ein Web-Element bis es sichtbar ist. Sichtbar bedeutet, dass das Element verfügbar ist und eine Höhe und Breite von mehr als 0 hat.');
                items.push(waitForElementWebVisibleCommandCompletion);
                const waitForFileNotExistsCommandCompletion = new vscode.CompletionItem('waitForFileNotExists');
                waitForFileNotExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForFileNotExistsCommandCompletion.insertText = new vscode.SnippetString('waitForFileNotExists(FILENAME = "$1")');
                waitForFileNotExistsCommandCompletion.documentation = new vscode.MarkdownString('Sucht nach einer Datei und schließt mit dem Status "Erfolg" ab, falls diese nicht gefunden wurde.    Das Kommando lässt sich in Bedingungen einsetzen, um Prozesse zu steuern.');
                items.push(waitForFileNotExistsCommandCompletion);
                const waitForImageCommandCompletion = new vscode.CompletionItem('waitForImage');
                waitForImageCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForImageCommandCompletion.insertText = new vscode.SnippetString('waitForImage(IMAGE_PATH = "$1", SECONDS = "$2")');
                waitForImageCommandCompletion.documentation = new vscode.MarkdownString('Sucht die Position eines Bilds');
                items.push(waitForImageCommandCompletion);
                const waitForJavaCommandCompletion = new vscode.CompletionItem('waitForJava');
                waitForJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForJavaCommandCompletion.insertText = new vscode.SnippetString('waitForJava(TARGET = "$1")');
                waitForJavaCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf eine Java Component, dass sie erscheint.');
                items.push(waitForJavaCommandCompletion);
                const waitForPictureToDisappearWinCommandCompletion = new vscode.CompletionItem('waitForPictureToDisappearWin');
                waitForPictureToDisappearWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForPictureToDisappearWinCommandCompletion.insertText = new vscode.SnippetString('waitForPictureToDisappearWin(WINDOW_NAME = "$1", RELATIVE_PATH_IMAGE = "$2")');
                waitForPictureToDisappearWinCommandCompletion.documentation = new vscode.MarkdownString('Wartet, bis ein Bild in einem Fenster nicht mehr vorhanden ist.');
                items.push(waitForPictureToDisappearWinCommandCompletion);
                const waitForPictureWinCommandCompletion = new vscode.CompletionItem('waitForPictureWin');
                waitForPictureWinCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForPictureWinCommandCompletion.insertText = new vscode.SnippetString('waitForPictureWin(WINDOW_NAME = "$1", RELATIVE_PATH_IMAGE = "$2")');
                waitForPictureWinCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf ein Bild innerhalb eines Festers');
                items.push(waitForPictureWinCommandCompletion);
                const waitForTextJavaCommandCompletion = new vscode.CompletionItem('waitForTextJava');
                waitForTextJavaCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitForTextJavaCommandCompletion.insertText = new vscode.SnippetString('waitForTextJava(TEXT = "$1")');
                waitForTextJavaCommandCompletion.documentation = new vscode.MarkdownString('Wartet auf die Anzeige eines Text-Components');
                items.push(waitForTextJavaCommandCompletion);
                const waitMobileCommandCompletion = new vscode.CompletionItem('waitMobile');
                waitMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                waitMobileCommandCompletion.insertText = new vscode.SnippetString('waitMobile()');
                waitMobileCommandCompletion.documentation = new vscode.MarkdownString('Der Befehl wartet auf die Verfügbarkeit eines Elements anhand eines Kriteriums oder einen definierten Zeitraum, falls keine Expression angeben wurde (Beispiel: waitMobile("name", "Ok-Knopf", "", "10")).');
                items.push(waitMobileCommandCompletion);
                const warningCommandCompletion = new vscode.CompletionItem('warning');
                warningCommandCompletion.kind = vscode.CompletionItemKind.Function;
                warningCommandCompletion.insertText = new vscode.SnippetString('warning(MESSAGE = "$1")');
                warningCommandCompletion.documentation = new vscode.MarkdownString('Das Kommando erzeugt eine Warnung.');
                items.push(warningCommandCompletion);
                const whenCommandCompletion = new vscode.CompletionItem('when');
                whenCommandCompletion.kind = vscode.CompletionItemKind.Function;
                whenCommandCompletion.insertText = new vscode.SnippetString('when()');
                whenCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(whenCommandCompletion);
                const whileCommandCompletion = new vscode.CompletionItem('while');
                whileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                whileCommandCompletion.insertText = new vscode.SnippetString('while(MAX_ITERATIONS = "$1"):');
                whileCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(whileCommandCompletion);
                const whileNotCommandCompletion = new vscode.CompletionItem('whileNot');
                whileNotCommandCompletion.kind = vscode.CompletionItemKind.Function;
                whileNotCommandCompletion.insertText = new vscode.SnippetString('whileNot(MAX_ITERATIONS = "$1"):');
                whileNotCommandCompletion.documentation = new vscode.MarkdownString('Wird zur Steuerung des Kontrollflusses verwendet');
                items.push(whileNotCommandCompletion);
                const winActivateCommandCompletion = new vscode.CompletionItem('winActivate');
                winActivateCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winActivateCommandCompletion.insertText = new vscode.SnippetString('winActivate(TITLE = "$1")');
                winActivateCommandCompletion.documentation = new vscode.MarkdownString('Aktiviert eine Anwendung, holt sie in den Vordergrund.');
                items.push(winActivateCommandCompletion);
                const winCheckIfFileExistsCommandCompletion = new vscode.CompletionItem('winCheckIfFileExists');
                winCheckIfFileExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winCheckIfFileExistsCommandCompletion.insertText = new vscode.SnippetString('winCheckIfFileExists(FILENAME = "$1")');
                winCheckIfFileExistsCommandCompletion.documentation = new vscode.MarkdownString('Überprüft ob eine Datei existiert.');
                items.push(winCheckIfFileExistsCommandCompletion);
                const winExistsCommandCompletion = new vscode.CompletionItem('winExists');
                winExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winExistsCommandCompletion.insertText = new vscode.SnippetString('winExists(TITLE = "$1")');
                winExistsCommandCompletion.documentation = new vscode.MarkdownString('Prüft ob ein Fenster existiert.');
                items.push(winExistsCommandCompletion);
                const winGetActiveWindowTitleCommandCompletion = new vscode.CompletionItem('winGetActiveWindowTitle');
                winGetActiveWindowTitleCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winGetActiveWindowTitleCommandCompletion.insertText = new vscode.SnippetString('winGetActiveWindowTitle()');
                winGetActiveWindowTitleCommandCompletion.documentation = new vscode.MarkdownString('Liefert den Titel des aktiven Fensters.');
                items.push(winGetActiveWindowTitleCommandCompletion);
                const winGetAllWindowsTitlesCommandCompletion = new vscode.CompletionItem('winGetAllWindowsTitles');
                winGetAllWindowsTitlesCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winGetAllWindowsTitlesCommandCompletion.insertText = new vscode.SnippetString('winGetAllWindowsTitles()');
                winGetAllWindowsTitlesCommandCompletion.documentation = new vscode.MarkdownString('Liefert die Titel aller geöffneten Fenster.');
                items.push(winGetAllWindowsTitlesCommandCompletion);
                const winGetControlinfoAtPositionCommandCompletion = new vscode.CompletionItem('winGetControlinfoAtPosition');
                winGetControlinfoAtPositionCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winGetControlinfoAtPositionCommandCompletion.insertText = new vscode.SnippetString('winGetControlinfoAtPosition(WINDOW_NAME = "$1", CONTROL = "$2", MOUSE_X = "$3", MOUSE_Y = "$4")');
                winGetControlinfoAtPositionCommandCompletion.documentation = new vscode.MarkdownString('Gibt die Info von einem Control an einer bestimmten Position.');
                items.push(winGetControlinfoAtPositionCommandCompletion);
                const winGetTextCommandCompletion = new vscode.CompletionItem('winGetText');
                winGetTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winGetTextCommandCompletion.insertText = new vscode.SnippetString('winGetText(TITLE = "$1")');
                winGetTextCommandCompletion.documentation = new vscode.MarkdownString('Liest den Text eines Fensters aus.');
                items.push(winGetTextCommandCompletion);
                const winGetWindowTextCommandCompletion = new vscode.CompletionItem('winGetWindowText');
                winGetWindowTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winGetWindowTextCommandCompletion.insertText = new vscode.SnippetString('winGetWindowText(WINDOW_NAME = "$1")');
                winGetWindowTextCommandCompletion.documentation = new vscode.MarkdownString('Liefert den Text eines bestimmten Fensters.');
                items.push(winGetWindowTextCommandCompletion);
                const winMouseClickCursorFensterCommandCompletion = new vscode.CompletionItem('winMouseClickCursorFenster');
                winMouseClickCursorFensterCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winMouseClickCursorFensterCommandCompletion.insertText = new vscode.SnippetString('winMouseClickCursorFenster(WINDOW_NAME = "$1", MOUSE_BUTTON = "$2")');
                winMouseClickCursorFensterCommandCompletion.documentation = new vscode.MarkdownString('Führt einen Mausklick auf einem bestimmten Fenster durch.');
                items.push(winMouseClickCursorFensterCommandCompletion);
                const winMouseClickXYCommandCompletion = new vscode.CompletionItem('winMouseClickXY');
                winMouseClickXYCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winMouseClickXYCommandCompletion.insertText = new vscode.SnippetString('winMouseClickXY(X = "$1", Y = "$2", MOUSE_BUTTON = "$3")');
                winMouseClickXYCommandCompletion.documentation = new vscode.MarkdownString('Führt einen Mausklick an einer bestimmten Position durch.');
                items.push(winMouseClickXYCommandCompletion);
                const winMouseClickXYFensterCommandCompletion = new vscode.CompletionItem('winMouseClickXYFenster');
                winMouseClickXYFensterCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winMouseClickXYFensterCommandCompletion.insertText = new vscode.SnippetString('winMouseClickXYFenster(WINDOW_NAME = "$1", X = "$2", Y = "$3", MOUSE_BUTTON = "$4")');
                winMouseClickXYFensterCommandCompletion.documentation = new vscode.MarkdownString('Führt einen Mausklick an einer bestimmten Position in einem Fenster durch.');
                items.push(winMouseClickXYFensterCommandCompletion);
                const winMouseDoubleClickXYFensterCommandCompletion = new vscode.CompletionItem('winMouseDoubleClickXYFenster');
                winMouseDoubleClickXYFensterCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winMouseDoubleClickXYFensterCommandCompletion.insertText = new vscode.SnippetString('winMouseDoubleClickXYFenster(WINDOW_NAME = "$1", X = "$2", Y = "$3")');
                winMouseDoubleClickXYFensterCommandCompletion.documentation = new vscode.MarkdownString('Führt einen Doppelklick an einer bestimmten Position in einem Fenster durch.');
                items.push(winMouseDoubleClickXYFensterCommandCompletion);
                const winMouseOn00CommandCompletion = new vscode.CompletionItem('winMouseOn00');
                winMouseOn00CommandCompletion.kind = vscode.CompletionItemKind.Function;
                winMouseOn00CommandCompletion.insertText = new vscode.SnippetString('winMouseOn00()');
                winMouseOn00CommandCompletion.documentation = new vscode.MarkdownString('Bewegt die Maus zur Position 0|0.');
                items.push(winMouseOn00CommandCompletion);
                const winOpenFileWithNotepadCommandCompletion = new vscode.CompletionItem('winOpenFileWithNotepad');
                winOpenFileWithNotepadCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winOpenFileWithNotepadCommandCompletion.insertText = new vscode.SnippetString('winOpenFileWithNotepad(FILENAME = "$1")');
                winOpenFileWithNotepadCommandCompletion.documentation = new vscode.MarkdownString('Öffnet eine vorhandene Datei mit dem Notepad');
                items.push(winOpenFileWithNotepadCommandCompletion);
                const winScrollMouseWheelCommandCompletion = new vscode.CompletionItem('winScrollMouseWheel');
                winScrollMouseWheelCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winScrollMouseWheelCommandCompletion.insertText = new vscode.SnippetString('winScrollMouseWheel(WHEEL_DIRECTION = "$1", NUMBER_OF_WHEEL_TURNS = "$2")');
                winScrollMouseWheelCommandCompletion.documentation = new vscode.MarkdownString('Scrollt das Mausrad in eine bestimmte Richtung.');
                items.push(winScrollMouseWheelCommandCompletion);
                const winSendCommandCompletion = new vscode.CompletionItem('winSend');
                winSendCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winSendCommandCompletion.insertText = new vscode.SnippetString('winSend()');
                winSendCommandCompletion.documentation = new vscode.MarkdownString('Schickt eine Tastenfolge.');
                items.push(winSendCommandCompletion);
                const winSendTextByPasteCommandCompletion = new vscode.CompletionItem('winSendTextByPaste');
                winSendTextByPasteCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winSendTextByPasteCommandCompletion.insertText = new vscode.SnippetString('winSendTextByPaste()');
                winSendTextByPasteCommandCompletion.documentation = new vscode.MarkdownString('Sendet eine Zeichenfolge die im Zwischenspeicher hinterlegt ist.');
                items.push(winSendTextByPasteCommandCompletion);
                const winSendWindowCommandCompletion = new vscode.CompletionItem('winSendWindow');
                winSendWindowCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winSendWindowCommandCompletion.insertText = new vscode.SnippetString('winSendWindow(WINDOW_NAME = "$1")');
                winSendWindowCommandCompletion.documentation = new vscode.MarkdownString('Schickt eine Tastenfolge an ein Fenster.');
                items.push(winSendWindowCommandCompletion);
                const winStatusbarTextCommandCompletion = new vscode.CompletionItem('winStatusbarText');
                winStatusbarTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winStatusbarTextCommandCompletion.insertText = new vscode.SnippetString('winStatusbarText(WINDOW_NAME = "$1")');
                winStatusbarTextCommandCompletion.documentation = new vscode.MarkdownString('Liefert die Statusbar eines Fensters.');
                items.push(winStatusbarTextCommandCompletion);
                const winWaitCommandCompletion = new vscode.CompletionItem('winWait');
                winWaitCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winWaitCommandCompletion.insertText = new vscode.SnippetString('winWait(TITLE = "$1", TIMEOUT_IN_SECONDS = "$2")');
                winWaitCommandCompletion.documentation = new vscode.MarkdownString('Prüft ob ein Fenster existiert. Es muss nicht aktiv sein.');
                items.push(winWaitCommandCompletion);
                const winWaitActiveCommandCompletion = new vscode.CompletionItem('winWaitActive');
                winWaitActiveCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winWaitActiveCommandCompletion.insertText = new vscode.SnippetString('winWaitActive(TITLE = "$1", TIMEOUT_IN_SECONDS = "$2")');
                winWaitActiveCommandCompletion.documentation = new vscode.MarkdownString('Prüft ob ein Fenster existiert.');
                items.push(winWaitActiveCommandCompletion);
                const winWaitForWindowExistsCommandCompletion = new vscode.CompletionItem('winWaitForWindowExists');
                winWaitForWindowExistsCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winWaitForWindowExistsCommandCompletion.insertText = new vscode.SnippetString('winWaitForWindowExists(WINDOW_NAME = "$1", MATCH_MODE = "$2")');
                winWaitForWindowExistsCommandCompletion.documentation = new vscode.MarkdownString('Wartet bis ein bestimmtes Fenster existiert.');
                items.push(winWaitForWindowExistsCommandCompletion);
                const winWaitForWindowTextCommandCompletion = new vscode.CompletionItem('winWaitForWindowText');
                winWaitForWindowTextCommandCompletion.kind = vscode.CompletionItemKind.Function;
                winWaitForWindowTextCommandCompletion.insertText = new vscode.SnippetString('winWaitForWindowText(WINDOW_NAME = "$1", TEXT = "$2")');
                winWaitForWindowTextCommandCompletion.documentation = new vscode.MarkdownString('Wartet bis ein bestimmter Text in einem Fenster existiert.');
                items.push(winWaitForWindowTextCommandCompletion);
                const writePropertiesToStorageCommandCompletion = new vscode.CompletionItem('writePropertiesToStorage');
                writePropertiesToStorageCommandCompletion.kind = vscode.CompletionItemKind.Function;
                writePropertiesToStorageCommandCompletion.insertText = new vscode.SnippetString('writePropertiesToStorage()');
                writePropertiesToStorageCommandCompletion.documentation = new vscode.MarkdownString('Schreibt die Laufzeit-Properties in die Storage-Datei. Dabei wird vor die Keys aller herausgeschriebenen Properties das Prefix "runtime_property\:" gesetzt. Bereits bestehende Einträge mit diesem Präfix werden zuvor gelöscht, sodass nach Ausführung nur die aktuell gesetzten Parameterwerte in der Storag-Datei enthalten sind.');
                items.push(writePropertiesToStorageCommandCompletion);
                const writeToFileCommandCompletion = new vscode.CompletionItem('writeToFile');
                writeToFileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                writeToFileCommandCompletion.insertText = new vscode.SnippetString('writeToFile(VALUE = "$1", FILENAME = "$2")');
                writeToFileCommandCompletion.documentation = new vscode.MarkdownString('Schreibt den übergebenen Text in die übergebene Datei.');
                items.push(writeToFileCommandCompletion);
                const xml2CobolCommandCompletion = new vscode.CompletionItem('xml2Cobol');
                xml2CobolCommandCompletion.kind = vscode.CompletionItemKind.Function;
                xml2CobolCommandCompletion.insertText = new vscode.SnippetString('xml2Cobol(INPUT_XML = "$1", COPYBOOK = "$2", OUTPUT_BIN = "$3")');
                xml2CobolCommandCompletion.documentation = new vscode.MarkdownString('Kommando zum übersetzen einer Host XML mittels Copybook in eine binär-Datei. Es wird CP037 als Ausgabedialkt verwendet.');
                items.push(xml2CobolCommandCompletion);
                const zipFilesCommandCompletion = new vscode.CompletionItem('zipFiles');
                zipFilesCommandCompletion.kind = vscode.CompletionItemKind.Function;
                zipFilesCommandCompletion.insertText = new vscode.SnippetString('zipFiles(PATH_OF_FILES = "$1", PATH_OF_ARCHIVE = "$2")');
                zipFilesCommandCompletion.documentation = new vscode.MarkdownString('Speichert eine Auswahl an Dateien in einem ZIP-Archiv.');
                items.push(zipFilesCommandCompletion);
                const zoomMobileCommandCompletion = new vscode.CompletionItem('zoomMobile');
                zoomMobileCommandCompletion.kind = vscode.CompletionItemKind.Function;
                zoomMobileCommandCompletion.insertText = new vscode.SnippetString('zoomMobile(X_POSITION = "$1", Y_POSITION = "$2")');
                zoomMobileCommandCompletion.documentation = new vscode.MarkdownString('Führt eine Zoom Geste (zwei Finger auseinander bewegen) am definierten Punkt durch (Beispiel: zoomMobile("", "150", "150")). Warnung: Es sollte immer vermieden werden, Befehle auf dem Screen auszuführen, da Pixel angaben Device- und Auflösungsabhängig sind.');
                items.push(zoomMobileCommandCompletion);
            }
            if (/.*\s*addToText\s*\(.*/.test(linePrefix)) {
                const addToTextEXISTING_TEXTCompletion = new vscode.CompletionItem('EXISTING_TEXT');
                addToTextEXISTING_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                addToTextEXISTING_TEXTCompletion.insertText = new vscode.SnippetString("EXISTING_TEXT = \"${1}\"");
                addToTextEXISTING_TEXTCompletion.documentation = new vscode.MarkdownString('Zu erg\u00E4nzender Text');
                items.push(addToTextEXISTING_TEXTCompletion);
                const addToTextTEXT_TO_ADDCompletion = new vscode.CompletionItem('TEXT_TO_ADD');
                addToTextTEXT_TO_ADDCompletion.kind = vscode.CompletionItemKind.Field;
                addToTextTEXT_TO_ADDCompletion.insertText = new vscode.SnippetString("TEXT_TO_ADD = \"${1}\"");
                addToTextTEXT_TO_ADDCompletion.documentation = new vscode.MarkdownString('Hinzuzuf\u00FCgender Text');
                items.push(addToTextTEXT_TO_ADDCompletion);
                const addToTextIS_FILECompletion = new vscode.CompletionItem('IS_FILE');
                addToTextIS_FILECompletion.kind = vscode.CompletionItemKind.Field;
                addToTextIS_FILECompletion.insertText = new vscode.SnippetString("IS_FILE = \"${1}\"");
                addToTextIS_FILECompletion.documentation = new vscode.MarkdownString('Angabe, ob der zu erg\u00E4nzende Text ein Dateipfad ist. Default false');
                items.push(addToTextIS_FILECompletion);
                const addToTextTARGET_FILECompletion = new vscode.CompletionItem('TARGET_FILE');
                addToTextTARGET_FILECompletion.kind = vscode.CompletionItemKind.Field;
                addToTextTARGET_FILECompletion.insertText = new vscode.SnippetString("TARGET_FILE = \"${1}\"");
                addToTextTARGET_FILECompletion.documentation = new vscode.MarkdownString('Pfad, wenn Ergebnis direkt in Datei geschrieben werden soll.');
                items.push(addToTextTARGET_FILECompletion);
                const addToTextTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                addToTextTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                addToTextTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                addToTextTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den die bearbeitete Datei geschrieben wird.');
                items.push(addToTextTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*agentCallJava\s*\(.*/.test(linePrefix)) {
                const agentCallJavaMETHODCompletion = new vscode.CompletionItem('METHOD');
                agentCallJavaMETHODCompletion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaMETHODCompletion.insertText = new vscode.SnippetString("METHOD = \"${1}\"");
                agentCallJavaMETHODCompletion.documentation = new vscode.MarkdownString('Auszuf\u00FChrende Methode der Komponente');
                items.push(agentCallJavaMETHODCompletion);
                const agentCallJavaPARAM1Completion = new vscode.CompletionItem('PARAM1');
                agentCallJavaPARAM1Completion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaPARAM1Completion.insertText = new vscode.SnippetString("PARAM1 = \"${1}\"");
                agentCallJavaPARAM1Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(agentCallJavaPARAM1Completion);
                const agentCallJavaPARAM2Completion = new vscode.CompletionItem('PARAM2');
                agentCallJavaPARAM2Completion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaPARAM2Completion.insertText = new vscode.SnippetString("PARAM2 = \"${1}\"");
                agentCallJavaPARAM2Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(agentCallJavaPARAM2Completion);
                const agentCallJavaPARAM3Completion = new vscode.CompletionItem('PARAM3');
                agentCallJavaPARAM3Completion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaPARAM3Completion.insertText = new vscode.SnippetString("PARAM3 = \"${1}\"");
                agentCallJavaPARAM3Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(agentCallJavaPARAM3Completion);
                const agentCallJavaPARAM4Completion = new vscode.CompletionItem('PARAM4');
                agentCallJavaPARAM4Completion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaPARAM4Completion.insertText = new vscode.SnippetString("PARAM4 = \"${1}\"");
                agentCallJavaPARAM4Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(agentCallJavaPARAM4Completion);
                const agentCallJavaPARAM5Completion = new vscode.CompletionItem('PARAM5');
                agentCallJavaPARAM5Completion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaPARAM5Completion.insertText = new vscode.SnippetString("PARAM5 = \"${1}\"");
                agentCallJavaPARAM5Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(agentCallJavaPARAM5Completion);
                const agentCallJavaPARAM6Completion = new vscode.CompletionItem('PARAM6');
                agentCallJavaPARAM6Completion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaPARAM6Completion.insertText = new vscode.SnippetString("PARAM6 = \"${1}\"");
                agentCallJavaPARAM6Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(agentCallJavaPARAM6Completion);
                const agentCallJavaPARAM7Completion = new vscode.CompletionItem('PARAM7');
                agentCallJavaPARAM7Completion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaPARAM7Completion.insertText = new vscode.SnippetString("PARAM7 = \"${1}\"");
                agentCallJavaPARAM7Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(agentCallJavaPARAM7Completion);
                const agentCallJavaTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                agentCallJavaTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                agentCallJavaTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(agentCallJavaTARGET_STORAGE_KEYCompletion);
                const agentCallJavaPARAM8Completion = new vscode.CompletionItem('PARAM8');
                agentCallJavaPARAM8Completion.kind = vscode.CompletionItemKind.Field;
                agentCallJavaPARAM8Completion.insertText = new vscode.SnippetString("PARAM8 = \"${1}\"");
                agentCallJavaPARAM8Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(agentCallJavaPARAM8Completion);
            }
            if (/.*\s*attachJava\s*\(.*/.test(linePrefix)) {
                const attachJavaNAMECompletion = new vscode.CompletionItem('NAME');
                attachJavaNAMECompletion.kind = vscode.CompletionItemKind.Field;
                attachJavaNAMECompletion.insertText = new vscode.SnippetString("NAME = \"${1}\"");
                attachJavaNAMECompletion.documentation = new vscode.MarkdownString('Name des Java Fensters');
                items.push(attachJavaNAMECompletion);
            }
            if (/.*\s*backup\s*\(.*/.test(linePrefix)) {
                const backupRESULT_LEVELCompletion = new vscode.CompletionItem('RESULT_LEVEL');
                backupRESULT_LEVELCompletion.kind = vscode.CompletionItemKind.Field;
                backupRESULT_LEVELCompletion.insertText = new vscode.SnippetString("RESULT_LEVEL = \"${1}\"");
                backupRESULT_LEVELCompletion.documentation = new vscode.MarkdownString('Zu verwendendes Result Level');
                items.push(backupRESULT_LEVELCompletion);
                const backupMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                backupMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                backupMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                backupMESSAGECompletion.documentation = new vscode.MarkdownString('Nachricht, die im Bericht angezeigt werden soll.');
                items.push(backupMESSAGECompletion);
            }
            if (/.*\s*basicAutoItCommand\s*\(.*/.test(linePrefix)) {
                const basicAutoItCommandPARAM0Completion = new vscode.CompletionItem('PARAM0');
                basicAutoItCommandPARAM0Completion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandPARAM0Completion.insertText = new vscode.SnippetString("PARAM0 = \"${1}\"");
                basicAutoItCommandPARAM0Completion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(basicAutoItCommandPARAM0Completion);
                const basicAutoItCommandPARAM1Completion = new vscode.CompletionItem('PARAM1');
                basicAutoItCommandPARAM1Completion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandPARAM1Completion.insertText = new vscode.SnippetString("PARAM1 = \"${1}\"");
                basicAutoItCommandPARAM1Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(basicAutoItCommandPARAM1Completion);
                const basicAutoItCommandPARAM2Completion = new vscode.CompletionItem('PARAM2');
                basicAutoItCommandPARAM2Completion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandPARAM2Completion.insertText = new vscode.SnippetString("PARAM2 = \"${1}\"");
                basicAutoItCommandPARAM2Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(basicAutoItCommandPARAM2Completion);
                const basicAutoItCommandPARAM3Completion = new vscode.CompletionItem('PARAM3');
                basicAutoItCommandPARAM3Completion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandPARAM3Completion.insertText = new vscode.SnippetString("PARAM3 = \"${1}\"");
                basicAutoItCommandPARAM3Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(basicAutoItCommandPARAM3Completion);
                const basicAutoItCommandPARAM4Completion = new vscode.CompletionItem('PARAM4');
                basicAutoItCommandPARAM4Completion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandPARAM4Completion.insertText = new vscode.SnippetString("PARAM4 = \"${1}\"");
                basicAutoItCommandPARAM4Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(basicAutoItCommandPARAM4Completion);
                const basicAutoItCommandPARAM5Completion = new vscode.CompletionItem('PARAM5');
                basicAutoItCommandPARAM5Completion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandPARAM5Completion.insertText = new vscode.SnippetString("PARAM5 = \"${1}\"");
                basicAutoItCommandPARAM5Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(basicAutoItCommandPARAM5Completion);
                const basicAutoItCommandPARAM6Completion = new vscode.CompletionItem('PARAM6');
                basicAutoItCommandPARAM6Completion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandPARAM6Completion.insertText = new vscode.SnippetString("PARAM6 = \"${1}\"");
                basicAutoItCommandPARAM6Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(basicAutoItCommandPARAM6Completion);
                const basicAutoItCommandPARAM7Completion = new vscode.CompletionItem('PARAM7');
                basicAutoItCommandPARAM7Completion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandPARAM7Completion.insertText = new vscode.SnippetString("PARAM7 = \"${1}\"");
                basicAutoItCommandPARAM7Completion.documentation = new vscode.MarkdownString('PARAM');
                items.push(basicAutoItCommandPARAM7Completion);
                const basicAutoItCommandTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                basicAutoItCommandTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                basicAutoItCommandTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                basicAutoItCommandTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(basicAutoItCommandTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*basicSapCommand\s*\(.*/.test(linePrefix)) {
                const basicSapCommandPARAM0Completion = new vscode.CompletionItem('PARAM0');
                basicSapCommandPARAM0Completion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandPARAM0Completion.insertText = new vscode.SnippetString("PARAM0 = \"${1}\"");
                basicSapCommandPARAM0Completion.documentation = new vscode.MarkdownString('Erster Parameter f\u00FCr SAP Aufruf');
                items.push(basicSapCommandPARAM0Completion);
                const basicSapCommandPARAM1Completion = new vscode.CompletionItem('PARAM1');
                basicSapCommandPARAM1Completion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandPARAM1Completion.insertText = new vscode.SnippetString("PARAM1 = \"${1}\"");
                basicSapCommandPARAM1Completion.documentation = new vscode.MarkdownString('Zweiter Parameter f\u00FCr SAP Aufruf');
                items.push(basicSapCommandPARAM1Completion);
                const basicSapCommandPARAM2Completion = new vscode.CompletionItem('PARAM2');
                basicSapCommandPARAM2Completion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandPARAM2Completion.insertText = new vscode.SnippetString("PARAM2 = \"${1}\"");
                basicSapCommandPARAM2Completion.documentation = new vscode.MarkdownString('Dritter Parameter f\u00FCr SAP Aufruf');
                items.push(basicSapCommandPARAM2Completion);
                const basicSapCommandPARAM3Completion = new vscode.CompletionItem('PARAM3');
                basicSapCommandPARAM3Completion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandPARAM3Completion.insertText = new vscode.SnippetString("PARAM3 = \"${1}\"");
                basicSapCommandPARAM3Completion.documentation = new vscode.MarkdownString('Vierter Parameter f\u00FCr SAP Aufruf');
                items.push(basicSapCommandPARAM3Completion);
                const basicSapCommandPARAM4Completion = new vscode.CompletionItem('PARAM4');
                basicSapCommandPARAM4Completion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandPARAM4Completion.insertText = new vscode.SnippetString("PARAM4 = \"${1}\"");
                basicSapCommandPARAM4Completion.documentation = new vscode.MarkdownString('F\u00FCnfter Parameter f\u00FCr SAP Aufruf');
                items.push(basicSapCommandPARAM4Completion);
                const basicSapCommandPARAM5Completion = new vscode.CompletionItem('PARAM5');
                basicSapCommandPARAM5Completion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandPARAM5Completion.insertText = new vscode.SnippetString("PARAM5 = \"${1}\"");
                basicSapCommandPARAM5Completion.documentation = new vscode.MarkdownString('Sechster Parameter f\u00FCr SAP Aufruf');
                items.push(basicSapCommandPARAM5Completion);
                const basicSapCommandPARAM6Completion = new vscode.CompletionItem('PARAM6');
                basicSapCommandPARAM6Completion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandPARAM6Completion.insertText = new vscode.SnippetString("PARAM6 = \"${1}\"");
                basicSapCommandPARAM6Completion.documentation = new vscode.MarkdownString('Siebter Parameter f\u00FCr SAP Aufruf');
                items.push(basicSapCommandPARAM6Completion);
                const basicSapCommandPARAM7Completion = new vscode.CompletionItem('PARAM7');
                basicSapCommandPARAM7Completion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandPARAM7Completion.insertText = new vscode.SnippetString("PARAM7 = \"${1}\"");
                basicSapCommandPARAM7Completion.documentation = new vscode.MarkdownString('Achter Parameter f\u00FCr SAP Aufruf');
                items.push(basicSapCommandPARAM7Completion);
                const basicSapCommandTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                basicSapCommandTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                basicSapCommandTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                basicSapCommandTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den ein potenzielles Ergebnis geschrieben werden soll.');
                items.push(basicSapCommandTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*break\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*changeStorageValue\s*\(.*/.test(linePrefix)) {
                const changeStorageValueSOURCE_STORAGE_KEYCompletion = new vscode.CompletionItem('SOURCE_STORAGE_KEY');
                changeStorageValueSOURCE_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                changeStorageValueSOURCE_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("SOURCE_STORAGE_KEY = \"${1}\"");
                changeStorageValueSOURCE_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel der zu modifizierenden Laufzeitvariable');
                items.push(changeStorageValueSOURCE_STORAGE_KEYCompletion);
                const changeStorageValueOPERATIONCompletion = new vscode.CompletionItem('OPERATION');
                changeStorageValueOPERATIONCompletion.kind = vscode.CompletionItemKind.Field;
                changeStorageValueOPERATIONCompletion.insertText = new vscode.SnippetString("OPERATION = \"${1}\"");
                changeStorageValueOPERATIONCompletion.documentation = new vscode.MarkdownString('Durchzuf\u00FChrende Operation. M\u00F6glich sind:            - entferne            - entferneLeerzeichen                                          - reset: setzt den Wert auf \'0\'            - addOrReplace: der Wert der Variable SOURCE_STORAGE_KEY wird durch den Wert in PARAM3 \u00FCberschrieben oder dieser wird neu hinzugef\u00FCgt. Wird PARAM3 auf den Wert {CLIPBOARD} gesetzt, so wird der aktuelle Wert der Zwischenablage in SOURCE_STORAGE_KEY gespeichert.       - extractSingleSqlResultFromJson: extrahiert einen einzelnen Wert aus der in PARAM3 gegebenen Spalte aus dem unter KEY als JSON-Array gespeicherten SQL-Ergebnis. Beispiel: [{\'ID\' :123 }] wird zu 1 wenn PARAM3 auf ID gesetzt wird.      Voraussetzung: die Variable enth\u00E4lt das Ergebnis genau eines ( also      nicht mehrerer ) SQL-Statements. Besteht das unter KEY gespeichert      SQL-Ergebnis aus mehreren Zeilen , wird per Default die erste Zeile      ausgelesen. Soll jedoch der Wert aus einer bestimmten Zeile      ausgelesen werden , kann diese in PARAM4 festgelegt werden.      Beispiel: [ \'ID\' :123 } ID\' :456 } wird zu 4 wenn PARAM3 auf ID      und PARAM4 auf 2 gesetzt wird. ( PARAM3=Spaltenname ( Pflicht )      PARAM4=Zeilenindex ( optional , Z\u00E4hlung ab 1)). Befinden sich Ergebnisse aus mehreren SQL-Kommandos in der Variablen, kann ein einzelner Eintrag \u00FCber einen Index in PARAM4 extrahiert werden (Voraussetzung: PARAM3 ist nicht gesetzt).       - regex: generiert und speichert einen Wert aus einer in PARAM3 \u00FCbergebenen Regular Expression             - regex_from_old: speichert den resultierenden String aus der Regular Expression (PARAM3) und dem Quellstring (SOURCE_STORAGE_VALUE)            - get_testscript_directory: speichert den absoluten Pfad des Testscript-Verzeichnisses in einer Variablen.            - replace_char: ersetzt in SOURCE_STORAGE_KEY eine gefundene Zeichenfolge (PARAM3) durch mitgegebene Zeichen (PARAM4) und speichert sie bei Bedarf in einer neuen Variablen.                                          - convert_date: wandelt das Format jjjj-MM-dd in das Format dd.MM.jjjj um.                                          - calculate_date: generiert ein String mit dem aktuellen Datum im Format jjjj-MM-dd, wenn PARAM3 und PARAM4 nicht gesetzt sind. \u00DCber PARAM3 eine Modifikation eines Datums gesetzt werden (Voraussetzung ist das Format jjjj-MM-dd). M\u00F6glich sind add_day, add_month, add_year, set_day, set_month und set_year mit dem ganzahligen Wert aus PARAM4.         ');
                items.push(changeStorageValueOPERATIONCompletion);
                const changeStorageValuePARAM3Completion = new vscode.CompletionItem('PARAM3');
                changeStorageValuePARAM3Completion.kind = vscode.CompletionItemKind.Field;
                changeStorageValuePARAM3Completion.insertText = new vscode.SnippetString("PARAM3 = \"${1}\"");
                changeStorageValuePARAM3Completion.documentation = new vscode.MarkdownString('Parameter abh\u00E4ngig von der Operation (siehe Parameter OPERATION).');
                items.push(changeStorageValuePARAM3Completion);
                const changeStorageValuePARAM4Completion = new vscode.CompletionItem('PARAM4');
                changeStorageValuePARAM4Completion.kind = vscode.CompletionItemKind.Field;
                changeStorageValuePARAM4Completion.insertText = new vscode.SnippetString("PARAM4 = \"${1}\"");
                changeStorageValuePARAM4Completion.documentation = new vscode.MarkdownString('Parameter abh\u00E4ngig von der Operation (siehe Parameter OPERATION).');
                items.push(changeStorageValuePARAM4Completion);
                const changeStorageValueTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                changeStorageValueTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                changeStorageValueTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                changeStorageValueTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein neuer Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird. Ist TARGET_STORAGE_KEY nicht gesetzt, wird das Ergebnis wieder unter dem Schl\u00FCssel SOURCE_STORAGE_KEY gespeichert, d.h. ein evtl. bislang dort abgelegter Wert wird \u00FCberschrieben.');
                items.push(changeStorageValueTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*checkAlertWeb\s*\(.*/.test(linePrefix)) {
                const checkAlertWebALERT_MESSAGECompletion = new vscode.CompletionItem('ALERT_MESSAGE');
                checkAlertWebALERT_MESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                checkAlertWebALERT_MESSAGECompletion.insertText = new vscode.SnippetString("ALERT_MESSAGE = \"${1}\"");
                checkAlertWebALERT_MESSAGECompletion.documentation = new vscode.MarkdownString('Vollst\u00E4ndige Warnung oder Teil (Substring) der Meldung, die zu pr\u00FCfen ist.');
                items.push(checkAlertWebALERT_MESSAGECompletion);
                const checkAlertWebACCEPT_ALERTCompletion = new vscode.CompletionItem('ACCEPT_ALERT');
                checkAlertWebACCEPT_ALERTCompletion.kind = vscode.CompletionItemKind.Field;
                checkAlertWebACCEPT_ALERTCompletion.insertText = new vscode.SnippetString("ACCEPT_ALERT = \"${1}\"");
                checkAlertWebACCEPT_ALERTCompletion.documentation = new vscode.MarkdownString('Auf False setzen, falls die Meldung nach Pr\u00FCfung nicht geschlossen werden soll. (Default True)');
                items.push(checkAlertWebACCEPT_ALERTCompletion);
                const checkAlertWebACCEPT_ALERT_ON_WARNINGCompletion = new vscode.CompletionItem('ACCEPT_ALERT_ON_WARNING');
                checkAlertWebACCEPT_ALERT_ON_WARNINGCompletion.kind = vscode.CompletionItemKind.Field;
                checkAlertWebACCEPT_ALERT_ON_WARNINGCompletion.insertText = new vscode.SnippetString("ACCEPT_ALERT_ON_WARNING = \"${1}\"");
                checkAlertWebACCEPT_ALERT_ON_WARNINGCompletion.documentation = new vscode.MarkdownString('Auf False setzen, falls die Meldung nicht geschlossen werden soll, nachdem gefunden wurde, dass ihr Inhalt nicht die ALERT_MESSAGE enth\u00E4lt. (Default True)');
                items.push(checkAlertWebACCEPT_ALERT_ON_WARNINGCompletion);
                const checkAlertWebTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                checkAlertWebTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                checkAlertWebTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                checkAlertWebTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Optionaler Schl\u00FCssel, unter dem der Inhalt der Alarm-Meldung in der Storage-Datei gespeichert werden kann.');
                items.push(checkAlertWebTARGET_STORAGE_KEYCompletion);
                const checkAlertWebWEB_DRIVER_WAIT_TIMEOUTCompletion = new vscode.CompletionItem('WEB_DRIVER_WAIT_TIMEOUT');
                checkAlertWebWEB_DRIVER_WAIT_TIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                checkAlertWebWEB_DRIVER_WAIT_TIMEOUTCompletion.insertText = new vscode.SnippetString("WEB_DRIVER_WAIT_TIMEOUT = \"${1}\"");
                checkAlertWebWEB_DRIVER_WAIT_TIMEOUTCompletion.documentation = new vscode.MarkdownString('Wartet auf Timout.');
                items.push(checkAlertWebWEB_DRIVER_WAIT_TIMEOUTCompletion);
            }
            if (/.*\s*checkButtonIsSelectableWinEle\s*\(.*/.test(linePrefix)) {
                const checkButtonIsSelectableWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkButtonIsSelectableWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkButtonIsSelectableWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkButtonIsSelectableWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkButtonIsSelectableWinEleWINDOW_NAMECompletion);
                const checkButtonIsSelectableWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkButtonIsSelectableWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkButtonIsSelectableWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkButtonIsSelectableWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkButtonIsSelectableWinElePROCESS_NAMECompletion);
                const checkButtonIsSelectableWinEleBUTTON_NAMECompletion = new vscode.CompletionItem('BUTTON_NAME');
                checkButtonIsSelectableWinEleBUTTON_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkButtonIsSelectableWinEleBUTTON_NAMECompletion.insertText = new vscode.SnippetString("BUTTON_NAME = \"${1}\"");
                checkButtonIsSelectableWinEleBUTTON_NAMECompletion.documentation = new vscode.MarkdownString('Name des Buttons. Dieser ist h\u00E4ufig identisch mit seinem Text (z.B. \'OK\'). Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen Namen zu ermitteln.');
                items.push(checkButtonIsSelectableWinEleBUTTON_NAMECompletion);
                const checkButtonIsSelectableWinEleSHOULD_BECompletion = new vscode.CompletionItem('SHOULD_BE');
                checkButtonIsSelectableWinEleSHOULD_BECompletion.kind = vscode.CompletionItemKind.Field;
                checkButtonIsSelectableWinEleSHOULD_BECompletion.insertText = new vscode.SnippetString("SHOULD_BE = \"${1}\"");
                checkButtonIsSelectableWinEleSHOULD_BECompletion.documentation = new vscode.MarkdownString('Zustand, den der Button haben sollte. Entweder true oder false.');
                items.push(checkButtonIsSelectableWinEleSHOULD_BECompletion);
            }
            if (/.*\s*checkCheckboxIsSelectableWinEle\s*\(.*/.test(linePrefix)) {
                const checkCheckboxIsSelectableWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkCheckboxIsSelectableWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectableWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkCheckboxIsSelectableWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkCheckboxIsSelectableWinEleWINDOW_NAMECompletion);
                const checkCheckboxIsSelectableWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkCheckboxIsSelectableWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectableWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkCheckboxIsSelectableWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkCheckboxIsSelectableWinElePROCESS_NAMECompletion);
                const checkCheckboxIsSelectableWinEleCHECKBOX_NAMECompletion = new vscode.CompletionItem('CHECKBOX_NAME');
                checkCheckboxIsSelectableWinEleCHECKBOX_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectableWinEleCHECKBOX_NAMECompletion.insertText = new vscode.SnippetString("CHECKBOX_NAME = \"${1}\"");
                checkCheckboxIsSelectableWinEleCHECKBOX_NAMECompletion.documentation = new vscode.MarkdownString('Name der Checkbox, die gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(checkCheckboxIsSelectableWinEleCHECKBOX_NAMECompletion);
                const checkCheckboxIsSelectableWinEleSHOULD_BECompletion = new vscode.CompletionItem('SHOULD_BE');
                checkCheckboxIsSelectableWinEleSHOULD_BECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectableWinEleSHOULD_BECompletion.insertText = new vscode.SnippetString("SHOULD_BE = \"${1}\"");
                checkCheckboxIsSelectableWinEleSHOULD_BECompletion.documentation = new vscode.MarkdownString('Eigenschaft, die das Element haben sollte. Es sind die Werte \'true\' oder \'false\' m\u00F6glich.');
                items.push(checkCheckboxIsSelectableWinEleSHOULD_BECompletion);
                const checkCheckboxIsSelectableWinEleCHECKBOX_INDEXCompletion = new vscode.CompletionItem('CHECKBOX_INDEX');
                checkCheckboxIsSelectableWinEleCHECKBOX_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectableWinEleCHECKBOX_INDEXCompletion.insertText = new vscode.SnippetString("CHECKBOX_INDEX = \"${1}\"");
                checkCheckboxIsSelectableWinEleCHECKBOX_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Checkboxes des Fensers bezieht.');
                items.push(checkCheckboxIsSelectableWinEleCHECKBOX_INDEXCompletion);
            }
            if (/.*\s*checkCheckboxIsSelectedWinEle\s*\(.*/.test(linePrefix)) {
                const checkCheckboxIsSelectedWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkCheckboxIsSelectedWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectedWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkCheckboxIsSelectedWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkCheckboxIsSelectedWinEleWINDOW_NAMECompletion);
                const checkCheckboxIsSelectedWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkCheckboxIsSelectedWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectedWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkCheckboxIsSelectedWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkCheckboxIsSelectedWinElePROCESS_NAMECompletion);
                const checkCheckboxIsSelectedWinEleCHECKBOX_NAMECompletion = new vscode.CompletionItem('CHECKBOX_NAME');
                checkCheckboxIsSelectedWinEleCHECKBOX_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectedWinEleCHECKBOX_NAMECompletion.insertText = new vscode.SnippetString("CHECKBOX_NAME = \"${1}\"");
                checkCheckboxIsSelectedWinEleCHECKBOX_NAMECompletion.documentation = new vscode.MarkdownString('Name der Checkbox, die gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(checkCheckboxIsSelectedWinEleCHECKBOX_NAMECompletion);
                const checkCheckboxIsSelectedWinEleSHOULD_BECompletion = new vscode.CompletionItem('SHOULD_BE');
                checkCheckboxIsSelectedWinEleSHOULD_BECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectedWinEleSHOULD_BECompletion.insertText = new vscode.SnippetString("SHOULD_BE = \"${1}\"");
                checkCheckboxIsSelectedWinEleSHOULD_BECompletion.documentation = new vscode.MarkdownString('Eigenschaft, die das Element haben sollte. Es sind die Werte \'true\' oder \'false\' m\u00F6glich.');
                items.push(checkCheckboxIsSelectedWinEleSHOULD_BECompletion);
                const checkCheckboxIsSelectedWinEleCHECKBOX_INDEXCompletion = new vscode.CompletionItem('CHECKBOX_INDEX');
                checkCheckboxIsSelectedWinEleCHECKBOX_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxIsSelectedWinEleCHECKBOX_INDEXCompletion.insertText = new vscode.SnippetString("CHECKBOX_INDEX = \"${1}\"");
                checkCheckboxIsSelectedWinEleCHECKBOX_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Checkboxes des Fensers bezieht.');
                items.push(checkCheckboxIsSelectedWinEleCHECKBOX_INDEXCompletion);
            }
            if (/.*\s*checkCheckboxSelectedWeb\s*\(.*/.test(linePrefix)) {
                const checkCheckboxSelectedWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkCheckboxSelectedWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxSelectedWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkCheckboxSelectedWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkCheckboxSelectedWebBY_CRITERIACompletion);
                const checkCheckboxSelectedWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkCheckboxSelectedWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxSelectedWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkCheckboxSelectedWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkCheckboxSelectedWebELEMENT_NAMECompletion);
                const checkCheckboxSelectedWebCHECK_SELECTEDCompletion = new vscode.CompletionItem('CHECK_SELECTED');
                checkCheckboxSelectedWebCHECK_SELECTEDCompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxSelectedWebCHECK_SELECTEDCompletion.insertText = new vscode.SnippetString("CHECK_SELECTED = \"${1}\"");
                checkCheckboxSelectedWebCHECK_SELECTEDCompletion.documentation = new vscode.MarkdownString('Wenn false, wird gepr\u00FCft, ob das Element nicht ausgew\u00E4hlt wurde. Wenn true, wird gepr\u00FCft, ob das Element ausgew\u00E4hlt wurde (Default: true)');
                items.push(checkCheckboxSelectedWebCHECK_SELECTEDCompletion);
            }
            if (/.*\s*checkCheckboxWinEle\s*\(.*/.test(linePrefix)) {
                const checkCheckboxWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkCheckboxWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkCheckboxWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkCheckboxWinEleWINDOW_NAMECompletion);
                const checkCheckboxWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkCheckboxWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkCheckboxWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkCheckboxWinElePROCESS_NAMECompletion);
                const checkCheckboxWinEleCHECKBOX_NAMECompletion = new vscode.CompletionItem('CHECKBOX_NAME');
                checkCheckboxWinEleCHECKBOX_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxWinEleCHECKBOX_NAMECompletion.insertText = new vscode.SnippetString("CHECKBOX_NAME = \"${1}\"");
                checkCheckboxWinEleCHECKBOX_NAMECompletion.documentation = new vscode.MarkdownString('Name der Checkbox, die gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(checkCheckboxWinEleCHECKBOX_NAMECompletion);
                const checkCheckboxWinEleCHECKBOX_INDEXCompletion = new vscode.CompletionItem('CHECKBOX_INDEX');
                checkCheckboxWinEleCHECKBOX_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                checkCheckboxWinEleCHECKBOX_INDEXCompletion.insertText = new vscode.SnippetString("CHECKBOX_INDEX = \"${1}\"");
                checkCheckboxWinEleCHECKBOX_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Checkboxes des Fensers bezieht.');
                items.push(checkCheckboxWinEleCHECKBOX_INDEXCompletion);
            }
            if (/.*\s*checkCurrentActivityAndroid\s*\(.*/.test(linePrefix)) {
                const checkCurrentActivityAndroidEXPECTED_ACTIVITY_NAMECompletion = new vscode.CompletionItem('EXPECTED_ACTIVITY_NAME');
                checkCurrentActivityAndroidEXPECTED_ACTIVITY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkCurrentActivityAndroidEXPECTED_ACTIVITY_NAMECompletion.insertText = new vscode.SnippetString("EXPECTED_ACTIVITY_NAME = \"${1}\"");
                checkCurrentActivityAndroidEXPECTED_ACTIVITY_NAMECompletion.documentation = new vscode.MarkdownString('Der Parameter muss mit dem Namen der Activity belegt werden.');
                items.push(checkCurrentActivityAndroidEXPECTED_ACTIVITY_NAMECompletion);
            }
            if (/.*\s*checkDriverActive\s*\(.*/.test(linePrefix)) {
                const checkDriverActiveBROWSER_ABBREVIATIONCompletion = new vscode.CompletionItem('BROWSER_ABBREVIATION');
                checkDriverActiveBROWSER_ABBREVIATIONCompletion.kind = vscode.CompletionItemKind.Field;
                checkDriverActiveBROWSER_ABBREVIATIONCompletion.insertText = new vscode.SnippetString("BROWSER_ABBREVIATION = \"${1}\"");
                checkDriverActiveBROWSER_ABBREVIATIONCompletion.documentation = new vscode.MarkdownString('Abk\u00FCrzung f\u00FCr den Browser, der \u00FCberpr\u00FCft werden soll (FF=Firefox, IE=Internet Explorer, CH=Chrome, SA=Safari)');
                items.push(checkDriverActiveBROWSER_ABBREVIATIONCompletion);
                const checkDriverActiveBROWSER_ALIASCompletion = new vscode.CompletionItem('BROWSER_ALIAS');
                checkDriverActiveBROWSER_ALIASCompletion.kind = vscode.CompletionItemKind.Field;
                checkDriverActiveBROWSER_ALIASCompletion.insertText = new vscode.SnippetString("BROWSER_ALIAS = \"${1}\"");
                checkDriverActiveBROWSER_ALIASCompletion.documentation = new vscode.MarkdownString('(Wird in startWeb festgelegt). Falls mehrere gleichartige Browser ge\u00F6ffnet sind, eindeutiger Alias des zu pr\u00FCfenden Browsers.');
                items.push(checkDriverActiveBROWSER_ALIASCompletion);
            }
            if (/.*\s*checkDropDownIsSelectableWinEle\s*\(.*/.test(linePrefix)) {
                const checkDropDownIsSelectableWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkDropDownIsSelectableWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkDropDownIsSelectableWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkDropDownIsSelectableWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkDropDownIsSelectableWinEleWINDOW_NAMECompletion);
                const checkDropDownIsSelectableWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkDropDownIsSelectableWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkDropDownIsSelectableWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkDropDownIsSelectableWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkDropDownIsSelectableWinElePROCESS_NAMECompletion);
                const checkDropDownIsSelectableWinEleDROPDOWN_NAMECompletion = new vscode.CompletionItem('DROPDOWN_NAME');
                checkDropDownIsSelectableWinEleDROPDOWN_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkDropDownIsSelectableWinEleDROPDOWN_NAMECompletion.insertText = new vscode.SnippetString("DROPDOWN_NAME = \"${1}\"");
                checkDropDownIsSelectableWinEleDROPDOWN_NAMECompletion.documentation = new vscode.MarkdownString('Name des Dropdown Men\u00FCs. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(checkDropDownIsSelectableWinEleDROPDOWN_NAMECompletion);
                const checkDropDownIsSelectableWinEleSHOULD_BECompletion = new vscode.CompletionItem('SHOULD_BE');
                checkDropDownIsSelectableWinEleSHOULD_BECompletion.kind = vscode.CompletionItemKind.Field;
                checkDropDownIsSelectableWinEleSHOULD_BECompletion.insertText = new vscode.SnippetString("SHOULD_BE = \"${1}\"");
                checkDropDownIsSelectableWinEleSHOULD_BECompletion.documentation = new vscode.MarkdownString('Eigenschaft, die das Element haben sollte. Es sind die Werte \'true\' oder \'false\' m\u00F6glich.');
                items.push(checkDropDownIsSelectableWinEleSHOULD_BECompletion);
                const checkDropDownIsSelectableWinEleDROPDOWN_INDEXCompletion = new vscode.CompletionItem('DROPDOWN_INDEX');
                checkDropDownIsSelectableWinEleDROPDOWN_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                checkDropDownIsSelectableWinEleDROPDOWN_INDEXCompletion.insertText = new vscode.SnippetString("DROPDOWN_INDEX = \"${1}\"");
                checkDropDownIsSelectableWinEleDROPDOWN_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Dropdown-menues des Fensers bezieht.');
                items.push(checkDropDownIsSelectableWinEleDROPDOWN_INDEXCompletion);
            }
            if (/.*\s*checkElementActiveWeb\s*\(.*/.test(linePrefix)) {
                const checkElementActiveWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementActiveWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementActiveWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementActiveWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementActiveWebBY_CRITERIACompletion);
                const checkElementActiveWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementActiveWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementActiveWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementActiveWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementActiveWebELEMENT_NAMECompletion);
            }
            if (/.*\s*checkElementAttributeEqualsWeb\s*\(.*/.test(linePrefix)) {
                const checkElementAttributeEqualsWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementAttributeEqualsWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementAttributeEqualsWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementAttributeEqualsWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementAttributeEqualsWebBY_CRITERIACompletion);
                const checkElementAttributeEqualsWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementAttributeEqualsWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementAttributeEqualsWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementAttributeEqualsWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementAttributeEqualsWebELEMENT_NAMECompletion);
                const checkElementAttributeEqualsWebTEXT_EQUALSCompletion = new vscode.CompletionItem('TEXT_EQUALS');
                checkElementAttributeEqualsWebTEXT_EQUALSCompletion.kind = vscode.CompletionItemKind.Field;
                checkElementAttributeEqualsWebTEXT_EQUALSCompletion.insertText = new vscode.SnippetString("TEXT_EQUALS = \"${1}\"");
                checkElementAttributeEqualsWebTEXT_EQUALSCompletion.documentation = new vscode.MarkdownString('Textueller Wert des Attribut-Wertes');
                items.push(checkElementAttributeEqualsWebTEXT_EQUALSCompletion);
                const checkElementAttributeEqualsWebATTRIBUTE_NAMECompletion = new vscode.CompletionItem('ATTRIBUTE_NAME');
                checkElementAttributeEqualsWebATTRIBUTE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementAttributeEqualsWebATTRIBUTE_NAMECompletion.insertText = new vscode.SnippetString("ATTRIBUTE_NAME = \"${1}\"");
                checkElementAttributeEqualsWebATTRIBUTE_NAMECompletion.documentation = new vscode.MarkdownString('Name des zu \u00FCberpr\u00FCfenden Attributs');
                items.push(checkElementAttributeEqualsWebATTRIBUTE_NAMECompletion);
                const checkElementAttributeEqualsWebCONTAINSCompletion = new vscode.CompletionItem('CONTAINS');
                checkElementAttributeEqualsWebCONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                checkElementAttributeEqualsWebCONTAINSCompletion.insertText = new vscode.SnippetString("CONTAINS = \"${1}\"");
                checkElementAttributeEqualsWebCONTAINSCompletion.documentation = new vscode.MarkdownString('Wenn false, muss der gefundene Text dem TEXT_EQUALS w\u00F6rtlich entsprechen. Wenn true, muss der angegebene Text nur enthalten sein. Default: false.');
                items.push(checkElementAttributeEqualsWebCONTAINSCompletion);
            }
            if (/.*\s*checkElementCssEqualsWeb\s*\(.*/.test(linePrefix)) {
                const checkElementCssEqualsWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementCssEqualsWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementCssEqualsWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementCssEqualsWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementCssEqualsWebBY_CRITERIACompletion);
                const checkElementCssEqualsWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementCssEqualsWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementCssEqualsWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementCssEqualsWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementCssEqualsWebELEMENT_NAMECompletion);
                const checkElementCssEqualsWebTEXT_EQUALSCompletion = new vscode.CompletionItem('TEXT_EQUALS');
                checkElementCssEqualsWebTEXT_EQUALSCompletion.kind = vscode.CompletionItemKind.Field;
                checkElementCssEqualsWebTEXT_EQUALSCompletion.insertText = new vscode.SnippetString("TEXT_EQUALS = \"${1}\"");
                checkElementCssEqualsWebTEXT_EQUALSCompletion.documentation = new vscode.MarkdownString('Textueller Wert des Attribut-Wertes');
                items.push(checkElementCssEqualsWebTEXT_EQUALSCompletion);
                const checkElementCssEqualsWebCSS_ATTRIBUTE_NAMECompletion = new vscode.CompletionItem('CSS_ATTRIBUTE_NAME');
                checkElementCssEqualsWebCSS_ATTRIBUTE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementCssEqualsWebCSS_ATTRIBUTE_NAMECompletion.insertText = new vscode.SnippetString("CSS_ATTRIBUTE_NAME = \"${1}\"");
                checkElementCssEqualsWebCSS_ATTRIBUTE_NAMECompletion.documentation = new vscode.MarkdownString('Name des zu \u00FCberpr\u00FCfenden Attributs');
                items.push(checkElementCssEqualsWebCSS_ATTRIBUTE_NAMECompletion);
                const checkElementCssEqualsWebCONTAINSCompletion = new vscode.CompletionItem('CONTAINS');
                checkElementCssEqualsWebCONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                checkElementCssEqualsWebCONTAINSCompletion.insertText = new vscode.SnippetString("CONTAINS = \"${1}\"");
                checkElementCssEqualsWebCONTAINSCompletion.documentation = new vscode.MarkdownString('Wenn false, muss der gefundene Text dem TEXT_EQUALS w\u00F6rtlich entsprechen. Wenn true, muss der angegebene Text nur enthalten sein. Default: false');
                items.push(checkElementCssEqualsWebCONTAINSCompletion);
            }
            if (/.*\s*checkElementEnabledWeb\s*\(.*/.test(linePrefix)) {
                const checkElementEnabledWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementEnabledWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementEnabledWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementEnabledWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementEnabledWebBY_CRITERIACompletion);
                const checkElementEnabledWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementEnabledWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementEnabledWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementEnabledWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementEnabledWebELEMENT_NAMECompletion);
            }
            if (/.*\s*checkElementNotPresent\s*\(.*/.test(linePrefix)) {
                const checkElementNotPresentBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementNotPresentBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementNotPresentBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementNotPresentBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementNotPresentBY_CRITERIACompletion);
                const checkElementNotPresentELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementNotPresentELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementNotPresentELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementNotPresentELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementNotPresentELEMENT_NAMECompletion);
            }
            if (/.*\s*checkElementNotPresentWeb\s*\(.*/.test(linePrefix)) {
                const checkElementNotPresentWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementNotPresentWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementNotPresentWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementNotPresentWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementNotPresentWebBY_CRITERIACompletion);
                const checkElementNotPresentWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementNotPresentWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementNotPresentWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementNotPresentWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementNotPresentWebELEMENT_NAMECompletion);
            }
            if (/.*\s*checkElementPresent\s*\(.*/.test(linePrefix)) {
                const checkElementPresentBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementPresentBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementPresentBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementPresentBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementPresentBY_CRITERIACompletion);
                const checkElementPresentELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementPresentELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementPresentELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementPresentELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementPresentELEMENT_NAMECompletion);
            }
            if (/.*\s*checkElementPresentWeb\s*\(.*/.test(linePrefix)) {
                const checkElementPresentWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementPresentWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementPresentWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementPresentWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementPresentWebBY_CRITERIACompletion);
                const checkElementPresentWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementPresentWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementPresentWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementPresentWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementPresentWebELEMENT_NAMECompletion);
            }
            if (/.*\s*checkElementSelectedWeb\s*\(.*/.test(linePrefix)) {
                const checkElementSelectedWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementSelectedWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementSelectedWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementSelectedWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementSelectedWebBY_CRITERIACompletion);
                const checkElementSelectedWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementSelectedWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementSelectedWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementSelectedWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementSelectedWebELEMENT_NAMECompletion);
                const checkElementSelectedWebCHECK_SELECTEDCompletion = new vscode.CompletionItem('CHECK_SELECTED');
                checkElementSelectedWebCHECK_SELECTEDCompletion.kind = vscode.CompletionItemKind.Field;
                checkElementSelectedWebCHECK_SELECTEDCompletion.insertText = new vscode.SnippetString("CHECK_SELECTED = \"${1}\"");
                checkElementSelectedWebCHECK_SELECTEDCompletion.documentation = new vscode.MarkdownString('Wenn false, wird gepr\u00FCft, ob das Element nicht ausgew\u00E4hlt wurde. Wenn true, wird gepr\u00FCft, ob das Element ausgew\u00E4hlt wurde (Default: true)');
                items.push(checkElementSelectedWebCHECK_SELECTEDCompletion);
            }
            if (/.*\s*checkElementTextEqualsWeb\s*\(.*/.test(linePrefix)) {
                const checkElementTextEqualsWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementTextEqualsWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementTextEqualsWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementTextEqualsWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementTextEqualsWebBY_CRITERIACompletion);
                const checkElementTextEqualsWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementTextEqualsWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementTextEqualsWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementTextEqualsWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementTextEqualsWebELEMENT_NAMECompletion);
                const checkElementTextEqualsWebTEXT_EQUALSCompletion = new vscode.CompletionItem('TEXT_EQUALS');
                checkElementTextEqualsWebTEXT_EQUALSCompletion.kind = vscode.CompletionItemKind.Field;
                checkElementTextEqualsWebTEXT_EQUALSCompletion.insertText = new vscode.SnippetString("TEXT_EQUALS = \"${1}\"");
                checkElementTextEqualsWebTEXT_EQUALSCompletion.documentation = new vscode.MarkdownString('Text, der enthalten sein soll.');
                items.push(checkElementTextEqualsWebTEXT_EQUALSCompletion);
                const checkElementTextEqualsWebCASE_SENSITIVECompletion = new vscode.CompletionItem('CASE_SENSITIVE');
                checkElementTextEqualsWebCASE_SENSITIVECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementTextEqualsWebCASE_SENSITIVECompletion.insertText = new vscode.SnippetString("CASE_SENSITIVE = \"${1}\"");
                checkElementTextEqualsWebCASE_SENSITIVECompletion.documentation = new vscode.MarkdownString('{true, false} Gibt an, ob auch auf Gro\u00DF- und Kleinschreibung geachtet werden soll bei der \u00DCberpr\u00FCfung. Default: false.');
                items.push(checkElementTextEqualsWebCASE_SENSITIVECompletion);
                const checkElementTextEqualsWebCONTAINSCompletion = new vscode.CompletionItem('CONTAINS');
                checkElementTextEqualsWebCONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                checkElementTextEqualsWebCONTAINSCompletion.insertText = new vscode.SnippetString("CONTAINS = \"${1}\"");
                checkElementTextEqualsWebCONTAINSCompletion.documentation = new vscode.MarkdownString('{true, false} Gibt an, ob gezielt nach dem Wert gesucht werden soll (true) oder ob es enthalten sein soll (false)). Default: false.');
                items.push(checkElementTextEqualsWebCONTAINSCompletion);
            }
            if (/.*\s*checkElementVisibleWeb\s*\(.*/.test(linePrefix)) {
                const checkElementVisibleWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkElementVisibleWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkElementVisibleWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkElementVisibleWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(checkElementVisibleWebBY_CRITERIACompletion);
                const checkElementVisibleWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkElementVisibleWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkElementVisibleWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkElementVisibleWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(checkElementVisibleWebELEMENT_NAMECompletion);
            }
            if (/.*\s*checkFileContent\s*\(.*/.test(linePrefix)) {
                const checkFileContentFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                checkFileContentFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkFileContentFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                checkFileContentFILENAMECompletion.documentation = new vscode.MarkdownString('Name der zu durchsuchenden Datei');
                items.push(checkFileContentFILENAMECompletion);
                const checkFileContentTEXT_EQUALSCompletion = new vscode.CompletionItem('TEXT_EQUALS');
                checkFileContentTEXT_EQUALSCompletion.kind = vscode.CompletionItemKind.Field;
                checkFileContentTEXT_EQUALSCompletion.insertText = new vscode.SnippetString("TEXT_EQUALS = \"${1}\"");
                checkFileContentTEXT_EQUALSCompletion.documentation = new vscode.MarkdownString('In der Datei zu findender Text');
                items.push(checkFileContentTEXT_EQUALSCompletion);
                const checkFileContentWAIT_MILLISECONDSCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS');
                checkFileContentWAIT_MILLISECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                checkFileContentWAIT_MILLISECONDSCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS = \"${1}\"");
                checkFileContentWAIT_MILLISECONDSCompletion.documentation = new vscode.MarkdownString('F\u00FCr so viele Millisekunden werden im Nachgang noch neue Daten verarbeitet');
                items.push(checkFileContentWAIT_MILLISECONDSCompletion);
            }
            if (/.*\s*checkFileExists\s*\(.*/.test(linePrefix)) {
                const checkFileExistsFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                checkFileExistsFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkFileExistsFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                checkFileExistsFILENAMECompletion.documentation = new vscode.MarkdownString('Name der zu suchenden Datei');
                items.push(checkFileExistsFILENAMECompletion);
                const checkFileExistsTRIESCompletion = new vscode.CompletionItem('TRIES');
                checkFileExistsTRIESCompletion.kind = vscode.CompletionItemKind.Field;
                checkFileExistsTRIESCompletion.insertText = new vscode.SnippetString("TRIES = \"${1}\"");
                checkFileExistsTRIESCompletion.documentation = new vscode.MarkdownString('Anzahl Versuche (ganzahlig), die nach der Datei gesucht werden soll.');
                items.push(checkFileExistsTRIESCompletion);
                const checkFileExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS_BETWEEN_TRIES');
                checkFileExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion.kind = vscode.CompletionItemKind.Field;
                checkFileExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS_BETWEEN_TRIES = \"${1}\"");
                checkFileExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion.documentation = new vscode.MarkdownString('Wartezeit, nachdem die Datei nicht gefunden wurde in Millisekunden.');
                items.push(checkFileExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion);
            }
            if (/.*\s*checkIfFileExists\s*\(.*/.test(linePrefix)) {
                const checkIfFileExistsFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                checkIfFileExistsFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkIfFileExistsFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                checkIfFileExistsFILENAMECompletion.documentation = new vscode.MarkdownString('Vollst\u00E4ndiger Dateipfad.');
                items.push(checkIfFileExistsFILENAMECompletion);
                const checkIfFileExistsMIN_SIZE_BYTESCompletion = new vscode.CompletionItem('MIN_SIZE_BYTES');
                checkIfFileExistsMIN_SIZE_BYTESCompletion.kind = vscode.CompletionItemKind.Field;
                checkIfFileExistsMIN_SIZE_BYTESCompletion.insertText = new vscode.SnippetString("MIN_SIZE_BYTES = \"${1}\"");
                checkIfFileExistsMIN_SIZE_BYTESCompletion.documentation = new vscode.MarkdownString('Minimale Dateigr\u00F6\u00DFe in Bytes, die gepr\u00FCft werden soll');
                items.push(checkIfFileExistsMIN_SIZE_BYTESCompletion);
            }
            if (/.*\s*checkIfStorageVariableIsSet\s*\(.*/.test(linePrefix)) {
                const checkIfStorageVariableIsSetSTORAGE_VARIABLECompletion = new vscode.CompletionItem('STORAGE_VARIABLE');
                checkIfStorageVariableIsSetSTORAGE_VARIABLECompletion.kind = vscode.CompletionItemKind.Field;
                checkIfStorageVariableIsSetSTORAGE_VARIABLECompletion.insertText = new vscode.SnippetString("STORAGE_VARIABLE = \"${1}\"");
                checkIfStorageVariableIsSetSTORAGE_VARIABLECompletion.documentation = new vscode.MarkdownString('Die zu \u00FCberpr\u00FCfende Storage Variable');
                items.push(checkIfStorageVariableIsSetSTORAGE_VARIABLECompletion);
                const checkIfStorageVariableIsSetIS_EMPTYCompletion = new vscode.CompletionItem('IS_EMPTY');
                checkIfStorageVariableIsSetIS_EMPTYCompletion.kind = vscode.CompletionItemKind.Field;
                checkIfStorageVariableIsSetIS_EMPTYCompletion.insertText = new vscode.SnippetString("IS_EMPTY = \"${1}\"");
                checkIfStorageVariableIsSetIS_EMPTYCompletion.documentation = new vscode.MarkdownString('Falls true, dann \u00FCberpr\u00FCfe ob die Storage Variable leer ist.');
                items.push(checkIfStorageVariableIsSetIS_EMPTYCompletion);
            }
            if (/.*\s*checkIfWindowExists\s*\(.*/.test(linePrefix)) {
                const checkIfWindowExistsWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkIfWindowExistsWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkIfWindowExistsWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkIfWindowExistsWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(checkIfWindowExistsWINDOW_NAMECompletion);
                const checkIfWindowExistsMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                checkIfWindowExistsMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                checkIfWindowExistsMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                checkIfWindowExistsMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(checkIfWindowExistsMATCH_MODECompletion);
            }
            if (/.*\s*checkRadioButtonIsSelectableWinEle\s*\(.*/.test(linePrefix)) {
                const checkRadioButtonIsSelectableWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkRadioButtonIsSelectableWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectableWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkRadioButtonIsSelectableWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkRadioButtonIsSelectableWinEleWINDOW_NAMECompletion);
                const checkRadioButtonIsSelectableWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkRadioButtonIsSelectableWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectableWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkRadioButtonIsSelectableWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkRadioButtonIsSelectableWinElePROCESS_NAMECompletion);
                const checkRadioButtonIsSelectableWinEleRADIO_BUTTON_NAMECompletion = new vscode.CompletionItem('RADIO_BUTTON_NAME');
                checkRadioButtonIsSelectableWinEleRADIO_BUTTON_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectableWinEleRADIO_BUTTON_NAMECompletion.insertText = new vscode.SnippetString("RADIO_BUTTON_NAME = \"${1}\"");
                checkRadioButtonIsSelectableWinEleRADIO_BUTTON_NAMECompletion.documentation = new vscode.MarkdownString('Name des Radio-Buttons, der gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(checkRadioButtonIsSelectableWinEleRADIO_BUTTON_NAMECompletion);
                const checkRadioButtonIsSelectableWinEleSHOULD_BECompletion = new vscode.CompletionItem('SHOULD_BE');
                checkRadioButtonIsSelectableWinEleSHOULD_BECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectableWinEleSHOULD_BECompletion.insertText = new vscode.SnippetString("SHOULD_BE = \"${1}\"");
                checkRadioButtonIsSelectableWinEleSHOULD_BECompletion.documentation = new vscode.MarkdownString('Eigenschaft, die das Element haben sollte. Es sind die Werte \'true\' oder \'false\' m\u00F6glich.');
                items.push(checkRadioButtonIsSelectableWinEleSHOULD_BECompletion);
                const checkRadioButtonIsSelectableWinEleRADIO_BUTTON_INDEXCompletion = new vscode.CompletionItem('RADIO_BUTTON_INDEX');
                checkRadioButtonIsSelectableWinEleRADIO_BUTTON_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectableWinEleRADIO_BUTTON_INDEXCompletion.insertText = new vscode.SnippetString("RADIO_BUTTON_INDEX = \"${1}\"");
                checkRadioButtonIsSelectableWinEleRADIO_BUTTON_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Radiobuttons des Fensers bezieht.');
                items.push(checkRadioButtonIsSelectableWinEleRADIO_BUTTON_INDEXCompletion);
            }
            if (/.*\s*checkRadioButtonIsSelectedWinEle\s*\(.*/.test(linePrefix)) {
                const checkRadioButtonIsSelectedWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkRadioButtonIsSelectedWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectedWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkRadioButtonIsSelectedWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkRadioButtonIsSelectedWinEleWINDOW_NAMECompletion);
                const checkRadioButtonIsSelectedWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkRadioButtonIsSelectedWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectedWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkRadioButtonIsSelectedWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkRadioButtonIsSelectedWinElePROCESS_NAMECompletion);
                const checkRadioButtonIsSelectedWinEleRADIO_BUTTON_NAMECompletion = new vscode.CompletionItem('RADIO_BUTTON_NAME');
                checkRadioButtonIsSelectedWinEleRADIO_BUTTON_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectedWinEleRADIO_BUTTON_NAMECompletion.insertText = new vscode.SnippetString("RADIO_BUTTON_NAME = \"${1}\"");
                checkRadioButtonIsSelectedWinEleRADIO_BUTTON_NAMECompletion.documentation = new vscode.MarkdownString('Name des Radio-Buttons, der gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(checkRadioButtonIsSelectedWinEleRADIO_BUTTON_NAMECompletion);
                const checkRadioButtonIsSelectedWinEleSHOULD_BECompletion = new vscode.CompletionItem('SHOULD_BE');
                checkRadioButtonIsSelectedWinEleSHOULD_BECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectedWinEleSHOULD_BECompletion.insertText = new vscode.SnippetString("SHOULD_BE = \"${1}\"");
                checkRadioButtonIsSelectedWinEleSHOULD_BECompletion.documentation = new vscode.MarkdownString('Status, den der RadioButton haben sollte. Entweder true oder false.');
                items.push(checkRadioButtonIsSelectedWinEleSHOULD_BECompletion);
                const checkRadioButtonIsSelectedWinEleRADIO_BUTTON_INDEXCompletion = new vscode.CompletionItem('RADIO_BUTTON_INDEX');
                checkRadioButtonIsSelectedWinEleRADIO_BUTTON_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonIsSelectedWinEleRADIO_BUTTON_INDEXCompletion.insertText = new vscode.SnippetString("RADIO_BUTTON_INDEX = \"${1}\"");
                checkRadioButtonIsSelectedWinEleRADIO_BUTTON_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Radiobuttons des Fensers bezieht.');
                items.push(checkRadioButtonIsSelectedWinEleRADIO_BUTTON_INDEXCompletion);
            }
            if (/.*\s*checkRadioButtonWinEle\s*\(.*/.test(linePrefix)) {
                const checkRadioButtonWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkRadioButtonWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkRadioButtonWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkRadioButtonWinEleWINDOW_NAMECompletion);
                const checkRadioButtonWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkRadioButtonWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkRadioButtonWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkRadioButtonWinElePROCESS_NAMECompletion);
                const checkRadioButtonWinEleRADIO_BUTTON_NAMECompletion = new vscode.CompletionItem('RADIO_BUTTON_NAME');
                checkRadioButtonWinEleRADIO_BUTTON_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonWinEleRADIO_BUTTON_NAMECompletion.insertText = new vscode.SnippetString("RADIO_BUTTON_NAME = \"${1}\"");
                checkRadioButtonWinEleRADIO_BUTTON_NAMECompletion.documentation = new vscode.MarkdownString('Name des Radio-Buttons, der gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(checkRadioButtonWinEleRADIO_BUTTON_NAMECompletion);
                const checkRadioButtonWinEleRADIO_BUTTON_INDEXCompletion = new vscode.CompletionItem('RADIO_BUTTON_INDEX');
                checkRadioButtonWinEleRADIO_BUTTON_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                checkRadioButtonWinEleRADIO_BUTTON_INDEXCompletion.insertText = new vscode.SnippetString("RADIO_BUTTON_INDEX = \"${1}\"");
                checkRadioButtonWinEleRADIO_BUTTON_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Radiobuttons des Fensers bezieht.');
                items.push(checkRadioButtonWinEleRADIO_BUTTON_INDEXCompletion);
            }
            if (/.*\s*checkResultByImageCP\s*\(.*/.test(linePrefix)) {
                const checkResultByImageCPIMAGE_PATHCompletion = new vscode.CompletionItem('IMAGE_PATH');
                checkResultByImageCPIMAGE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                checkResultByImageCPIMAGE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_PATH = \"${1}\"");
                checkResultByImageCPIMAGE_PATHCompletion.documentation = new vscode.MarkdownString('Gibt den Pfad zu dem Bild relativ zu der Testset-Datei an.');
                items.push(checkResultByImageCPIMAGE_PATHCompletion);
                const checkResultByImageCPBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                checkResultByImageCPBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                checkResultByImageCPBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                checkResultByImageCPBASEDIRCompletion.documentation = new vscode.MarkdownString('Gibt das Basisverzeichnis an.');
                items.push(checkResultByImageCPBASEDIRCompletion);
            }
            if (/.*\s*checkResultByImageWin\s*\(.*/.test(linePrefix)) {
                const checkResultByImageWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkResultByImageWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkResultByImageWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkResultByImageWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(checkResultByImageWinWINDOW_NAMECompletion);
                const checkResultByImageWinIMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('IMAGE_RELATIVE_PATH');
                checkResultByImageWinIMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                checkResultByImageWinIMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_RELATIVE_PATH = \"${1}\"");
                checkResultByImageWinIMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(checkResultByImageWinIMAGE_RELATIVE_PATHCompletion);
                const checkResultByImageWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                checkResultByImageWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                checkResultByImageWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                checkResultByImageWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(checkResultByImageWinBASEDIRCompletion);
            }
            if (/.*\s*checkResultByTextWin\s*\(.*/.test(linePrefix)) {
                const checkResultByTextWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkResultByTextWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkResultByTextWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkResultByTextWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(checkResultByTextWinWINDOW_NAMECompletion);
                const checkResultByTextWinTEXT_EQUALSCompletion = new vscode.CompletionItem('TEXT_EQUALS');
                checkResultByTextWinTEXT_EQUALSCompletion.kind = vscode.CompletionItemKind.Field;
                checkResultByTextWinTEXT_EQUALSCompletion.insertText = new vscode.SnippetString("TEXT_EQUALS = \"${1}\"");
                checkResultByTextWinTEXT_EQUALSCompletion.documentation = new vscode.MarkdownString('Text, der gefunden werden muss.');
                items.push(checkResultByTextWinTEXT_EQUALSCompletion);
            }
            if (/.*\s*checkResultWeb\s*\(.*/.test(linePrefix)) {
                const checkResultWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                checkResultWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                checkResultWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                checkResultWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default: xpath.');
                items.push(checkResultWebBY_CRITERIACompletion);
                const checkResultWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                checkResultWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkResultWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                checkResultWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig von BY_CRITERIA');
                items.push(checkResultWebELEMENT_NAMECompletion);
                const checkResultWebTEXT_EQUALSCompletion = new vscode.CompletionItem('TEXT_EQUALS');
                checkResultWebTEXT_EQUALSCompletion.kind = vscode.CompletionItemKind.Field;
                checkResultWebTEXT_EQUALSCompletion.insertText = new vscode.SnippetString("TEXT_EQUALS = \"${1}\"");
                checkResultWebTEXT_EQUALSCompletion.documentation = new vscode.MarkdownString('Zu findender Text.');
                items.push(checkResultWebTEXT_EQUALSCompletion);
                const checkResultWebSEARCH_SUBSTRINGCompletion = new vscode.CompletionItem('SEARCH_SUBSTRING');
                checkResultWebSEARCH_SUBSTRINGCompletion.kind = vscode.CompletionItemKind.Field;
                checkResultWebSEARCH_SUBSTRINGCompletion.insertText = new vscode.SnippetString("SEARCH_SUBSTRING = \"${1}\"");
                checkResultWebSEARCH_SUBSTRINGCompletion.documentation = new vscode.MarkdownString('Wenn true, wird festgelegt, dass nur nach einem Teil-String im zu durchsuchenden Element gesucht werden soll.       Beim Default-Wert \'false\', muss hingegegen der komplette Text \u00FCbereinstimmen.');
                items.push(checkResultWebSEARCH_SUBSTRINGCompletion);
            }
            if (/.*\s*checkTextOnCitrixTextField\s*\(.*/.test(linePrefix)) {
                const checkTextOnCitrixTextFieldWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkTextOnCitrixTextFieldWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkTextOnCitrixTextFieldWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkTextOnCitrixTextFieldWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(checkTextOnCitrixTextFieldWINDOW_NAMECompletion);
                const checkTextOnCitrixTextFieldIMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('IMAGE_RELATIVE_PATH');
                checkTextOnCitrixTextFieldIMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                checkTextOnCitrixTextFieldIMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_RELATIVE_PATH = \"${1}\"");
                checkTextOnCitrixTextFieldIMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Relativer Pfad zum Bild des Textfeldes, das gefunden werden soll.');
                items.push(checkTextOnCitrixTextFieldIMAGE_RELATIVE_PATHCompletion);
                const checkTextOnCitrixTextFieldTEXT_EQUALSCompletion = new vscode.CompletionItem('TEXT_EQUALS');
                checkTextOnCitrixTextFieldTEXT_EQUALSCompletion.kind = vscode.CompletionItemKind.Field;
                checkTextOnCitrixTextFieldTEXT_EQUALSCompletion.insertText = new vscode.SnippetString("TEXT_EQUALS = \"${1}\"");
                checkTextOnCitrixTextFieldTEXT_EQUALSCompletion.documentation = new vscode.MarkdownString('Zu \u00DCberpr\u00FCfender Text.');
                items.push(checkTextOnCitrixTextFieldTEXT_EQUALSCompletion);
                const checkTextOnCitrixTextFieldX_ORIENTATION_TO_CLICKCompletion = new vscode.CompletionItem('X_ORIENTATION_TO_CLICK');
                checkTextOnCitrixTextFieldX_ORIENTATION_TO_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                checkTextOnCitrixTextFieldX_ORIENTATION_TO_CLICKCompletion.insertText = new vscode.SnippetString("X_ORIENTATION_TO_CLICK = \"${1}\"");
                checkTextOnCitrixTextFieldX_ORIENTATION_TO_CLICKCompletion.documentation = new vscode.MarkdownString('Verschiebung zum eigentlichen Textfeld, da in der Regel die Beschriftung des Textfeldes als Bild angegeben werden wird.');
                items.push(checkTextOnCitrixTextFieldX_ORIENTATION_TO_CLICKCompletion);
            }
            if (/.*\s*checkTextboxReadOnlyFocussedWinEle\s*\(.*/.test(linePrefix)) {
                const checkTextboxReadOnlyFocussedWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                checkTextboxReadOnlyFocussedWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkTextboxReadOnlyFocussedWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                checkTextboxReadOnlyFocussedWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(checkTextboxReadOnlyFocussedWinEleWINDOW_NAMECompletion);
                const checkTextboxReadOnlyFocussedWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                checkTextboxReadOnlyFocussedWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                checkTextboxReadOnlyFocussedWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                checkTextboxReadOnlyFocussedWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(checkTextboxReadOnlyFocussedWinElePROCESS_NAMECompletion);
                const checkTextboxReadOnlyFocussedWinEleSHOULD_BECompletion = new vscode.CompletionItem('SHOULD_BE');
                checkTextboxReadOnlyFocussedWinEleSHOULD_BECompletion.kind = vscode.CompletionItemKind.Field;
                checkTextboxReadOnlyFocussedWinEleSHOULD_BECompletion.insertText = new vscode.SnippetString("SHOULD_BE = \"${1}\"");
                checkTextboxReadOnlyFocussedWinEleSHOULD_BECompletion.documentation = new vscode.MarkdownString('Eigenschaft, die das Element haben sollte. Es sind die Werte \'true\' oder \'false\' m\u00F6glich.');
                items.push(checkTextboxReadOnlyFocussedWinEleSHOULD_BECompletion);
            }
            if (/.*\s*clearFullscreenImageRenderer\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*clearOverlayImageRenderer\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*clearStorage\s*\(.*/.test(linePrefix)) {
                const clearStorageKEYS_TO_KEEPCompletion = new vscode.CompletionItem('KEYS_TO_KEEP');
                clearStorageKEYS_TO_KEEPCompletion.kind = vscode.CompletionItemKind.Field;
                clearStorageKEYS_TO_KEEPCompletion.insertText = new vscode.SnippetString("KEYS_TO_KEEP = \"${1}\"");
                clearStorageKEYS_TO_KEEPCompletion.documentation = new vscode.MarkdownString('Optionale komma-separierte Liste von Schl\u00FCsseln, deren zugeh\u00F6rige Eintr\u00E4ge nicht gel\u00F6scht werden sollen.');
                items.push(clearStorageKEYS_TO_KEEPCompletion);
            }
            if (/.*\s*clearStorageValue\s*\(.*/.test(linePrefix)) {
                const clearStorageValueTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                clearStorageValueTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                clearStorageValueTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                clearStorageValueTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Zu l\u00F6schender Schl\u00FCssel');
                items.push(clearStorageValueTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*clearTextRenderer\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*clearTextWeb\s*\(.*/.test(linePrefix)) {
                const clearTextWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                clearTextWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                clearTextWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                clearTextWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(clearTextWebBY_CRITERIACompletion);
                const clearTextWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                clearTextWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clearTextWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                clearTextWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des zu leerenden Elements, abh\u00E4ngig vom Kriterium.');
                items.push(clearTextWebELEMENT_NAMECompletion);
            }
            if (/.*\s*clickButtonAutomIdWinEle\s*\(.*/.test(linePrefix)) {
                const clickButtonAutomIdWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickButtonAutomIdWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickButtonAutomIdWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickButtonAutomIdWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(clickButtonAutomIdWinEleWINDOW_NAMECompletion);
                const clickButtonAutomIdWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                clickButtonAutomIdWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickButtonAutomIdWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                clickButtonAutomIdWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(clickButtonAutomIdWinElePROCESS_NAMECompletion);
                const clickButtonAutomIdWinEleBUTTON_AUTOMATION_IDCompletion = new vscode.CompletionItem('BUTTON_AUTOMATION_ID');
                clickButtonAutomIdWinEleBUTTON_AUTOMATION_IDCompletion.kind = vscode.CompletionItemKind.Field;
                clickButtonAutomIdWinEleBUTTON_AUTOMATION_IDCompletion.insertText = new vscode.SnippetString("BUTTON_AUTOMATION_ID = \"${1}\"");
                clickButtonAutomIdWinEleBUTTON_AUTOMATION_IDCompletion.documentation = new vscode.MarkdownString('Automation-ID des Buttons, der gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diese zu ermitteln.');
                items.push(clickButtonAutomIdWinEleBUTTON_AUTOMATION_IDCompletion);
            }
            if (/.*\s*clickButtonWinEle\s*\(.*/.test(linePrefix)) {
                const clickButtonWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickButtonWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickButtonWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickButtonWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(clickButtonWinEleWINDOW_NAMECompletion);
                const clickButtonWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                clickButtonWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickButtonWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                clickButtonWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(clickButtonWinElePROCESS_NAMECompletion);
                const clickButtonWinEleBUTTON_NAMECompletion = new vscode.CompletionItem('BUTTON_NAME');
                clickButtonWinEleBUTTON_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickButtonWinEleBUTTON_NAMECompletion.insertText = new vscode.SnippetString("BUTTON_NAME = \"${1}\"");
                clickButtonWinEleBUTTON_NAMECompletion.documentation = new vscode.MarkdownString('Name des Buttons, der gesteuert werden soll. Dieser ist h\u00E4ufig identisch mit seinem Text (z.B. \'OK\'). Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen Namen zu ermitteln.');
                items.push(clickButtonWinEleBUTTON_NAMECompletion);
            }
            if (/.*\s*clickByIdWeb\s*\(.*/.test(linePrefix)) {
                const clickByIdWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                clickByIdWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickByIdWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                clickByIdWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Inhalt der id');
                items.push(clickByIdWebELEMENT_NAMECompletion);
                const clickByIdWebMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                clickByIdWebMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                clickByIdWebMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                clickByIdWebMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{right, left} Gibt an, ob es sich um einen Links- oder Rechtsklick handelt. Default ist links');
                items.push(clickByIdWebMOUSE_BUTTONCompletion);
            }
            if (/.*\s*clickByTextJava\s*\(.*/.test(linePrefix)) {
                const clickByTextJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                clickByTextJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                clickByTextJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(clickByTextJavaTARGETCompletion);
                const clickByTextJavaIS_DOUBLE_CLICKCompletion = new vscode.CompletionItem('IS_DOUBLE_CLICK');
                clickByTextJavaIS_DOUBLE_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextJavaIS_DOUBLE_CLICKCompletion.insertText = new vscode.SnippetString("IS_DOUBLE_CLICK = \"${1}\"");
                clickByTextJavaIS_DOUBLE_CLICKCompletion.documentation = new vscode.MarkdownString('Gibt an, ob ein Doppelklick get\u00E4tigt werden soll.');
                items.push(clickByTextJavaIS_DOUBLE_CLICKCompletion);
                const clickByTextJavaIS_RIGHT_CLICKCompletion = new vscode.CompletionItem('IS_RIGHT_CLICK');
                clickByTextJavaIS_RIGHT_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextJavaIS_RIGHT_CLICKCompletion.insertText = new vscode.SnippetString("IS_RIGHT_CLICK = \"${1}\"");
                clickByTextJavaIS_RIGHT_CLICKCompletion.documentation = new vscode.MarkdownString('Gibt an, ob die rechte Maustaste, anstatt der linken verwendet werden soll.');
                items.push(clickByTextJavaIS_RIGHT_CLICKCompletion);
                const clickByTextJavaCHECK_CONTAINSCompletion = new vscode.CompletionItem('CHECK_CONTAINS');
                clickByTextJavaCHECK_CONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextJavaCHECK_CONTAINSCompletion.insertText = new vscode.SnippetString("CHECK_CONTAINS = \"${1}\"");
                clickByTextJavaCHECK_CONTAINSCompletion.documentation = new vscode.MarkdownString('True, falls eine Zeichenreihenfolge eine Teilzeichenfolge enth\u00E4lt');
                items.push(clickByTextJavaCHECK_CONTAINSCompletion);
                const clickByTextJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                clickByTextJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                clickByTextJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(clickByTextJavaWAIT_MILLISCompletion);
                const clickByTextJavaX_OFFSETCompletion = new vscode.CompletionItem('X_OFFSET');
                clickByTextJavaX_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextJavaX_OFFSETCompletion.insertText = new vscode.SnippetString("X_OFFSET = \"${1}\"");
                clickByTextJavaX_OFFSETCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach rechts (positiv) oder links (negativ)');
                items.push(clickByTextJavaX_OFFSETCompletion);
                const clickByTextJavaY_OFFSETCompletion = new vscode.CompletionItem('Y_OFFSET');
                clickByTextJavaY_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextJavaY_OFFSETCompletion.insertText = new vscode.SnippetString("Y_OFFSET = \"${1}\"");
                clickByTextJavaY_OFFSETCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach unten (positiv) oder oben (negativ)');
                items.push(clickByTextJavaY_OFFSETCompletion);
            }
            if (/.*\s*clickByTextWeb\s*\(.*/.test(linePrefix)) {
                const clickByTextWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                clickByTextWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                clickByTextWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Inhalt des linktext.');
                items.push(clickByTextWebELEMENT_NAMECompletion);
                const clickByTextWebMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                clickByTextWebMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                clickByTextWebMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                clickByTextWebMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{right, left} Gibt an, ob es sich um einen Links- oder Rechtsklick handelt. Default ist links');
                items.push(clickByTextWebMOUSE_BUTTONCompletion);
            }
            if (/.*\s*clickCoordinateWin\s*\(.*/.test(linePrefix)) {
                const clickCoordinateWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickCoordinateWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickCoordinateWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickCoordinateWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(clickCoordinateWinWINDOW_NAMECompletion);
                const clickCoordinateWinXCompletion = new vscode.CompletionItem('X');
                clickCoordinateWinXCompletion.kind = vscode.CompletionItemKind.Field;
                clickCoordinateWinXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                clickCoordinateWinXCompletion.documentation = new vscode.MarkdownString('X-Koordinate des anzuklickenden Punktes');
                items.push(clickCoordinateWinXCompletion);
                const clickCoordinateWinYCompletion = new vscode.CompletionItem('Y');
                clickCoordinateWinYCompletion.kind = vscode.CompletionItemKind.Field;
                clickCoordinateWinYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                clickCoordinateWinYCompletion.documentation = new vscode.MarkdownString('X-Koordinate des anzuklickenden Punktes');
                items.push(clickCoordinateWinYCompletion);
                const clickCoordinateWinMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                clickCoordinateWinMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                clickCoordinateWinMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                clickCoordinateWinMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{links,rechts} links ist default, muss daher nicht angegeben werden.');
                items.push(clickCoordinateWinMOUSE_BUTTONCompletion);
            }
            if (/.*\s*clickCursorWin\s*\(.*/.test(linePrefix)) {
                const clickCursorWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickCursorWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickCursorWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickCursorWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(clickCursorWinWINDOW_NAMECompletion);
                const clickCursorWinMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                clickCursorWinMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                clickCursorWinMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                clickCursorWinMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{links,rechts} links ist default, muss daher nicht angegeben werden.');
                items.push(clickCursorWinMOUSE_BUTTONCompletion);
            }
            if (/.*\s*clickImageCP\s*\(.*/.test(linePrefix)) {
                const clickImageCPIMAGE_PATHCompletion = new vscode.CompletionItem('IMAGE_PATH');
                clickImageCPIMAGE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageCPIMAGE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_PATH = \"${1}\"");
                clickImageCPIMAGE_PATHCompletion.documentation = new vscode.MarkdownString('Gibt den Pfad zu dem Bild relativ zu der Testset-Datei an.');
                items.push(clickImageCPIMAGE_PATHCompletion);
                const clickImageCPBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                clickImageCPBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageCPBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                clickImageCPBASEDIRCompletion.documentation = new vscode.MarkdownString('Gibt das Basisverzeichnis an.');
                items.push(clickImageCPBASEDIRCompletion);
                const clickImageCPOFFSET_XCompletion = new vscode.CompletionItem('OFFSET_X');
                clickImageCPOFFSET_XCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageCPOFFSET_XCompletion.insertText = new vscode.SnippetString("OFFSET_X = \"${1}\"");
                clickImageCPOFFSET_XCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach rechts (positiv) oder links (negativ)');
                items.push(clickImageCPOFFSET_XCompletion);
                const clickImageCPOFFSET_YCompletion = new vscode.CompletionItem('OFFSET_Y');
                clickImageCPOFFSET_YCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageCPOFFSET_YCompletion.insertText = new vscode.SnippetString("OFFSET_Y = \"${1}\"");
                clickImageCPOFFSET_YCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach unten (positiv) oder oben (negativ)');
                items.push(clickImageCPOFFSET_YCompletion);
            }
            if (/.*\s*clickImageWin\s*\(.*/.test(linePrefix)) {
                const clickImageWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickImageWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickImageWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickImageWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(clickImageWinWINDOW_NAMECompletion);
                const clickImageWinIMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('IMAGE_RELATIVE_PATH');
                clickImageWinIMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageWinIMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_RELATIVE_PATH = \"${1}\"");
                clickImageWinIMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(clickImageWinIMAGE_RELATIVE_PATHCompletion);
                const clickImageWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                clickImageWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                clickImageWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(clickImageWinBASEDIRCompletion);
                const clickImageWinMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                clickImageWinMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageWinMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                clickImageWinMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{links,rechts} links ist default, muss daher nicht angegeben werden.');
                items.push(clickImageWinMOUSE_BUTTONCompletion);
                const clickImageWinRELATIVE_XCompletion = new vscode.CompletionItem('RELATIVE_X');
                clickImageWinRELATIVE_XCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageWinRELATIVE_XCompletion.insertText = new vscode.SnippetString("RELATIVE_X = \"${1}\"");
                clickImageWinRELATIVE_XCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der X-Achse. Links: Negativ. Rechts: Positiv');
                items.push(clickImageWinRELATIVE_XCompletion);
                const clickImageWinRELATIVE_YCompletion = new vscode.CompletionItem('RELATIVE_Y');
                clickImageWinRELATIVE_YCompletion.kind = vscode.CompletionItemKind.Field;
                clickImageWinRELATIVE_YCompletion.insertText = new vscode.SnippetString("RELATIVE_Y = \"${1}\"");
                clickImageWinRELATIVE_YCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der Y-Achse. Oben: Negativ. Unten: Positiv');
                items.push(clickImageWinRELATIVE_YCompletion);
            }
            if (/.*\s*clickItemByTextJava\s*\(.*/.test(linePrefix)) {
                const clickItemByTextJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                clickItemByTextJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                clickItemByTextJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(clickItemByTextJavaTARGETCompletion);
                const clickItemByTextJavaIS_DOUBLE_CLICKCompletion = new vscode.CompletionItem('IS_DOUBLE_CLICK');
                clickItemByTextJavaIS_DOUBLE_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaIS_DOUBLE_CLICKCompletion.insertText = new vscode.SnippetString("IS_DOUBLE_CLICK = \"${1}\"");
                clickItemByTextJavaIS_DOUBLE_CLICKCompletion.documentation = new vscode.MarkdownString('Gibt an, ob ein Doppelklick get\u00E4tigt werden soll.');
                items.push(clickItemByTextJavaIS_DOUBLE_CLICKCompletion);
                const clickItemByTextJavaIS_RIGHT_CLICKCompletion = new vscode.CompletionItem('IS_RIGHT_CLICK');
                clickItemByTextJavaIS_RIGHT_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaIS_RIGHT_CLICKCompletion.insertText = new vscode.SnippetString("IS_RIGHT_CLICK = \"${1}\"");
                clickItemByTextJavaIS_RIGHT_CLICKCompletion.documentation = new vscode.MarkdownString('Gibt an, ob die rechte Maustaste, anstatt der linken verwendet werden soll.');
                items.push(clickItemByTextJavaIS_RIGHT_CLICKCompletion);
                const clickItemByTextJavaTEXTCompletion = new vscode.CompletionItem('TEXT');
                clickItemByTextJavaTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                clickItemByTextJavaTEXTCompletion.documentation = new vscode.MarkdownString('Text, welcher in dem Element geklickt werden soll');
                items.push(clickItemByTextJavaTEXTCompletion);
                const clickItemByTextJavaOFFSETCompletion = new vscode.CompletionItem('OFFSET');
                clickItemByTextJavaOFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaOFFSETCompletion.insertText = new vscode.SnippetString("OFFSET = \"${1}\"");
                clickItemByTextJavaOFFSETCompletion.documentation = new vscode.MarkdownString('Offset falls mehrere Elemente existieren');
                items.push(clickItemByTextJavaOFFSETCompletion);
                const clickItemByTextJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                clickItemByTextJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                clickItemByTextJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(clickItemByTextJavaWAIT_MILLISCompletion);
                const clickItemByTextJavaX_OFFSETCompletion = new vscode.CompletionItem('X_OFFSET');
                clickItemByTextJavaX_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaX_OFFSETCompletion.insertText = new vscode.SnippetString("X_OFFSET = \"${1}\"");
                clickItemByTextJavaX_OFFSETCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach rechts (positiv) oder links (negativ)');
                items.push(clickItemByTextJavaX_OFFSETCompletion);
                const clickItemByTextJavaY_OFFSETCompletion = new vscode.CompletionItem('Y_OFFSET');
                clickItemByTextJavaY_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaY_OFFSETCompletion.insertText = new vscode.SnippetString("Y_OFFSET = \"${1}\"");
                clickItemByTextJavaY_OFFSETCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach unten (positiv) oder oben (negativ)');
                items.push(clickItemByTextJavaY_OFFSETCompletion);
                const clickItemByTextJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                clickItemByTextJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                clickItemByTextJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(clickItemByTextJavaBY_NAMECompletion);
                const clickItemByTextJavaCONTAINSCompletion = new vscode.CompletionItem('CONTAINS');
                clickItemByTextJavaCONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                clickItemByTextJavaCONTAINSCompletion.insertText = new vscode.SnippetString("CONTAINS = \"${1}\"");
                clickItemByTextJavaCONTAINSCompletion.documentation = new vscode.MarkdownString('True, falls eine Zeichenreihenfolge eine Teilzeichenfolge enth\u00E4lt');
                items.push(clickItemByTextJavaCONTAINSCompletion);
            }
            if (/.*\s*clickJava\s*\(.*/.test(linePrefix)) {
                const clickJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                clickJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                clickJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                clickJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(clickJavaTARGETCompletion);
                const clickJavaIS_DOUBLE_CLICKCompletion = new vscode.CompletionItem('IS_DOUBLE_CLICK');
                clickJavaIS_DOUBLE_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                clickJavaIS_DOUBLE_CLICKCompletion.insertText = new vscode.SnippetString("IS_DOUBLE_CLICK = \"${1}\"");
                clickJavaIS_DOUBLE_CLICKCompletion.documentation = new vscode.MarkdownString('Gibt an, ob ein Doppelklick get\u00E4tigt werden soll.');
                items.push(clickJavaIS_DOUBLE_CLICKCompletion);
                const clickJavaIS_RIGHT_CLICKCompletion = new vscode.CompletionItem('IS_RIGHT_CLICK');
                clickJavaIS_RIGHT_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                clickJavaIS_RIGHT_CLICKCompletion.insertText = new vscode.SnippetString("IS_RIGHT_CLICK = \"${1}\"");
                clickJavaIS_RIGHT_CLICKCompletion.documentation = new vscode.MarkdownString('Gibt an, ob die rechte Maustaste, anstatt der linken verwendet werden soll.');
                items.push(clickJavaIS_RIGHT_CLICKCompletion);
                const clickJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                clickJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                clickJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                clickJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(clickJavaWAIT_MILLISCompletion);
                const clickJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                clickJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                clickJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(clickJavaBY_NAMECompletion);
                const clickJavaX_OFFSETCompletion = new vscode.CompletionItem('X_OFFSET');
                clickJavaX_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                clickJavaX_OFFSETCompletion.insertText = new vscode.SnippetString("X_OFFSET = \"${1}\"");
                clickJavaX_OFFSETCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach rechts (positiv) oder links (negativ)');
                items.push(clickJavaX_OFFSETCompletion);
                const clickJavaY_OFFSETCompletion = new vscode.CompletionItem('Y_OFFSET');
                clickJavaY_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                clickJavaY_OFFSETCompletion.insertText = new vscode.SnippetString("Y_OFFSET = \"${1}\"");
                clickJavaY_OFFSETCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach unten (positiv) oder oben (negativ)');
                items.push(clickJavaY_OFFSETCompletion);
            }
            if (/.*\s*clickMenuAutomIdWinEle\s*\(.*/.test(linePrefix)) {
                const clickMenuAutomIdWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickMenuAutomIdWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuAutomIdWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickMenuAutomIdWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(clickMenuAutomIdWinEleWINDOW_NAMECompletion);
                const clickMenuAutomIdWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                clickMenuAutomIdWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuAutomIdWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                clickMenuAutomIdWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(clickMenuAutomIdWinElePROCESS_NAMECompletion);
                const clickMenuAutomIdWinEleMENUBAR_NAMECompletion = new vscode.CompletionItem('MENUBAR_NAME');
                clickMenuAutomIdWinEleMENUBAR_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuAutomIdWinEleMENUBAR_NAMECompletion.insertText = new vscode.SnippetString("MENUBAR_NAME = \"${1}\"");
                clickMenuAutomIdWinEleMENUBAR_NAMECompletion.documentation = new vscode.MarkdownString('Name der Men\u00FC-Leiste, die gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen Namen zu ermitteln.');
                items.push(clickMenuAutomIdWinEleMENUBAR_NAMECompletion);
                const clickMenuAutomIdWinEleMENU_AUTOMATION_IDCompletion = new vscode.CompletionItem('MENU_AUTOMATION_ID');
                clickMenuAutomIdWinEleMENU_AUTOMATION_IDCompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuAutomIdWinEleMENU_AUTOMATION_IDCompletion.insertText = new vscode.SnippetString("MENU_AUTOMATION_ID = \"${1}\"");
                clickMenuAutomIdWinEleMENU_AUTOMATION_IDCompletion.documentation = new vscode.MarkdownString('Automation-ID des Men\u00FCpunktes, der gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diese zu ermitteln.');
                items.push(clickMenuAutomIdWinEleMENU_AUTOMATION_IDCompletion);
                const clickMenuAutomIdWinEleMENU_ITEM_AUTOMATION_IDCompletion = new vscode.CompletionItem('MENU_ITEM_AUTOMATION_ID');
                clickMenuAutomIdWinEleMENU_ITEM_AUTOMATION_IDCompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuAutomIdWinEleMENU_ITEM_AUTOMATION_IDCompletion.insertText = new vscode.SnippetString("MENU_ITEM_AUTOMATION_ID = \"${1}\"");
                clickMenuAutomIdWinEleMENU_ITEM_AUTOMATION_IDCompletion.documentation = new vscode.MarkdownString('Automation-ID des Untermen\u00FC-Punktes, der gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diese zu ermitteln.');
                items.push(clickMenuAutomIdWinEleMENU_ITEM_AUTOMATION_IDCompletion);
            }
            if (/.*\s*clickMenuWinEle\s*\(.*/.test(linePrefix)) {
                const clickMenuWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickMenuWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickMenuWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(clickMenuWinEleWINDOW_NAMECompletion);
                const clickMenuWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                clickMenuWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                clickMenuWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(clickMenuWinElePROCESS_NAMECompletion);
                const clickMenuWinEleMENUBAR_NAMECompletion = new vscode.CompletionItem('MENUBAR_NAME');
                clickMenuWinEleMENUBAR_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWinEleMENUBAR_NAMECompletion.insertText = new vscode.SnippetString("MENUBAR_NAME = \"${1}\"");
                clickMenuWinEleMENUBAR_NAMECompletion.documentation = new vscode.MarkdownString('Name der Men\u00FC-Leiste, die gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen Namen zu ermitteln.');
                items.push(clickMenuWinEleMENUBAR_NAMECompletion);
                const clickMenuWinEleMENU_NAMECompletion = new vscode.CompletionItem('MENU_NAME');
                clickMenuWinEleMENU_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWinEleMENU_NAMECompletion.insertText = new vscode.SnippetString("MENU_NAME = \"${1}\"");
                clickMenuWinEleMENU_NAMECompletion.documentation = new vscode.MarkdownString('Name des Men\u00FC-Punktes, der gesteuert werden soll. Dieser ist h\u00E4ufig identisch mit seinem Text (z.B. \'Datei\'). Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen Namen zu ermitteln.');
                items.push(clickMenuWinEleMENU_NAMECompletion);
                const clickMenuWinEleMENU_ITEM_NAMECompletion = new vscode.CompletionItem('MENU_ITEM_NAME');
                clickMenuWinEleMENU_ITEM_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWinEleMENU_ITEM_NAMECompletion.insertText = new vscode.SnippetString("MENU_ITEM_NAME = \"${1}\"");
                clickMenuWinEleMENU_ITEM_NAMECompletion.documentation = new vscode.MarkdownString('Name des Untermen\u00FC-Punktes, der gesteuert werden soll. Dieser ist h\u00E4ufig identisch mit seinem Text (z.B. \'Speichern\'). Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen Namen zu ermitteln.');
                items.push(clickMenuWinEleMENU_ITEM_NAMECompletion);
            }
            if (/.*\s*clickMenuWindowWin\s*\(.*/.test(linePrefix)) {
                const clickMenuWindowWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickMenuWindowWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWindowWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickMenuWindowWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(clickMenuWindowWinWINDOW_NAMECompletion);
                const clickMenuWindowWinMENU_IMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('MENU_IMAGE_RELATIVE_PATH');
                clickMenuWindowWinMENU_IMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWindowWinMENU_IMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("MENU_IMAGE_RELATIVE_PATH = \"${1}\"");
                clickMenuWindowWinMENU_IMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Relativer Pfad zum Men\u00FC-Bild');
                items.push(clickMenuWindowWinMENU_IMAGE_RELATIVE_PATHCompletion);
                const clickMenuWindowWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                clickMenuWindowWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWindowWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                clickMenuWindowWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(clickMenuWindowWinBASEDIRCompletion);
                const clickMenuWindowWinWAIT_TIME_BETWEEN_CLICKSCompletion = new vscode.CompletionItem('WAIT_TIME_BETWEEN_CLICKS');
                clickMenuWindowWinWAIT_TIME_BETWEEN_CLICKSCompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWindowWinWAIT_TIME_BETWEEN_CLICKSCompletion.insertText = new vscode.SnippetString("WAIT_TIME_BETWEEN_CLICKS = \"${1}\"");
                clickMenuWindowWinWAIT_TIME_BETWEEN_CLICKSCompletion.documentation = new vscode.MarkdownString('Wartezeit zwischen Klick auf Men\u00FC-Bild und Untermen\u00FCpunkt-Bild');
                items.push(clickMenuWindowWinWAIT_TIME_BETWEEN_CLICKSCompletion);
                const clickMenuWindowWinMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                clickMenuWindowWinMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWindowWinMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                clickMenuWindowWinMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{links,rechts} links ist default, muss daher nicht angegeben werden.');
                items.push(clickMenuWindowWinMOUSE_BUTTONCompletion);
                const clickMenuWindowWinSUBMENU_IMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('SUBMENU_IMAGE_RELATIVE_PATH');
                clickMenuWindowWinSUBMENU_IMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                clickMenuWindowWinSUBMENU_IMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("SUBMENU_IMAGE_RELATIVE_PATH = \"${1}\"");
                clickMenuWindowWinSUBMENU_IMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Relativer Pfad zum Untermen\u00FCpunkt-Bild');
                items.push(clickMenuWindowWinSUBMENU_IMAGE_RELATIVE_PATHCompletion);
            }
            if (/.*\s*clickTabWinEle\s*\(.*/.test(linePrefix)) {
                const clickTabWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                clickTabWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickTabWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                clickTabWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(clickTabWinElePROCESS_NAMECompletion);
                const clickTabWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickTabWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickTabWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickTabWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(clickTabWinEleWINDOW_NAMECompletion);
                const clickTabWinEleTAB_NAMECompletion = new vscode.CompletionItem('TAB_NAME');
                clickTabWinEleTAB_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickTabWinEleTAB_NAMECompletion.insertText = new vscode.SnippetString("TAB_NAME = \"${1}\"");
                clickTabWinEleTAB_NAMECompletion.documentation = new vscode.MarkdownString('Name des Tabs, das ausgew\u00E4hlt werden soll. Dieser ist h\u00E4ufig identisch mit seinem Text (z.B. \'OK\'). Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen Namen zu ermitteln.');
                items.push(clickTabWinEleTAB_NAMECompletion);
            }
            if (/.*\s*clickTextInPicture\s*\(.*/.test(linePrefix)) {
                const clickTextInPictureWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                clickTextInPictureWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                clickTextInPictureWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters');
                items.push(clickTextInPictureWINDOW_NAMECompletion);
                const clickTextInPictureFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                clickTextInPictureFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                clickTextInPictureFILENAMECompletion.documentation = new vscode.MarkdownString('Name der Bilddatei, die untersucht werden soll. Wenn keine Bilddatei angegeben wird, wird der Zwischenspeicher nach Bilddaten durchsucht. Ist auch hier kein Bild vorhanden, wird ein Screenshot erstellt.');
                items.push(clickTextInPictureFILENAMECompletion);
                const clickTextInPictureBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                clickTextInPictureBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                clickTextInPictureBASEDIRCompletion.documentation = new vscode.MarkdownString('Gibt das Basisverzeichnis an.');
                items.push(clickTextInPictureBASEDIRCompletion);
                const clickTextInPictureTEXT_TO_CLICKCompletion = new vscode.CompletionItem('TEXT_TO_CLICK');
                clickTextInPictureTEXT_TO_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureTEXT_TO_CLICKCompletion.insertText = new vscode.SnippetString("TEXT_TO_CLICK = \"${1}\"");
                clickTextInPictureTEXT_TO_CLICKCompletion.documentation = new vscode.MarkdownString('Text der gesucht werden und dessen Position angeklickt werden soll');
                items.push(clickTextInPictureTEXT_TO_CLICKCompletion);
                const clickTextInPictureX1Completion = new vscode.CompletionItem('X1');
                clickTextInPictureX1Completion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureX1Completion.insertText = new vscode.SnippetString("X1 = \"${1}\"");
                clickTextInPictureX1Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: X-Koordinate der linken oberen Ecke.');
                items.push(clickTextInPictureX1Completion);
                const clickTextInPictureY1Completion = new vscode.CompletionItem('Y1');
                clickTextInPictureY1Completion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureY1Completion.insertText = new vscode.SnippetString("Y1 = \"${1}\"");
                clickTextInPictureY1Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: Y-Koordinate der linken oberen Ecke.');
                items.push(clickTextInPictureY1Completion);
                const clickTextInPictureX2Completion = new vscode.CompletionItem('X2');
                clickTextInPictureX2Completion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureX2Completion.insertText = new vscode.SnippetString("X2 = \"${1}\"");
                clickTextInPictureX2Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: X-Koordinate der rechten unteren Ecke.');
                items.push(clickTextInPictureX2Completion);
                const clickTextInPictureY2Completion = new vscode.CompletionItem('Y2');
                clickTextInPictureY2Completion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureY2Completion.insertText = new vscode.SnippetString("Y2 = \"${1}\"");
                clickTextInPictureY2Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: Y-Koordinate der rechten unteren Ecke.');
                items.push(clickTextInPictureY2Completion);
                const clickTextInPictureOCR_IMPLEMENTATIONCompletion = new vscode.CompletionItem('OCR_IMPLEMENTATION');
                clickTextInPictureOCR_IMPLEMENTATIONCompletion.kind = vscode.CompletionItemKind.Field;
                clickTextInPictureOCR_IMPLEMENTATIONCompletion.insertText = new vscode.SnippetString("OCR_IMPLEMENTATION = \"${1}\"");
                clickTextInPictureOCR_IMPLEMENTATIONCompletion.documentation = new vscode.MarkdownString('Wahl der verwendeten OCR Implementierung. GCP oder TESSERACT.');
                items.push(clickTextInPictureOCR_IMPLEMENTATIONCompletion);
            }
            if (/.*\s*clickWeb\s*\(.*/.test(linePrefix)) {
                const clickWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                clickWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                clickWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                clickWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(clickWebBY_CRITERIACompletion);
                const clickWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                clickWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                clickWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(clickWebELEMENT_NAMECompletion);
                const clickWebNEXT_ELEMENT_BY_CRITERIACompletion = new vscode.CompletionItem('NEXT_ELEMENT_BY_CRITERIA');
                clickWebNEXT_ELEMENT_BY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                clickWebNEXT_ELEMENT_BY_CRITERIACompletion.insertText = new vscode.SnippetString("NEXT_ELEMENT_BY_CRITERIA = \"${1}\"");
                clickWebNEXT_ELEMENT_BY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das n\u00E4chste Element ermittelt werden soll.');
                items.push(clickWebNEXT_ELEMENT_BY_CRITERIACompletion);
                const clickWebNEXT_ELEMENT_NAMECompletion = new vscode.CompletionItem('NEXT_ELEMENT_NAME');
                clickWebNEXT_ELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickWebNEXT_ELEMENT_NAMECompletion.insertText = new vscode.SnippetString("NEXT_ELEMENT_NAME = \"${1}\"");
                clickWebNEXT_ELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Name des n\u00E4chsten Elements, das nach dem Klicken auf das eigentliche Element verf\u00FCgbar sein soll.');
                items.push(clickWebNEXT_ELEMENT_NAMECompletion);
                const clickWebMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                clickWebMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                clickWebMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                clickWebMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{right, left} Gibt an, ob es sich um einen Links- oder Rechtsklick handelt. Default ist links');
                items.push(clickWebMOUSE_BUTTONCompletion);
            }
            if (/.*\s*clickWebFast\s*\(.*/.test(linePrefix)) {
                const clickWebFastBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                clickWebFastBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                clickWebFastBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                clickWebFastBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(clickWebFastBY_CRITERIACompletion);
                const clickWebFastELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                clickWebFastELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                clickWebFastELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                clickWebFastELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(clickWebFastELEMENT_NAMECompletion);
                const clickWebFastNO_VISIBILITY_CHECKCompletion = new vscode.CompletionItem('NO_VISIBILITY_CHECK');
                clickWebFastNO_VISIBILITY_CHECKCompletion.kind = vscode.CompletionItemKind.Field;
                clickWebFastNO_VISIBILITY_CHECKCompletion.insertText = new vscode.SnippetString("NO_VISIBILITY_CHECK = \"${1}\"");
                clickWebFastNO_VISIBILITY_CHECKCompletion.documentation = new vscode.MarkdownString('Wenn true, wird vor dem Klick nicht \u00FCberpr\u00FCft ob (bzw. gewartet bis) das Element sichtbar ist (Default: false)');
                items.push(clickWebFastNO_VISIBILITY_CHECKCompletion);
            }
            if (/.*\s*closeApplication\s*\(.*/.test(linePrefix)) {
                const closeApplicationTITLECompletion = new vscode.CompletionItem('TITLE');
                closeApplicationTITLECompletion.kind = vscode.CompletionItemKind.Field;
                closeApplicationTITLECompletion.insertText = new vscode.SnippetString("TITLE = \"${1}\"");
                closeApplicationTITLECompletion.documentation = new vscode.MarkdownString('Titel des zu beendenden Fensters');
                items.push(closeApplicationTITLECompletion);
            }
            if (/.*\s*closeApplicationCP\s*\(.*/.test(linePrefix)) {
                const closeApplicationCPWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                closeApplicationCPWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                closeApplicationCPWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                closeApplicationCPWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des zu schlie\u00DFenden Fensters.');
                items.push(closeApplicationCPWINDOW_NAMECompletion);
            }
            if (/.*\s*closeApplicationWin\s*\(.*/.test(linePrefix)) {
                const closeApplicationWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                closeApplicationWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                closeApplicationWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                closeApplicationWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(closeApplicationWinWINDOW_NAMECompletion);
                const closeApplicationWinMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                closeApplicationWinMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                closeApplicationWinMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                closeApplicationWinMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(closeApplicationWinMATCH_MODECompletion);
            }
            if (/.*\s*closeApplicationWinEle\s*\(.*/.test(linePrefix)) {
                const closeApplicationWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                closeApplicationWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                closeApplicationWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                closeApplicationWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(closeApplicationWinEleWINDOW_NAMECompletion);
                const closeApplicationWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                closeApplicationWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                closeApplicationWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                closeApplicationWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(closeApplicationWinElePROCESS_NAMECompletion);
            }
            if (/.*\s*closeSql\s*\(.*/.test(linePrefix)) {
                const closeSqlCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                closeSqlCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                closeSqlCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                closeSqlCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der bestehenden Datenbankverbindung');
                items.push(closeSqlCONNECTION_NAMECompletion);
            }
            if (/.*\s*cobol2Xml\s*\(.*/.test(linePrefix)) {
                const cobol2XmlINPUT_BINCompletion = new vscode.CompletionItem('INPUT_BIN');
                cobol2XmlINPUT_BINCompletion.kind = vscode.CompletionItemKind.Field;
                cobol2XmlINPUT_BINCompletion.insertText = new vscode.SnippetString("INPUT_BIN = \"${1}\"");
                cobol2XmlINPUT_BINCompletion.documentation = new vscode.MarkdownString('Zu verwendendes Eingangs-BIN');
                items.push(cobol2XmlINPUT_BINCompletion);
                const cobol2XmlCOPYBOOKCompletion = new vscode.CompletionItem('COPYBOOK');
                cobol2XmlCOPYBOOKCompletion.kind = vscode.CompletionItemKind.Field;
                cobol2XmlCOPYBOOKCompletion.insertText = new vscode.SnippetString("COPYBOOK = \"${1}\"");
                cobol2XmlCOPYBOOKCompletion.documentation = new vscode.MarkdownString('Host Copybook');
                items.push(cobol2XmlCOPYBOOKCompletion);
                const cobol2XmlOUTPUT_XMLCompletion = new vscode.CompletionItem('OUTPUT_XML');
                cobol2XmlOUTPUT_XMLCompletion.kind = vscode.CompletionItemKind.Field;
                cobol2XmlOUTPUT_XMLCompletion.insertText = new vscode.SnippetString("OUTPUT_XML = \"${1}\"");
                cobol2XmlOUTPUT_XMLCompletion.documentation = new vscode.MarkdownString('Zu erstellende XML Datei');
                items.push(cobol2XmlOUTPUT_XMLCompletion);
                const cobol2XmlFONTCompletion = new vscode.CompletionItem('FONT');
                cobol2XmlFONTCompletion.kind = vscode.CompletionItemKind.Field;
                cobol2XmlFONTCompletion.insertText = new vscode.SnippetString("FONT = \"${1}\"");
                cobol2XmlFONTCompletion.documentation = new vscode.MarkdownString('Zu verwendendes Charset der Cobol Datei');
                items.push(cobol2XmlFONTCompletion);
            }
            if (/.*\s*comfortClickWin\s*\(.*/.test(linePrefix)) {
                const comfortClickWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                comfortClickWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                comfortClickWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(comfortClickWinWINDOW_NAMECompletion);
                const comfortClickWinRELATIVE_PATH_IMAGECompletion = new vscode.CompletionItem('RELATIVE_PATH_IMAGE');
                comfortClickWinRELATIVE_PATH_IMAGECompletion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinRELATIVE_PATH_IMAGECompletion.insertText = new vscode.SnippetString("RELATIVE_PATH_IMAGE = \"${1}\"");
                comfortClickWinRELATIVE_PATH_IMAGECompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(comfortClickWinRELATIVE_PATH_IMAGECompletion);
                const comfortClickWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                comfortClickWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                comfortClickWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(comfortClickWinBASEDIRCompletion);
                const comfortClickWinTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                comfortClickWinTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                comfortClickWinTIMEOUTCompletion.documentation = new vscode.MarkdownString('Zeit, nach der das Warten mit einem Fehler abgebrochen wird.');
                items.push(comfortClickWinTIMEOUTCompletion);
                const comfortClickWinMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                comfortClickWinMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                comfortClickWinMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{links,rechts} links ist default, muss daher nicht angegeben werden.');
                items.push(comfortClickWinMOUSE_BUTTONCompletion);
                const comfortClickWinRELATIVE_XCompletion = new vscode.CompletionItem('RELATIVE_X');
                comfortClickWinRELATIVE_XCompletion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinRELATIVE_XCompletion.insertText = new vscode.SnippetString("RELATIVE_X = \"${1}\"");
                comfortClickWinRELATIVE_XCompletion.documentation = new vscode.MarkdownString('Verschiebung des Klicks relativ zum Mittelpunkt des Bildes. Links: Negativ. Rechts: Positiv');
                items.push(comfortClickWinRELATIVE_XCompletion);
                const comfortClickWinRELATIVE_YCompletion = new vscode.CompletionItem('RELATIVE_Y');
                comfortClickWinRELATIVE_YCompletion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinRELATIVE_YCompletion.insertText = new vscode.SnippetString("RELATIVE_Y = \"${1}\"");
                comfortClickWinRELATIVE_YCompletion.documentation = new vscode.MarkdownString('Verschiebung des Klicks relativ zum Mittelpunkt des Bildes. Oben: Negativ. Unten: Positiv');
                items.push(comfortClickWinRELATIVE_YCompletion);
                const comfortClickWinX1Completion = new vscode.CompletionItem('X1');
                comfortClickWinX1Completion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinX1Completion.insertText = new vscode.SnippetString("X1 = \"${1}\"");
                comfortClickWinX1Completion.documentation = new vscode.MarkdownString('Linke Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(comfortClickWinX1Completion);
                const comfortClickWinY1Completion = new vscode.CompletionItem('Y1');
                comfortClickWinY1Completion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinY1Completion.insertText = new vscode.SnippetString("Y1 = \"${1}\"");
                comfortClickWinY1Completion.documentation = new vscode.MarkdownString('Obere Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(comfortClickWinY1Completion);
                const comfortClickWinX2Completion = new vscode.CompletionItem('X2');
                comfortClickWinX2Completion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinX2Completion.insertText = new vscode.SnippetString("X2 = \"${1}\"");
                comfortClickWinX2Completion.documentation = new vscode.MarkdownString('Rechte Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(comfortClickWinX2Completion);
                const comfortClickWinY2Completion = new vscode.CompletionItem('Y2');
                comfortClickWinY2Completion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinY2Completion.insertText = new vscode.SnippetString("Y2 = \"${1}\"");
                comfortClickWinY2Completion.documentation = new vscode.MarkdownString('Untere Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(comfortClickWinY2Completion);
                const comfortClickWinMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                comfortClickWinMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                comfortClickWinMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                comfortClickWinMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(comfortClickWinMATCH_MODECompletion);
            }
            if (/.*\s*comfortSendTextWin\s*\(.*/.test(linePrefix)) {
                const comfortSendTextWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                comfortSendTextWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                comfortSendTextWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(comfortSendTextWinWINDOW_NAMECompletion);
                const comfortSendTextWinRELATIVE_PATH_IMAGECompletion = new vscode.CompletionItem('RELATIVE_PATH_IMAGE');
                comfortSendTextWinRELATIVE_PATH_IMAGECompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinRELATIVE_PATH_IMAGECompletion.insertText = new vscode.SnippetString("RELATIVE_PATH_IMAGE = \"${1}\"");
                comfortSendTextWinRELATIVE_PATH_IMAGECompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(comfortSendTextWinRELATIVE_PATH_IMAGECompletion);
                const comfortSendTextWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                comfortSendTextWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                comfortSendTextWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(comfortSendTextWinBASEDIRCompletion);
                const comfortSendTextWinTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                comfortSendTextWinTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                comfortSendTextWinTIMEOUTCompletion.documentation = new vscode.MarkdownString('Zeit, nach der ein Fehler gemeldet wird.');
                items.push(comfortSendTextWinTIMEOUTCompletion);
                const comfortSendTextWinMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                comfortSendTextWinMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                comfortSendTextWinMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{links,rechts} links ist default, muss daher nicht angegeben werden.');
                items.push(comfortSendTextWinMOUSE_BUTTONCompletion);
                const comfortSendTextWinRELATIVE_XCompletion = new vscode.CompletionItem('RELATIVE_X');
                comfortSendTextWinRELATIVE_XCompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinRELATIVE_XCompletion.insertText = new vscode.SnippetString("RELATIVE_X = \"${1}\"");
                comfortSendTextWinRELATIVE_XCompletion.documentation = new vscode.MarkdownString('Verschiebung des Klicks relativ zum Mittelpunkt des Bildes. Links: Negativ. Rechts: Positiv');
                items.push(comfortSendTextWinRELATIVE_XCompletion);
                const comfortSendTextWinRELATIVE_YCompletion = new vscode.CompletionItem('RELATIVE_Y');
                comfortSendTextWinRELATIVE_YCompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinRELATIVE_YCompletion.insertText = new vscode.SnippetString("RELATIVE_Y = \"${1}\"");
                comfortSendTextWinRELATIVE_YCompletion.documentation = new vscode.MarkdownString('Verschiebung des Klicks relativ zum Mittelpunkt des Bildes. Oben: Negativ. Unten: Positiv');
                items.push(comfortSendTextWinRELATIVE_YCompletion);
                const comfortSendTextWinX1Completion = new vscode.CompletionItem('X1');
                comfortSendTextWinX1Completion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinX1Completion.insertText = new vscode.SnippetString("X1 = \"${1}\"");
                comfortSendTextWinX1Completion.documentation = new vscode.MarkdownString('Linke Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(comfortSendTextWinX1Completion);
                const comfortSendTextWinY1Completion = new vscode.CompletionItem('Y1');
                comfortSendTextWinY1Completion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinY1Completion.insertText = new vscode.SnippetString("Y1 = \"${1}\"");
                comfortSendTextWinY1Completion.documentation = new vscode.MarkdownString('Obere Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(comfortSendTextWinY1Completion);
                const comfortSendTextWinX2Completion = new vscode.CompletionItem('X2');
                comfortSendTextWinX2Completion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinX2Completion.insertText = new vscode.SnippetString("X2 = \"${1}\"");
                comfortSendTextWinX2Completion.documentation = new vscode.MarkdownString('Rechte Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(comfortSendTextWinX2Completion);
                const comfortSendTextWinY2Completion = new vscode.CompletionItem('Y2');
                comfortSendTextWinY2Completion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinY2Completion.insertText = new vscode.SnippetString("Y2 = \"${1}\"");
                comfortSendTextWinY2Completion.documentation = new vscode.MarkdownString('Untere Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(comfortSendTextWinY2Completion);
                const comfortSendTextWinTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                comfortSendTextWinTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                comfortSendTextWinTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Zu sendender (schreibender) Text');
                items.push(comfortSendTextWinTEXT_TO_SENDCompletion);
                const comfortSendTextWinMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                comfortSendTextWinMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                comfortSendTextWinMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                comfortSendTextWinMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(comfortSendTextWinMATCH_MODECompletion);
            }
            if (/.*\s*comfortWaitWindow\s*\(.*/.test(linePrefix)) {
                const comfortWaitWindowWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                comfortWaitWindowWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                comfortWaitWindowWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                comfortWaitWindowWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(comfortWaitWindowWINDOW_NAMECompletion);
                const comfortWaitWindowMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                comfortWaitWindowMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                comfortWaitWindowMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                comfortWaitWindowMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(comfortWaitWindowMATCH_MODECompletion);
                const comfortWaitWindowTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                comfortWaitWindowTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                comfortWaitWindowTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                comfortWaitWindowTIMEOUTCompletion.documentation = new vscode.MarkdownString('Zeit, nach der ein Fehler gemeldet wird.');
                items.push(comfortWaitWindowTIMEOUTCompletion);
            }
            if (/.*\s*comment\s*\(.*/.test(linePrefix)) {
                const commentTEXTCompletion = new vscode.CompletionItem('TEXT');
                commentTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                commentTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                commentTEXTCompletion.documentation = new vscode.MarkdownString('Der darzustellende Kommentar');
                items.push(commentTEXTCompletion);
            }
            if (/.*\s*compareChangesSql\s*\(.*/.test(linePrefix)) {
                const compareChangesSqlCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                compareChangesSqlCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                compareChangesSqlCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der bestehenden Datenbankverbindung');
                items.push(compareChangesSqlCONNECTION_NAMECompletion);
                const compareChangesSqlTABLE_BEFORECompletion = new vscode.CompletionItem('TABLE_BEFORE');
                compareChangesSqlTABLE_BEFORECompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlTABLE_BEFORECompletion.insertText = new vscode.SnippetString("TABLE_BEFORE = \"${1}\"");
                compareChangesSqlTABLE_BEFORECompletion.documentation = new vscode.MarkdownString('Name der ersten zu vergleichenden Tabelle');
                items.push(compareChangesSqlTABLE_BEFORECompletion);
                const compareChangesSqlTABLE_AFTERCompletion = new vscode.CompletionItem('TABLE_AFTER');
                compareChangesSqlTABLE_AFTERCompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlTABLE_AFTERCompletion.insertText = new vscode.SnippetString("TABLE_AFTER = \"${1}\"");
                compareChangesSqlTABLE_AFTERCompletion.documentation = new vscode.MarkdownString('Name der zweiten zu vergleichenden Tabelle');
                items.push(compareChangesSqlTABLE_AFTERCompletion);
                const compareChangesSqlPRIMARY_KEYSCompletion = new vscode.CompletionItem('PRIMARY_KEYS');
                compareChangesSqlPRIMARY_KEYSCompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlPRIMARY_KEYSCompletion.insertText = new vscode.SnippetString("PRIMARY_KEYS = \"${1}\"");
                compareChangesSqlPRIMARY_KEYSCompletion.documentation = new vscode.MarkdownString('Komma-separierte Liste der Namen der Prim\u00E4rschl\u00FCssel-Spalten');
                items.push(compareChangesSqlPRIMARY_KEYSCompletion);
                const compareChangesSqlIGNORE_FIELD_LISTCompletion = new vscode.CompletionItem('IGNORE_FIELD_LIST');
                compareChangesSqlIGNORE_FIELD_LISTCompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlIGNORE_FIELD_LISTCompletion.insertText = new vscode.SnippetString("IGNORE_FIELD_LIST = \"${1}\"");
                compareChangesSqlIGNORE_FIELD_LISTCompletion.documentation = new vscode.MarkdownString('Komma-separierte Liste der Namen der Spalten, die beim Vergleich zu ignorieren sind');
                items.push(compareChangesSqlIGNORE_FIELD_LISTCompletion);
                const compareChangesSqlVERBOSECompletion = new vscode.CompletionItem('VERBOSE');
                compareChangesSqlVERBOSECompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlVERBOSECompletion.insertText = new vscode.SnippetString("VERBOSE = \"${1}\"");
                compareChangesSqlVERBOSECompletion.documentation = new vscode.MarkdownString('Auf true zu setzen, um in der Weboberfl\u00E4che eine detaillierte Zusammenfassung des Vergleichs zu erhalten. (Default: false)');
                items.push(compareChangesSqlVERBOSECompletion);
                const compareChangesSqlOUTPUT_FILE_CSVCompletion = new vscode.CompletionItem('OUTPUT_FILE_CSV');
                compareChangesSqlOUTPUT_FILE_CSVCompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlOUTPUT_FILE_CSVCompletion.insertText = new vscode.SnippetString("OUTPUT_FILE_CSV = \"${1}\"");
                compareChangesSqlOUTPUT_FILE_CSVCompletion.documentation = new vscode.MarkdownString('Pfad zu der CSV-Datei, in die das Vergleichsergebnis geschrieben wird.  -    Dabei werden f\u00FCr jede Zeile alle Spalten aufgef\u00FChrt, in denen in mindestens einer Zeile \u00C4nderungen gefunden wurden, sowie die Prim\u00E4rschl\u00FCsselspalten.  -    Achtung: bereits vorhandene Inhalte in der Datei werden \u00DCberschrieben.');
                items.push(compareChangesSqlOUTPUT_FILE_CSVCompletion);
                const compareChangesSqlSUCCESS_ON_NO_CHANGECompletion = new vscode.CompletionItem('SUCCESS_ON_NO_CHANGE');
                compareChangesSqlSUCCESS_ON_NO_CHANGECompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlSUCCESS_ON_NO_CHANGECompletion.insertText = new vscode.SnippetString("SUCCESS_ON_NO_CHANGE = \"${1}\"");
                compareChangesSqlSUCCESS_ON_NO_CHANGECompletion.documentation = new vscode.MarkdownString('Ist dieser Wert false (default), gibt das Kommando das Resultat \'Warnung\' aus, wenn mindestens eine \u00C4nderung gefunden wurde und ansonsten \'Erfolg\'.  -    Ist der Wert true, ist das Verhalten umgekehrt.');
                items.push(compareChangesSqlSUCCESS_ON_NO_CHANGECompletion);
                const compareChangesSqlENCODINGCompletion = new vscode.CompletionItem('ENCODING');
                compareChangesSqlENCODINGCompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlENCODINGCompletion.insertText = new vscode.SnippetString("ENCODING = \"${1}\"");
                compareChangesSqlENCODINGCompletion.documentation = new vscode.MarkdownString('Encoding der Output-Files (Default: UTF-8)');
                items.push(compareChangesSqlENCODINGCompletion);
                const compareChangesSqlOUTPUT_FILE_REPORTCompletion = new vscode.CompletionItem('OUTPUT_FILE_REPORT');
                compareChangesSqlOUTPUT_FILE_REPORTCompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlOUTPUT_FILE_REPORTCompletion.insertText = new vscode.SnippetString("OUTPUT_FILE_REPORT = \"${1}\"");
                compareChangesSqlOUTPUT_FILE_REPORTCompletion.documentation = new vscode.MarkdownString('Pfad zur Text-Datei, in die eine detaillierte Zusammenfassung des Vergleichs zu schreiben ist. Achtung: bereits vorhandene Inhalte in der Datei werden \u00DCberschrieben.');
                items.push(compareChangesSqlOUTPUT_FILE_REPORTCompletion);
                const compareChangesSqlCSV_DELIMITERCompletion = new vscode.CompletionItem('CSV_DELIMITER');
                compareChangesSqlCSV_DELIMITERCompletion.kind = vscode.CompletionItemKind.Field;
                compareChangesSqlCSV_DELIMITERCompletion.insertText = new vscode.SnippetString("CSV_DELIMITER = \"${1}\"");
                compareChangesSqlCSV_DELIMITERCompletion.documentation = new vscode.MarkdownString('Trennzeichen zwischen den in der CSV-Datei vorzunehmenden Eintr\u00E4gen. Zul\u00E4ssig sind 1 bis 5 Zeichen. (Default: ,)');
                items.push(compareChangesSqlCSV_DELIMITERCompletion);
            }
            if (/.*\s*compareText\s*\(.*/.test(linePrefix)) {
                const compareTextTEXT1Completion = new vscode.CompletionItem('TEXT1');
                compareTextTEXT1Completion.kind = vscode.CompletionItemKind.Field;
                compareTextTEXT1Completion.insertText = new vscode.SnippetString("TEXT1 = \"${1}\"");
                compareTextTEXT1Completion.documentation = new vscode.MarkdownString('Text oder vollst\u00E4ndig qualifizierter Dateiname einer Textdatei.');
                items.push(compareTextTEXT1Completion);
                const compareTextTEXT2Completion = new vscode.CompletionItem('TEXT2');
                compareTextTEXT2Completion.kind = vscode.CompletionItemKind.Field;
                compareTextTEXT2Completion.insertText = new vscode.SnippetString("TEXT2 = \"${1}\"");
                compareTextTEXT2Completion.documentation = new vscode.MarkdownString('Text oder vollst\u00E4ndig qualifizierter Dateiname einer Textdatei.');
                items.push(compareTextTEXT2Completion);
                const compareTextLINES_TO_IGNORECompletion = new vscode.CompletionItem('LINES_TO_IGNORE');
                compareTextLINES_TO_IGNORECompletion.kind = vscode.CompletionItemKind.Field;
                compareTextLINES_TO_IGNORECompletion.insertText = new vscode.SnippetString("LINES_TO_IGNORE = \"${1}\"");
                compareTextLINES_TO_IGNORECompletion.documentation = new vscode.MarkdownString('Liste von Ganzzahlen, die Zeilen angeben, die vom Vergleich ausgenommen werden. Erlaubte Trennzeichen sind \',\' f\u00FCr Einzelwerte und \'-\' f\u00FCr Wertebereiche (z. B. \'3, 7, 8-10, 12, 19-21\', um Zeilen 3, 7, 8, 9, 10, 12, 19, 20, 21 auszunehmen). Achtung: Die Zeilen werden in beiden Texten ignoriert.');
                items.push(compareTextLINES_TO_IGNORECompletion);
                const compareTextLINES_TO_COMPARECompletion = new vscode.CompletionItem('LINES_TO_COMPARE');
                compareTextLINES_TO_COMPARECompletion.kind = vscode.CompletionItemKind.Field;
                compareTextLINES_TO_COMPARECompletion.insertText = new vscode.SnippetString("LINES_TO_COMPARE = \"${1}\"");
                compareTextLINES_TO_COMPARECompletion.documentation = new vscode.MarkdownString('Liste von Ganzzahlen, die Zeilen angeben, die zu vergleichen sind. Erlaubte Trennzeichen sind \',\' f\u00FCr Einzelwerte und \'-\' f\u00FCr Wertebereiche (z. B. \'3, 7, 8-10\', um alle Zeilen au\u00DFer 3, 7, 8, 9, 10 auszunehmen). Bestehen \u00DCberschneidungen zwischen LINES_TO_KEEP und LINES_TO_IGNORE, so werden Zeilen in LINES_TO_IGNORE in jedem Fall ausgenommen.');
                items.push(compareTextLINES_TO_COMPARECompletion);
                const compareTextTEXT1_IS_FILECompletion = new vscode.CompletionItem('TEXT1_IS_FILE');
                compareTextTEXT1_IS_FILECompletion.kind = vscode.CompletionItemKind.Field;
                compareTextTEXT1_IS_FILECompletion.insertText = new vscode.SnippetString("TEXT1_IS_FILE = \"${1}\"");
                compareTextTEXT1_IS_FILECompletion.documentation = new vscode.MarkdownString('Ist TEXT1 ein Dateiname? (true\/false, default: false)');
                items.push(compareTextTEXT1_IS_FILECompletion);
                const compareTextTEXT2_IS_FILECompletion = new vscode.CompletionItem('TEXT2_IS_FILE');
                compareTextTEXT2_IS_FILECompletion.kind = vscode.CompletionItemKind.Field;
                compareTextTEXT2_IS_FILECompletion.insertText = new vscode.SnippetString("TEXT2_IS_FILE = \"${1}\"");
                compareTextTEXT2_IS_FILECompletion.documentation = new vscode.MarkdownString('Ist TEXT2 ein Dateiname? (true\/false, default: false)');
                items.push(compareTextTEXT2_IS_FILECompletion);
                const compareTextENCODING_TEXT1Completion = new vscode.CompletionItem('ENCODING_TEXT1');
                compareTextENCODING_TEXT1Completion.kind = vscode.CompletionItemKind.Field;
                compareTextENCODING_TEXT1Completion.insertText = new vscode.SnippetString("ENCODING_TEXT1 = \"${1}\"");
                compareTextENCODING_TEXT1Completion.documentation = new vscode.MarkdownString('Falls TEXT1 eine Datei ist, mit welcher Kodierung soll diese eingelesen werden? (Default: UTF-8, Optionen: US-ASCII, ISO-8859-1, UTF-8, UTF-16BE, UTF-16LE, UTF-16)');
                items.push(compareTextENCODING_TEXT1Completion);
                const compareTextENCODING_TEXT2Completion = new vscode.CompletionItem('ENCODING_TEXT2');
                compareTextENCODING_TEXT2Completion.kind = vscode.CompletionItemKind.Field;
                compareTextENCODING_TEXT2Completion.insertText = new vscode.SnippetString("ENCODING_TEXT2 = \"${1}\"");
                compareTextENCODING_TEXT2Completion.documentation = new vscode.MarkdownString('Analog zu ENCODING_TEXT1 f\u00FCr TEXT2');
                items.push(compareTextENCODING_TEXT2Completion);
                const compareTextTRIM_LINESCompletion = new vscode.CompletionItem('TRIM_LINES');
                compareTextTRIM_LINESCompletion.kind = vscode.CompletionItemKind.Field;
                compareTextTRIM_LINESCompletion.insertText = new vscode.SnippetString("TRIM_LINES = \"${1}\"");
                compareTextTRIM_LINESCompletion.documentation = new vscode.MarkdownString('Sollen Leerzeichen an Anfang und Ende jeder Zeile vor Vergleich entfernt werden? (true\/false, default: false)');
                items.push(compareTextTRIM_LINESCompletion);
                const compareTextSKIP_EMPTY_LINESCompletion = new vscode.CompletionItem('SKIP_EMPTY_LINES');
                compareTextSKIP_EMPTY_LINESCompletion.kind = vscode.CompletionItemKind.Field;
                compareTextSKIP_EMPTY_LINESCompletion.insertText = new vscode.SnippetString("SKIP_EMPTY_LINES = \"${1}\"");
                compareTextSKIP_EMPTY_LINESCompletion.documentation = new vscode.MarkdownString('Sollen Leerzeilen aus den Texten bei Vergleich \u00FCbersprungen werden? (true\/false, default: false). Bsp: Beide Texte werden gerade in Zeile 2 verglichen. TEXT_2 hat in Zeile 2 eine Leerzeile, TEXT_1, Zeile 2 ist nicht leer. Dann wird stattdessen die n\u00E4chste Nicht-Leerzeile in TEXT_2 (z.B. TEXT_2, Zeile 4) mit TEXT_1, Zeile 2 verglichen. Die folgenden zu vergleichenden Zeilen verschieben sich analog. Im Beispielfall w\u00FCrde also als n\u00E4chstes TEXT_2, Zeile 5 mit TEXT_1, Zeile 3 verglichen werden.');
                items.push(compareTextSKIP_EMPTY_LINESCompletion);
            }
            if (/.*\s*containsAlpha\s*\(.*/.test(linePrefix)) {
                const containsAlphaTEXTCompletion = new vscode.CompletionItem('TEXT');
                containsAlphaTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                containsAlphaTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                containsAlphaTEXTCompletion.documentation = new vscode.MarkdownString('Der Text, der den Wert enthalten soll');
                items.push(containsAlphaTEXTCompletion);
                const containsAlphaVALUECompletion = new vscode.CompletionItem('VALUE');
                containsAlphaVALUECompletion.kind = vscode.CompletionItemKind.Field;
                containsAlphaVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                containsAlphaVALUECompletion.documentation = new vscode.MarkdownString('Wert, der enthalten sein soll');
                items.push(containsAlphaVALUECompletion);
            }
            if (/.*\s*controlClick\s*\(.*/.test(linePrefix)) {
                const controlClickWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlClickWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlClickWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlClickWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlClickWINDOW_NAMECompletion);
                const controlClickCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlClickCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlClickCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlClickCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlClickCONTROLCompletion);
                const controlClickMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                controlClickMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                controlClickMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                controlClickMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('Die zu dr\u00FCckende Maustaste, left, right, middle, menu, primary, secondary. Standard ist left.');
                items.push(controlClickMOUSE_BUTTONCompletion);
                const controlClickXCompletion = new vscode.CompletionItem('X');
                controlClickXCompletion.kind = vscode.CompletionItemKind.Field;
                controlClickXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                controlClickXCompletion.documentation = new vscode.MarkdownString('Die x-Position innerhalb des Controls, die geklickt werden soll. Standard ist die Mitte');
                items.push(controlClickXCompletion);
                const controlClickYCompletion = new vscode.CompletionItem('Y');
                controlClickYCompletion.kind = vscode.CompletionItemKind.Field;
                controlClickYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                controlClickYCompletion.documentation = new vscode.MarkdownString('LDie y-Position innerhalb des Controls, die geklickt werden soll. Standard ist die Mitte');
                items.push(controlClickYCompletion);
            }
            if (/.*\s*controlCommand\s*\(.*/.test(linePrefix)) {
                const controlCommandWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlCommandWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlCommandWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlCommandWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlCommandWINDOW_NAMECompletion);
                const controlCommandCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlCommandCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlCommandCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlCommandCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlCommandCONTROLCompletion);
                const controlCommandMODECompletion = new vscode.CompletionItem('MODE');
                controlCommandMODECompletion.kind = vscode.CompletionItemKind.Field;
                controlCommandMODECompletion.insertText = new vscode.SnippetString("MODE = \"${1}\"");
                controlCommandMODECompletion.documentation = new vscode.MarkdownString('Der zu sendende Modus (z.B. stringSelect). ');
                items.push(controlCommandMODECompletion);
                const controlCommandOPTION1Completion = new vscode.CompletionItem('OPTION1');
                controlCommandOPTION1Completion.kind = vscode.CompletionItemKind.Field;
                controlCommandOPTION1Completion.insertText = new vscode.SnippetString("OPTION1 = \"${1}\"");
                controlCommandOPTION1Completion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(controlCommandOPTION1Completion);
                const controlCommandTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                controlCommandTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                controlCommandTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                controlCommandTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(controlCommandTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*controlDisable\s*\(.*/.test(linePrefix)) {
                const controlDisableWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlDisableWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlDisableWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlDisableWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlDisableWINDOW_NAMECompletion);
                const controlDisableCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlDisableCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlDisableCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlDisableCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlDisableCONTROLCompletion);
            }
            if (/.*\s*controlDoubleClick\s*\(.*/.test(linePrefix)) {
                const controlDoubleClickWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlDoubleClickWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlDoubleClickWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlDoubleClickWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlDoubleClickWINDOW_NAMECompletion);
                const controlDoubleClickCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlDoubleClickCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlDoubleClickCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlDoubleClickCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlDoubleClickCONTROLCompletion);
                const controlDoubleClickMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                controlDoubleClickMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                controlDoubleClickMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                controlDoubleClickMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('Die zu dr\u00FCckende Maustaste, left, right, middle, menu, primary, secondary. Standard ist left.');
                items.push(controlDoubleClickMOUSE_BUTTONCompletion);
                const controlDoubleClickXCompletion = new vscode.CompletionItem('X');
                controlDoubleClickXCompletion.kind = vscode.CompletionItemKind.Field;
                controlDoubleClickXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                controlDoubleClickXCompletion.documentation = new vscode.MarkdownString('Die x-Position innerhalb des Controls, die geklickt werden soll. Standard ist die Mitte');
                items.push(controlDoubleClickXCompletion);
                const controlDoubleClickYCompletion = new vscode.CompletionItem('Y');
                controlDoubleClickYCompletion.kind = vscode.CompletionItemKind.Field;
                controlDoubleClickYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                controlDoubleClickYCompletion.documentation = new vscode.MarkdownString('LDie y-Position innerhalb des Controls, die geklickt werden soll. Standard ist die Mitte');
                items.push(controlDoubleClickYCompletion);
            }
            if (/.*\s*controlEnable\s*\(.*/.test(linePrefix)) {
                const controlEnableWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlEnableWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlEnableWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlEnableWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlEnableWINDOW_NAMECompletion);
                const controlEnableCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlEnableCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlEnableCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlEnableCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlEnableCONTROLCompletion);
            }
            if (/.*\s*controlFocus\s*\(.*/.test(linePrefix)) {
                const controlFocusWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlFocusWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlFocusWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlFocusWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlFocusWINDOW_NAMECompletion);
                const controlFocusCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlFocusCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlFocusCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlFocusCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlFocusCONTROLCompletion);
            }
            if (/.*\s*controlGetText\s*\(.*/.test(linePrefix)) {
                const controlGetTextWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlGetTextWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlGetTextWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlGetTextWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlGetTextWINDOW_NAMECompletion);
                const controlGetTextCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlGetTextCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlGetTextCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlGetTextCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlGetTextCONTROLCompletion);
                const controlGetTextTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                controlGetTextTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                controlGetTextTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                controlGetTextTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(controlGetTextTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*controlHide\s*\(.*/.test(linePrefix)) {
                const controlHideWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlHideWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlHideWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlHideWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlHideWINDOW_NAMECompletion);
                const controlHideCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlHideCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlHideCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlHideCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlHideCONTROLCompletion);
            }
            if (/.*\s*controlListView\s*\(.*/.test(linePrefix)) {
                const controlListViewWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlListViewWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlListViewWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlListViewWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlListViewWINDOW_NAMECompletion);
                const controlListViewCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlListViewCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlListViewCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlListViewCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlListViewCONTROLCompletion);
                const controlListViewMODECompletion = new vscode.CompletionItem('MODE');
                controlListViewMODECompletion.kind = vscode.CompletionItemKind.Field;
                controlListViewMODECompletion.insertText = new vscode.SnippetString("MODE = \"${1}\"");
                controlListViewMODECompletion.documentation = new vscode.MarkdownString('Der zu sendende Modus (z.B. Select). ');
                items.push(controlListViewMODECompletion);
                const controlListViewOPTION1Completion = new vscode.CompletionItem('OPTION1');
                controlListViewOPTION1Completion.kind = vscode.CompletionItemKind.Field;
                controlListViewOPTION1Completion.insertText = new vscode.SnippetString("OPTION1 = \"${1}\"");
                controlListViewOPTION1Completion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(controlListViewOPTION1Completion);
                const controlListViewOPTION2Completion = new vscode.CompletionItem('OPTION2');
                controlListViewOPTION2Completion.kind = vscode.CompletionItemKind.Field;
                controlListViewOPTION2Completion.insertText = new vscode.SnippetString("OPTION2 = \"${1}\"");
                controlListViewOPTION2Completion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(controlListViewOPTION2Completion);
                const controlListViewTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                controlListViewTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                controlListViewTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                controlListViewTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(controlListViewTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*controlSend\s*\(.*/.test(linePrefix)) {
                const controlSendWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlSendWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlSendWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlSendWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlSendWINDOW_NAMECompletion);
                const controlSendCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlSendCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlSendCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlSendCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlSendCONTROLCompletion);
                const controlSendTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                controlSendTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                controlSendTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                controlSendTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Text der versendet werden soll. ');
                items.push(controlSendTEXT_TO_SENDCompletion);
            }
            if (/.*\s*controlSetText\s*\(.*/.test(linePrefix)) {
                const controlSetTextWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlSetTextWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlSetTextWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlSetTextWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlSetTextWINDOW_NAMECompletion);
                const controlSetTextCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlSetTextCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlSetTextCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlSetTextCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlSetTextCONTROLCompletion);
                const controlSetTextTEXT_TO_SETCompletion = new vscode.CompletionItem('TEXT_TO_SET');
                controlSetTextTEXT_TO_SETCompletion.kind = vscode.CompletionItemKind.Field;
                controlSetTextTEXT_TO_SETCompletion.insertText = new vscode.SnippetString("TEXT_TO_SET = \"${1}\"");
                controlSetTextTEXT_TO_SETCompletion.documentation = new vscode.MarkdownString('Text der gesetzt werden soll. ');
                items.push(controlSetTextTEXT_TO_SETCompletion);
            }
            if (/.*\s*controlShow\s*\(.*/.test(linePrefix)) {
                const controlShowWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlShowWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlShowWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlShowWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlShowWINDOW_NAMECompletion);
                const controlShowCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlShowCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlShowCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlShowCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlShowCONTROLCompletion);
            }
            if (/.*\s*controlTreeView\s*\(.*/.test(linePrefix)) {
                const controlTreeViewWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlTreeViewWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlTreeViewWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlTreeViewWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlTreeViewWINDOW_NAMECompletion);
                const controlTreeViewCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlTreeViewCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlTreeViewCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlTreeViewCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlTreeViewCONTROLCompletion);
                const controlTreeViewMODECompletion = new vscode.CompletionItem('MODE');
                controlTreeViewMODECompletion.kind = vscode.CompletionItemKind.Field;
                controlTreeViewMODECompletion.insertText = new vscode.SnippetString("MODE = \"${1}\"");
                controlTreeViewMODECompletion.documentation = new vscode.MarkdownString('Der zu sendende Modus (z.B. Select). ');
                items.push(controlTreeViewMODECompletion);
                const controlTreeViewOPTION1Completion = new vscode.CompletionItem('OPTION1');
                controlTreeViewOPTION1Completion.kind = vscode.CompletionItemKind.Field;
                controlTreeViewOPTION1Completion.insertText = new vscode.SnippetString("OPTION1 = \"${1}\"");
                controlTreeViewOPTION1Completion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(controlTreeViewOPTION1Completion);
                const controlTreeViewTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                controlTreeViewTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                controlTreeViewTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                controlTreeViewTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(controlTreeViewTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*controlWaitFor\s*\(.*/.test(linePrefix)) {
                const controlWaitForWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                controlWaitForWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                controlWaitForWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                controlWaitForWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Der Titel\/hWnd\/Klasse des Fensters, auf das zugegriffen werden soll.');
                items.push(controlWaitForWINDOW_NAMECompletion);
                const controlWaitForCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                controlWaitForCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                controlWaitForCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                controlWaitForCONTROLCompletion.documentation = new vscode.MarkdownString('Die ID des Controls, das beeinflusst werden soll. ');
                items.push(controlWaitForCONTROLCompletion);
                const controlWaitForMAX_SECONDS_TO_WAITCompletion = new vscode.CompletionItem('MAX_SECONDS_TO_WAIT');
                controlWaitForMAX_SECONDS_TO_WAITCompletion.kind = vscode.CompletionItemKind.Field;
                controlWaitForMAX_SECONDS_TO_WAITCompletion.insertText = new vscode.SnippetString("MAX_SECONDS_TO_WAIT = \"${1}\"");
                controlWaitForMAX_SECONDS_TO_WAITCompletion.documentation = new vscode.MarkdownString('Maximale Wartezeit bevor das Kommando mit Fehler abbricht.');
                items.push(controlWaitForMAX_SECONDS_TO_WAITCompletion);
            }
            if (/.*\s*convertExcelToCsv\s*\(.*/.test(linePrefix)) {
                const convertExcelToCsvFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                convertExcelToCsvFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                convertExcelToCsvFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                convertExcelToCsvFILENAMECompletion.documentation = new vscode.MarkdownString('Der vollst\u00E4ndige Dateipfad zur Excel-Datei, die konvertiert werden soll.');
                items.push(convertExcelToCsvFILENAMECompletion);
                const convertExcelToCsvSHEET_INDEXCompletion = new vscode.CompletionItem('SHEET_INDEX');
                convertExcelToCsvSHEET_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                convertExcelToCsvSHEET_INDEXCompletion.insertText = new vscode.SnippetString("SHEET_INDEX = \"${1}\"");
                convertExcelToCsvSHEET_INDEXCompletion.documentation = new vscode.MarkdownString('Index (Nummer) des Tabellenblatts das ausgegeben werden soll.');
                items.push(convertExcelToCsvSHEET_INDEXCompletion);
                const convertExcelToCsvDEST_FILENAMECompletion = new vscode.CompletionItem('DEST_FILENAME');
                convertExcelToCsvDEST_FILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                convertExcelToCsvDEST_FILENAMECompletion.insertText = new vscode.SnippetString("DEST_FILENAME = \"${1}\"");
                convertExcelToCsvDEST_FILENAMECompletion.documentation = new vscode.MarkdownString('Der vollst\u00E4ndige Pfad der Zieldatei.');
                items.push(convertExcelToCsvDEST_FILENAMECompletion);
                const convertExcelToCsvEVALUATE_FORMULASCompletion = new vscode.CompletionItem('EVALUATE_FORMULAS');
                convertExcelToCsvEVALUATE_FORMULASCompletion.kind = vscode.CompletionItemKind.Field;
                convertExcelToCsvEVALUATE_FORMULASCompletion.insertText = new vscode.SnippetString("EVALUATE_FORMULAS = \"${1}\"");
                convertExcelToCsvEVALUATE_FORMULASCompletion.documentation = new vscode.MarkdownString('True\/False gibt an, ob Formeln ausgewertet, oder als Formel     ausgegeben werden sollen (optional, standard=true)');
                items.push(convertExcelToCsvEVALUATE_FORMULASCompletion);
            }
            if (/.*\s*copyFile\s*\(.*/.test(linePrefix)) {
                const copyFileFILENAME_FROMCompletion = new vscode.CompletionItem('FILENAME_FROM');
                copyFileFILENAME_FROMCompletion.kind = vscode.CompletionItemKind.Field;
                copyFileFILENAME_FROMCompletion.insertText = new vscode.SnippetString("FILENAME_FROM = \"${1}\"");
                copyFileFILENAME_FROMCompletion.documentation = new vscode.MarkdownString('Quelle');
                items.push(copyFileFILENAME_FROMCompletion);
                const copyFileFILENAME_TOCompletion = new vscode.CompletionItem('FILENAME_TO');
                copyFileFILENAME_TOCompletion.kind = vscode.CompletionItemKind.Field;
                copyFileFILENAME_TOCompletion.insertText = new vscode.SnippetString("FILENAME_TO = \"${1}\"");
                copyFileFILENAME_TOCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(copyFileFILENAME_TOCompletion);
            }
            if (/.*\s*copyTextCP\s*\(.*/.test(linePrefix)) {
                const copyTextCPTAB_COUNTCompletion = new vscode.CompletionItem('TAB_COUNT');
                copyTextCPTAB_COUNTCompletion.kind = vscode.CompletionItemKind.Field;
                copyTextCPTAB_COUNTCompletion.insertText = new vscode.SnippetString("TAB_COUNT = \"${1}\"");
                copyTextCPTAB_COUNTCompletion.documentation = new vscode.MarkdownString('Angabe, wie oft die Tabulator-Taste gedrueckt werden soll.');
                items.push(copyTextCPTAB_COUNTCompletion);
                const copyTextCPTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                copyTextCPTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                copyTextCPTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                copyTextCPTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Angabe, ob und wo der Clipboard Wert gespeichert werden soll.');
                items.push(copyTextCPTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*createDir\s*\(.*/.test(linePrefix)) {
                const createDirDIR_ABSOLUTE_PATHCompletion = new vscode.CompletionItem('DIR_ABSOLUTE_PATH');
                createDirDIR_ABSOLUTE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                createDirDIR_ABSOLUTE_PATHCompletion.insertText = new vscode.SnippetString("DIR_ABSOLUTE_PATH = \"${1}\"");
                createDirDIR_ABSOLUTE_PATHCompletion.documentation = new vscode.MarkdownString('Absoluter Pfad des Verzeichnisses, das erstellt werden soll');
                items.push(createDirDIR_ABSOLUTE_PATHCompletion);
                const createDirCREATE_PARENT_DIRSCompletion = new vscode.CompletionItem('CREATE_PARENT_DIRS');
                createDirCREATE_PARENT_DIRSCompletion.kind = vscode.CompletionItemKind.Field;
                createDirCREATE_PARENT_DIRSCompletion.insertText = new vscode.SnippetString("CREATE_PARENT_DIRS = \"${1}\"");
                createDirCREATE_PARENT_DIRSCompletion.documentation = new vscode.MarkdownString('Sollen nicht existierende \u00FCbergeordnete Ordner auch erstellt werden?       Falls \'false\' und \u00FCbergeordnete Ordner nicht existieren, schl\u00E4gt das Kommando fehl.       Falls \'true\', k\u00F6nnten bei einem anderweitig verursachten Fehlschlagen des Kommandos zumindest einige der \u00FCbergeordneten Verzeichnisse erstellt worden sein.      {true, false} Default: false');
                items.push(createDirCREATE_PARENT_DIRSCompletion);
            }
            if (/.*\s*csvToJson\s*\(.*/.test(linePrefix)) {
                const csvToJsonCSVCompletion = new vscode.CompletionItem('CSV');
                csvToJsonCSVCompletion.kind = vscode.CompletionItemKind.Field;
                csvToJsonCSVCompletion.insertText = new vscode.SnippetString("CSV = \"${1}\"");
                csvToJsonCSVCompletion.documentation = new vscode.MarkdownString('Inhalte im CSV Format oder Dateipfad');
                items.push(csvToJsonCSVCompletion);
                const csvToJsonIS_FILECompletion = new vscode.CompletionItem('IS_FILE');
                csvToJsonIS_FILECompletion.kind = vscode.CompletionItemKind.Field;
                csvToJsonIS_FILECompletion.insertText = new vscode.SnippetString("IS_FILE = \"${1}\"");
                csvToJsonIS_FILECompletion.documentation = new vscode.MarkdownString('Wenn true, wird ein Dateipfad zur CSV Datei erwartet. False per Default.');
                items.push(csvToJsonIS_FILECompletion);
                const csvToJsonTO_FILECompletion = new vscode.CompletionItem('TO_FILE');
                csvToJsonTO_FILECompletion.kind = vscode.CompletionItemKind.Field;
                csvToJsonTO_FILECompletion.insertText = new vscode.SnippetString("TO_FILE = \"${1}\"");
                csvToJsonTO_FILECompletion.documentation = new vscode.MarkdownString('Dateipfad, in welcher die json Datei gespeichert werden soll. Optional.');
                items.push(csvToJsonTO_FILECompletion);
                const csvToJsonTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                csvToJsonTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                csvToJsonTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                csvToJsonTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Element-Text geschrieben werden soll.');
                items.push(csvToJsonTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*deleteAllCookiesMobile\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*deleteCookiesWeb\s*\(.*/.test(linePrefix)) {
                const deleteCookiesWebURLCompletion = new vscode.CompletionItem('URL');
                deleteCookiesWebURLCompletion.kind = vscode.CompletionItemKind.Field;
                deleteCookiesWebURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                deleteCookiesWebURLCompletion.documentation = new vscode.MarkdownString('URL zu welcher die Cookies gel\u00F6scht werden sollen');
                items.push(deleteCookiesWebURLCompletion);
                const deleteCookiesWebCOOKIE_NAMECompletion = new vscode.CompletionItem('COOKIE_NAME');
                deleteCookiesWebCOOKIE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                deleteCookiesWebCOOKIE_NAMECompletion.insertText = new vscode.SnippetString("COOKIE_NAME = \"${1}\"");
                deleteCookiesWebCOOKIE_NAMECompletion.documentation = new vscode.MarkdownString('Name des zu l\u00F6schenden Cookies');
                items.push(deleteCookiesWebCOOKIE_NAMECompletion);
            }
            if (/.*\s*deleteDir\s*\(.*/.test(linePrefix)) {
                const deleteDirFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                deleteDirFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                deleteDirFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                deleteDirFILENAMECompletion.documentation = new vscode.MarkdownString('Pfad zum Ordner, der gel\u00F6scht werden soll');
                items.push(deleteDirFILENAMECompletion);
                const deleteDirMUST_DELETECompletion = new vscode.CompletionItem('MUST_DELETE');
                deleteDirMUST_DELETECompletion.kind = vscode.CompletionItemKind.Field;
                deleteDirMUST_DELETECompletion.insertText = new vscode.SnippetString("MUST_DELETE = \"${1}\"");
                deleteDirMUST_DELETECompletion.documentation = new vscode.MarkdownString('Muss etwas gel\u00F6scht werden? {true, false} Wenn true, gibt das Kommando bei einem Fehlschlagen des L\u00F6schens einen Fehler zur\u00FCck. Default: true');
                items.push(deleteDirMUST_DELETECompletion);
            }
            if (/.*\s*deleteFile\s*\(.*/.test(linePrefix)) {
                const deleteFileFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                deleteFileFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                deleteFileFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                deleteFileFILENAMECompletion.documentation = new vscode.MarkdownString('Dateiname oder Ordnername. Falls Ordnername, werden alle Dateien im Ordner gel\u00F6scht');
                items.push(deleteFileFILENAMECompletion);
                const deleteFileMUST_DELETECompletion = new vscode.CompletionItem('MUST_DELETE');
                deleteFileMUST_DELETECompletion.kind = vscode.CompletionItemKind.Field;
                deleteFileMUST_DELETECompletion.insertText = new vscode.SnippetString("MUST_DELETE = \"${1}\"");
                deleteFileMUST_DELETECompletion.documentation = new vscode.MarkdownString('Muss etwas gel\u00F6scht werden? {true, false} Default: true');
                items.push(deleteFileMUST_DELETECompletion);
                const deleteFileOLDER_THAN_DAYSCompletion = new vscode.CompletionItem('OLDER_THAN_DAYS');
                deleteFileOLDER_THAN_DAYSCompletion.kind = vscode.CompletionItemKind.Field;
                deleteFileOLDER_THAN_DAYSCompletion.insertText = new vscode.SnippetString("OLDER_THAN_DAYS = \"${1}\"");
                deleteFileOLDER_THAN_DAYSCompletion.documentation = new vscode.MarkdownString('Alle Dateien in einem Verzeichnis (angegeben \u00FCber den FILENAME) l\u00F6schen, die \u00E4lter als die angegebene Zahl Tage sind.');
                items.push(deleteFileOLDER_THAN_DAYSCompletion);
                const deleteFileDELETE_DIRECTORYCompletion = new vscode.CompletionItem('DELETE_DIRECTORY');
                deleteFileDELETE_DIRECTORYCompletion.kind = vscode.CompletionItemKind.Field;
                deleteFileDELETE_DIRECTORYCompletion.insertText = new vscode.SnippetString("DELETE_DIRECTORY = \"${1}\"");
                deleteFileDELETE_DIRECTORYCompletion.documentation = new vscode.MarkdownString('{true, false} Wenn FILENAME den Pfad eines Ordners angibt und nicht nur die Inhalte des Ordners sondern auch der Ordner selbst gel\u00F6scht werden soll,       ist hier true anzugeben. Default: false');
                items.push(deleteFileDELETE_DIRECTORYCompletion);
            }
            if (/.*\s*deleteInText\s*\(.*/.test(linePrefix)) {
                const deleteInTextTEXT_OR_FILECompletion = new vscode.CompletionItem('TEXT_OR_FILE');
                deleteInTextTEXT_OR_FILECompletion.kind = vscode.CompletionItemKind.Field;
                deleteInTextTEXT_OR_FILECompletion.insertText = new vscode.SnippetString("TEXT_OR_FILE = \"${1}\"");
                deleteInTextTEXT_OR_FILECompletion.documentation = new vscode.MarkdownString('Vollst\u00E4ndiger Text oder Dateipfad');
                items.push(deleteInTextTEXT_OR_FILECompletion);
                const deleteInTextWORDCompletion = new vscode.CompletionItem('WORD');
                deleteInTextWORDCompletion.kind = vscode.CompletionItemKind.Field;
                deleteInTextWORDCompletion.insertText = new vscode.SnippetString("WORD = \"${1}\"");
                deleteInTextWORDCompletion.documentation = new vscode.MarkdownString('Zu l\u00F6schender Text');
                items.push(deleteInTextWORDCompletion);
                const deleteInTextIS_FILECompletion = new vscode.CompletionItem('IS_FILE');
                deleteInTextIS_FILECompletion.kind = vscode.CompletionItemKind.Field;
                deleteInTextIS_FILECompletion.insertText = new vscode.SnippetString("IS_FILE = \"${1}\"");
                deleteInTextIS_FILECompletion.documentation = new vscode.MarkdownString('Angabe, ob der zu erg\u00E4nzende Text ein Dateipfad ist. Default false');
                items.push(deleteInTextIS_FILECompletion);
                const deleteInTextTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                deleteInTextTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                deleteInTextTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                deleteInTextTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der resultierende Text geschrieben wird.');
                items.push(deleteInTextTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*deleteMail\s*\(.*/.test(linePrefix)) {
                const deleteMailSERVERCompletion = new vscode.CompletionItem('SERVER');
                deleteMailSERVERCompletion.kind = vscode.CompletionItemKind.Field;
                deleteMailSERVERCompletion.insertText = new vscode.SnippetString("SERVER = \"${1}\"");
                deleteMailSERVERCompletion.documentation = new vscode.MarkdownString('Servername des Mailanbieters.');
                items.push(deleteMailSERVERCompletion);
                const deleteMailUSERCompletion = new vscode.CompletionItem('USER');
                deleteMailUSERCompletion.kind = vscode.CompletionItemKind.Field;
                deleteMailUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                deleteMailUSERCompletion.documentation = new vscode.MarkdownString('Benutzername f\u00FCr das Mailkonto');
                items.push(deleteMailUSERCompletion);
                const deleteMailPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                deleteMailPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                deleteMailPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                deleteMailPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr das Mailkonto');
                items.push(deleteMailPASSWORDCompletion);
                const deleteMailFOLDERCompletion = new vscode.CompletionItem('FOLDER');
                deleteMailFOLDERCompletion.kind = vscode.CompletionItemKind.Field;
                deleteMailFOLDERCompletion.insertText = new vscode.SnippetString("FOLDER = \"${1}\"");
                deleteMailFOLDERCompletion.documentation = new vscode.MarkdownString('Name des Ordners, auf den zugegeriffen werden soll.');
                items.push(deleteMailFOLDERCompletion);
                const deleteMailSUBJECTCompletion = new vscode.CompletionItem('SUBJECT');
                deleteMailSUBJECTCompletion.kind = vscode.CompletionItemKind.Field;
                deleteMailSUBJECTCompletion.insertText = new vscode.SnippetString("SUBJECT = \"${1}\"");
                deleteMailSUBJECTCompletion.documentation = new vscode.MarkdownString('Betreff der Mail(s), die gel\u00F6scht werden soll(en).');
                items.push(deleteMailSUBJECTCompletion);
                const deleteMailSENDERCompletion = new vscode.CompletionItem('SENDER');
                deleteMailSENDERCompletion.kind = vscode.CompletionItemKind.Field;
                deleteMailSENDERCompletion.insertText = new vscode.SnippetString("SENDER = \"${1}\"");
                deleteMailSENDERCompletion.documentation = new vscode.MarkdownString('Absender-Adresse, von welcher empfangene E-Mails gel\u00F6scht werden sollen');
                items.push(deleteMailSENDERCompletion);
                const deleteMailMUST_DELETECompletion = new vscode.CompletionItem('MUST_DELETE');
                deleteMailMUST_DELETECompletion.kind = vscode.CompletionItemKind.Field;
                deleteMailMUST_DELETECompletion.insertText = new vscode.SnippetString("MUST_DELETE = \"${1}\"");
                deleteMailMUST_DELETECompletion.documentation = new vscode.MarkdownString('Der Parameter gibt an, ob Mails gefunden und gel\u00F6scht werden m\u00FCssen.      Bei \'false\' ist das L\u00F6schen also optional. {true\/false}');
                items.push(deleteMailMUST_DELETECompletion);
                const deleteMailPORTCompletion = new vscode.CompletionItem('PORT');
                deleteMailPORTCompletion.kind = vscode.CompletionItemKind.Field;
                deleteMailPORTCompletion.insertText = new vscode.SnippetString("PORT = \"${1}\"");
                deleteMailPORTCompletion.documentation = new vscode.MarkdownString('Port des Servers');
                items.push(deleteMailPORTCompletion);
            }
            if (/.*\s*do\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*doubleClickImageCP\s*\(.*/.test(linePrefix)) {
                const doubleClickImageCPIMAGE_PATHCompletion = new vscode.CompletionItem('IMAGE_PATH');
                doubleClickImageCPIMAGE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageCPIMAGE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_PATH = \"${1}\"");
                doubleClickImageCPIMAGE_PATHCompletion.documentation = new vscode.MarkdownString('Gibt den Pfad zu dem Bild relativ zu der Testset-Datei an.');
                items.push(doubleClickImageCPIMAGE_PATHCompletion);
                const doubleClickImageCPBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                doubleClickImageCPBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageCPBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                doubleClickImageCPBASEDIRCompletion.documentation = new vscode.MarkdownString('Gibt das Basisverzeichnis an.');
                items.push(doubleClickImageCPBASEDIRCompletion);
                const doubleClickImageCPOFFSET_XCompletion = new vscode.CompletionItem('OFFSET_X');
                doubleClickImageCPOFFSET_XCompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageCPOFFSET_XCompletion.insertText = new vscode.SnippetString("OFFSET_X = \"${1}\"");
                doubleClickImageCPOFFSET_XCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach rechts (positiv) oder links (negativ)');
                items.push(doubleClickImageCPOFFSET_XCompletion);
                const doubleClickImageCPOFFSET_YCompletion = new vscode.CompletionItem('OFFSET_Y');
                doubleClickImageCPOFFSET_YCompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageCPOFFSET_YCompletion.insertText = new vscode.SnippetString("OFFSET_Y = \"${1}\"");
                doubleClickImageCPOFFSET_YCompletion.documentation = new vscode.MarkdownString('Offset vom Mittelpunkt des Bildes nach unten (positiv) oder oben (negativ)');
                items.push(doubleClickImageCPOFFSET_YCompletion);
            }
            if (/.*\s*doubleClickImageWin\s*\(.*/.test(linePrefix)) {
                const doubleClickImageWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                doubleClickImageWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                doubleClickImageWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(doubleClickImageWinWINDOW_NAMECompletion);
                const doubleClickImageWinIMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('IMAGE_RELATIVE_PATH');
                doubleClickImageWinIMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageWinIMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_RELATIVE_PATH = \"${1}\"");
                doubleClickImageWinIMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(doubleClickImageWinIMAGE_RELATIVE_PATHCompletion);
                const doubleClickImageWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                doubleClickImageWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                doubleClickImageWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(doubleClickImageWinBASEDIRCompletion);
                const doubleClickImageWinRELATIVE_XCompletion = new vscode.CompletionItem('RELATIVE_X');
                doubleClickImageWinRELATIVE_XCompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageWinRELATIVE_XCompletion.insertText = new vscode.SnippetString("RELATIVE_X = \"${1}\"");
                doubleClickImageWinRELATIVE_XCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der X-Achse. Links: Negativ. Rechts: Positiv');
                items.push(doubleClickImageWinRELATIVE_XCompletion);
                const doubleClickImageWinRELATIVE_YCompletion = new vscode.CompletionItem('RELATIVE_Y');
                doubleClickImageWinRELATIVE_YCompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageWinRELATIVE_YCompletion.insertText = new vscode.SnippetString("RELATIVE_Y = \"${1}\"");
                doubleClickImageWinRELATIVE_YCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der Y-Achse. Oben: Negativ. Unten: Positiv');
                items.push(doubleClickImageWinRELATIVE_YCompletion);
                const doubleClickImageWinMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                doubleClickImageWinMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                doubleClickImageWinMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                doubleClickImageWinMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(doubleClickImageWinMATCH_MODECompletion);
            }
            if (/.*\s*doubleclickWeb\s*\(.*/.test(linePrefix)) {
                const doubleclickWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                doubleclickWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                doubleclickWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                doubleclickWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(doubleclickWebBY_CRITERIACompletion);
                const doubleclickWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                doubleclickWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                doubleclickWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                doubleclickWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(doubleclickWebELEMENT_NAMECompletion);
                const doubleclickWebNEXT_ELEMENT_BY_CRITERIACompletion = new vscode.CompletionItem('NEXT_ELEMENT_BY_CRITERIA');
                doubleclickWebNEXT_ELEMENT_BY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                doubleclickWebNEXT_ELEMENT_BY_CRITERIACompletion.insertText = new vscode.SnippetString("NEXT_ELEMENT_BY_CRITERIA = \"${1}\"");
                doubleclickWebNEXT_ELEMENT_BY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das n\u00E4chste Element ermittelt werden soll.');
                items.push(doubleclickWebNEXT_ELEMENT_BY_CRITERIACompletion);
                const doubleclickWebNEXT_ELEMENT_NAMECompletion = new vscode.CompletionItem('NEXT_ELEMENT_NAME');
                doubleclickWebNEXT_ELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                doubleclickWebNEXT_ELEMENT_NAMECompletion.insertText = new vscode.SnippetString("NEXT_ELEMENT_NAME = \"${1}\"");
                doubleclickWebNEXT_ELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Name des n\u00E4chsten Elements, das nach dem Klicken auf das eigentliche Element verf\u00FCgbar sein soll.');
                items.push(doubleclickWebNEXT_ELEMENT_NAMECompletion);
                const doubleclickWebUSE_REAL_CLICKSCompletion = new vscode.CompletionItem('USE_REAL_CLICKS');
                doubleclickWebUSE_REAL_CLICKSCompletion.kind = vscode.CompletionItemKind.Field;
                doubleclickWebUSE_REAL_CLICKSCompletion.insertText = new vscode.SnippetString("USE_REAL_CLICKS = \"${1}\"");
                doubleclickWebUSE_REAL_CLICKSCompletion.documentation = new vscode.MarkdownString('Wenn true, werden zwei Selenium-Klicks einzeln hintereinander ausgef\u00FChrt. Wenn false, wird direkt die DoubleClick-Funktion von Selenium aufgerufen (Default: false).');
                items.push(doubleclickWebUSE_REAL_CLICKSCompletion);
            }
            if (/.*\s*dragAndDropWeb\s*\(.*/.test(linePrefix)) {
                const dragAndDropWebSTART_BY_CRITERIACompletion = new vscode.CompletionItem('START_BY_CRITERIA');
                dragAndDropWebSTART_BY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                dragAndDropWebSTART_BY_CRITERIACompletion.insertText = new vscode.SnippetString("START_BY_CRITERIA = \"${1}\"");
                dragAndDropWebSTART_BY_CRITERIACompletion.documentation = new vscode.MarkdownString('Suchstrategie f\u00FCr das Anfangselement.');
                items.push(dragAndDropWebSTART_BY_CRITERIACompletion);
                const dragAndDropWebSTART_ELEMENT_NAMECompletion = new vscode.CompletionItem('START_ELEMENT_NAME');
                dragAndDropWebSTART_ELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                dragAndDropWebSTART_ELEMENT_NAMECompletion.insertText = new vscode.SnippetString("START_ELEMENT_NAME = \"${1}\"");
                dragAndDropWebSTART_ELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Das Anfangselement.');
                items.push(dragAndDropWebSTART_ELEMENT_NAMECompletion);
                const dragAndDropWebEND_BY_CRITERIACompletion = new vscode.CompletionItem('END_BY_CRITERIA');
                dragAndDropWebEND_BY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                dragAndDropWebEND_BY_CRITERIACompletion.insertText = new vscode.SnippetString("END_BY_CRITERIA = \"${1}\"");
                dragAndDropWebEND_BY_CRITERIACompletion.documentation = new vscode.MarkdownString('Suchstrategie f\u00FCr das Zielelement.');
                items.push(dragAndDropWebEND_BY_CRITERIACompletion);
                const dragAndDropWebEND_ELEMENT_NAMECompletion = new vscode.CompletionItem('END_ELEMENT_NAME');
                dragAndDropWebEND_ELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                dragAndDropWebEND_ELEMENT_NAMECompletion.insertText = new vscode.SnippetString("END_ELEMENT_NAME = \"${1}\"");
                dragAndDropWebEND_ELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Das Zielelement.');
                items.push(dragAndDropWebEND_ELEMENT_NAMECompletion);
                const dragAndDropWebWITH_OFFSETCompletion = new vscode.CompletionItem('WITH_OFFSET');
                dragAndDropWebWITH_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                dragAndDropWebWITH_OFFSETCompletion.insertText = new vscode.SnippetString("WITH_OFFSET = \"${1}\"");
                dragAndDropWebWITH_OFFSETCompletion.documentation = new vscode.MarkdownString('{true, false} Gibt an, ob mit Offset verschoben werden soll. Default: false.');
                items.push(dragAndDropWebWITH_OFFSETCompletion);
                const dragAndDropWebEND_OFFSET_XCompletion = new vscode.CompletionItem('END_OFFSET_X');
                dragAndDropWebEND_OFFSET_XCompletion.kind = vscode.CompletionItemKind.Field;
                dragAndDropWebEND_OFFSET_XCompletion.insertText = new vscode.SnippetString("END_OFFSET_X = \"${1}\"");
                dragAndDropWebEND_OFFSET_XCompletion.documentation = new vscode.MarkdownString('X-Offset');
                items.push(dragAndDropWebEND_OFFSET_XCompletion);
                const dragAndDropWebEND_OFFSET_YCompletion = new vscode.CompletionItem('END_OFFSET_Y');
                dragAndDropWebEND_OFFSET_YCompletion.kind = vscode.CompletionItemKind.Field;
                dragAndDropWebEND_OFFSET_YCompletion.insertText = new vscode.SnippetString("END_OFFSET_Y = \"${1}\"");
                dragAndDropWebEND_OFFSET_YCompletion.documentation = new vscode.MarkdownString('Y-Offset');
                items.push(dragAndDropWebEND_OFFSET_YCompletion);
            }
            if (/.*\s*dragByCoordinates\s*\(.*/.test(linePrefix)) {
                const dragByCoordinatesWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                dragByCoordinatesWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                dragByCoordinatesWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                dragByCoordinatesWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(dragByCoordinatesWINDOW_NAMECompletion);
                const dragByCoordinatesMOVE_FROM_XCompletion = new vscode.CompletionItem('MOVE_FROM_X');
                dragByCoordinatesMOVE_FROM_XCompletion.kind = vscode.CompletionItemKind.Field;
                dragByCoordinatesMOVE_FROM_XCompletion.insertText = new vscode.SnippetString("MOVE_FROM_X = \"${1}\"");
                dragByCoordinatesMOVE_FROM_XCompletion.documentation = new vscode.MarkdownString('Position (X-Koordinate), von wo aus das Bild verschoben werden soll.');
                items.push(dragByCoordinatesMOVE_FROM_XCompletion);
                const dragByCoordinatesMOVE_FROM_YCompletion = new vscode.CompletionItem('MOVE_FROM_Y');
                dragByCoordinatesMOVE_FROM_YCompletion.kind = vscode.CompletionItemKind.Field;
                dragByCoordinatesMOVE_FROM_YCompletion.insertText = new vscode.SnippetString("MOVE_FROM_Y = \"${1}\"");
                dragByCoordinatesMOVE_FROM_YCompletion.documentation = new vscode.MarkdownString('Position (Y-Koordinate), von wo aus das Bild verschoben werden soll.');
                items.push(dragByCoordinatesMOVE_FROM_YCompletion);
                const dragByCoordinatesMOVE_TO_XCompletion = new vscode.CompletionItem('MOVE_TO_X');
                dragByCoordinatesMOVE_TO_XCompletion.kind = vscode.CompletionItemKind.Field;
                dragByCoordinatesMOVE_TO_XCompletion.insertText = new vscode.SnippetString("MOVE_TO_X = \"${1}\"");
                dragByCoordinatesMOVE_TO_XCompletion.documentation = new vscode.MarkdownString('Position (X-Koordinate), wohin das Bild verschoben werden soll.');
                items.push(dragByCoordinatesMOVE_TO_XCompletion);
                const dragByCoordinatesMOVE_TO_YCompletion = new vscode.CompletionItem('MOVE_TO_Y');
                dragByCoordinatesMOVE_TO_YCompletion.kind = vscode.CompletionItemKind.Field;
                dragByCoordinatesMOVE_TO_YCompletion.insertText = new vscode.SnippetString("MOVE_TO_Y = \"${1}\"");
                dragByCoordinatesMOVE_TO_YCompletion.documentation = new vscode.MarkdownString('Position (Y-Koordinate), wohin das Bild verschoben werden soll.');
                items.push(dragByCoordinatesMOVE_TO_YCompletion);
            }
            if (/.*\s*dragByImageWin\s*\(.*/.test(linePrefix)) {
                const dragByImageWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                dragByImageWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                dragByImageWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                dragByImageWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(dragByImageWinWINDOW_NAMECompletion);
                const dragByImageWinSTART_IMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('START_IMAGE_RELATIVE_PATH');
                dragByImageWinSTART_IMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                dragByImageWinSTART_IMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("START_IMAGE_RELATIVE_PATH = \"${1}\"");
                dragByImageWinSTART_IMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zum Startbild ');
                items.push(dragByImageWinSTART_IMAGE_RELATIVE_PATHCompletion);
                const dragByImageWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                dragByImageWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                dragByImageWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                dragByImageWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(dragByImageWinBASEDIRCompletion);
                const dragByImageWinMOVE_TO_XCompletion = new vscode.CompletionItem('MOVE_TO_X');
                dragByImageWinMOVE_TO_XCompletion.kind = vscode.CompletionItemKind.Field;
                dragByImageWinMOVE_TO_XCompletion.insertText = new vscode.SnippetString("MOVE_TO_X = \"${1}\"");
                dragByImageWinMOVE_TO_XCompletion.documentation = new vscode.MarkdownString('Position (X-Koordinate), wohin das Bild verschoben werden soll oder Offset bei Zielbild.');
                items.push(dragByImageWinMOVE_TO_XCompletion);
                const dragByImageWinMOVE_TO_YCompletion = new vscode.CompletionItem('MOVE_TO_Y');
                dragByImageWinMOVE_TO_YCompletion.kind = vscode.CompletionItemKind.Field;
                dragByImageWinMOVE_TO_YCompletion.insertText = new vscode.SnippetString("MOVE_TO_Y = \"${1}\"");
                dragByImageWinMOVE_TO_YCompletion.documentation = new vscode.MarkdownString('Position (Y-Koordinate), wohin das Bild verschoben werden soll oder Offset bei Zielbild.');
                items.push(dragByImageWinMOVE_TO_YCompletion);
                const dragByImageWinTARGET_IMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('TARGET_IMAGE_RELATIVE_PATH');
                dragByImageWinTARGET_IMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                dragByImageWinTARGET_IMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("TARGET_IMAGE_RELATIVE_PATH = \"${1}\"");
                dragByImageWinTARGET_IMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zum Zielbild ');
                items.push(dragByImageWinTARGET_IMAGE_RELATIVE_PATHCompletion);
                const dragByImageWinMOVE_SPEEDCompletion = new vscode.CompletionItem('MOVE_SPEED');
                dragByImageWinMOVE_SPEEDCompletion.kind = vscode.CompletionItemKind.Field;
                dragByImageWinMOVE_SPEEDCompletion.insertText = new vscode.SnippetString("MOVE_SPEED = \"${1}\"");
                dragByImageWinMOVE_SPEEDCompletion.documentation = new vscode.MarkdownString('Mausgeschwindigkeit der Bewegung (0 schnell, 100 langsam, default 25)');
                items.push(dragByImageWinMOVE_SPEEDCompletion);
            }
            if (/.*\s*else\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*elseIf\s*\(.*/.test(linePrefix)) {
                const elseIfACCEPTABLE_RESULT_LEVELSCompletion = new vscode.CompletionItem('ACCEPTABLE_RESULT_LEVELS');
                elseIfACCEPTABLE_RESULT_LEVELSCompletion.kind = vscode.CompletionItemKind.Field;
                elseIfACCEPTABLE_RESULT_LEVELSCompletion.insertText = new vscode.SnippetString("ACCEPTABLE_RESULT_LEVELS = \"${1}\"");
                elseIfACCEPTABLE_RESULT_LEVELSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(elseIfACCEPTABLE_RESULT_LEVELSCompletion);
            }
            if (/.*\s*empty\s*\(.*/.test(linePrefix)) {
                const emptyVALUECompletion = new vscode.CompletionItem('VALUE');
                emptyVALUECompletion.kind = vscode.CompletionItemKind.Field;
                emptyVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                emptyVALUECompletion.documentation = new vscode.MarkdownString('Zu \u00FCberpr\u00FCfender Parameter');
                items.push(emptyVALUECompletion);
            }
            if (/.*\s*emptyOrUndeclared\s*\(.*/.test(linePrefix)) {
                const emptyOrUndeclaredVALUECompletion = new vscode.CompletionItem('VALUE');
                emptyOrUndeclaredVALUECompletion.kind = vscode.CompletionItemKind.Field;
                emptyOrUndeclaredVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                emptyOrUndeclaredVALUECompletion.documentation = new vscode.MarkdownString('Zu \u00FCberpr\u00FCfender Parameter');
                items.push(emptyOrUndeclaredVALUECompletion);
            }
            if (/.*\s*endsWithAlpha\s*\(.*/.test(linePrefix)) {
                const endsWithAlphaTEXTCompletion = new vscode.CompletionItem('TEXT');
                endsWithAlphaTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                endsWithAlphaTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                endsWithAlphaTEXTCompletion.documentation = new vscode.MarkdownString('Zu \u00FCberpr\u00FCfender Text.');
                items.push(endsWithAlphaTEXTCompletion);
                const endsWithAlphaSUFFIXCompletion = new vscode.CompletionItem('SUFFIX');
                endsWithAlphaSUFFIXCompletion.kind = vscode.CompletionItemKind.Field;
                endsWithAlphaSUFFIXCompletion.insertText = new vscode.SnippetString("SUFFIX = \"${1}\"");
                endsWithAlphaSUFFIXCompletion.documentation = new vscode.MarkdownString('M\u00F6glicher Teil-Text, mit dem TEXT endet.');
                items.push(endsWithAlphaSUFFIXCompletion);
                const endsWithAlphaTRIM_TEXTCompletion = new vscode.CompletionItem('TRIM_TEXT');
                endsWithAlphaTRIM_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                endsWithAlphaTRIM_TEXTCompletion.insertText = new vscode.SnippetString("TRIM_TEXT = \"${1}\"");
                endsWithAlphaTRIM_TEXTCompletion.documentation = new vscode.MarkdownString('Sollen vor- und nachgestellte Leerzeichen in TEXT ignoriert werden? {true, false} Default: true');
                items.push(endsWithAlphaTRIM_TEXTCompletion);
                const endsWithAlphaTRIM_SUFFIXCompletion = new vscode.CompletionItem('TRIM_SUFFIX');
                endsWithAlphaTRIM_SUFFIXCompletion.kind = vscode.CompletionItemKind.Field;
                endsWithAlphaTRIM_SUFFIXCompletion.insertText = new vscode.SnippetString("TRIM_SUFFIX = \"${1}\"");
                endsWithAlphaTRIM_SUFFIXCompletion.documentation = new vscode.MarkdownString('Sollen vor- und nachgestellte Leerzeichen in SUFFIX ignoriert werden? {true, false} Default: true');
                items.push(endsWithAlphaTRIM_SUFFIXCompletion);
            }
            if (/.*\s*equalsAlpha\s*\(.*/.test(linePrefix)) {
                const equalsAlphaLEFTCompletion = new vscode.CompletionItem('LEFT');
                equalsAlphaLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsAlphaLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                equalsAlphaLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.{EMPTY} eingeben f\u00FCr ein leeres Parameter');
                items.push(equalsAlphaLEFTCompletion);
                const equalsAlphaRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                equalsAlphaRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsAlphaRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                equalsAlphaRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll. {EMPTY} eingeben f\u00FCr ein leeres Parameter');
                items.push(equalsAlphaRIGHTCompletion);
                const equalsAlphaIGNORE_CASECompletion = new vscode.CompletionItem('IGNORE_CASE');
                equalsAlphaIGNORE_CASECompletion.kind = vscode.CompletionItemKind.Field;
                equalsAlphaIGNORE_CASECompletion.insertText = new vscode.SnippetString("IGNORE_CASE = \"${1}\"");
                equalsAlphaIGNORE_CASECompletion.documentation = new vscode.MarkdownString('Gro\u00DF- und Kleinschreibung soll ignoriert werden (Default: true)');
                items.push(equalsAlphaIGNORE_CASECompletion);
                const equalsAlphaTRIM_LEFTCompletion = new vscode.CompletionItem('TRIM_LEFT');
                equalsAlphaTRIM_LEFTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsAlphaTRIM_LEFTCompletion.insertText = new vscode.SnippetString("TRIM_LEFT = \"${1}\"");
                equalsAlphaTRIM_LEFTCompletion.documentation = new vscode.MarkdownString('Leerzeichen an Beginn und Ende von LEFT vor dem Vergleich abschneiden (Default: false)');
                items.push(equalsAlphaTRIM_LEFTCompletion);
                const equalsAlphaTRIM_RIGHTCompletion = new vscode.CompletionItem('TRIM_RIGHT');
                equalsAlphaTRIM_RIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsAlphaTRIM_RIGHTCompletion.insertText = new vscode.SnippetString("TRIM_RIGHT = \"${1}\"");
                equalsAlphaTRIM_RIGHTCompletion.documentation = new vscode.MarkdownString('Leerzeichen an Beginn und Ende von RIGHT vor dem Vergleich abschneiden (Default: false)');
                items.push(equalsAlphaTRIM_RIGHTCompletion);
            }
            if (/.*\s*equalsAlphaIgnoreCase\s*\(.*/.test(linePrefix)) {
                const equalsAlphaIgnoreCaseTEXT1Completion = new vscode.CompletionItem('TEXT1');
                equalsAlphaIgnoreCaseTEXT1Completion.kind = vscode.CompletionItemKind.Field;
                equalsAlphaIgnoreCaseTEXT1Completion.insertText = new vscode.SnippetString("TEXT1 = \"${1}\"");
                equalsAlphaIgnoreCaseTEXT1Completion.documentation = new vscode.MarkdownString('Erstes Wort oder erster Text, der verglichen werden soll');
                items.push(equalsAlphaIgnoreCaseTEXT1Completion);
                const equalsAlphaIgnoreCaseTEXT2Completion = new vscode.CompletionItem('TEXT2');
                equalsAlphaIgnoreCaseTEXT2Completion.kind = vscode.CompletionItemKind.Field;
                equalsAlphaIgnoreCaseTEXT2Completion.insertText = new vscode.SnippetString("TEXT2 = \"${1}\"");
                equalsAlphaIgnoreCaseTEXT2Completion.documentation = new vscode.MarkdownString('Zweites Wort oder zweiter Text, der verglichen werden soll');
                items.push(equalsAlphaIgnoreCaseTEXT2Completion);
            }
            if (/.*\s*equalsDate\s*\(.*/.test(linePrefix)) {
                const equalsDateLEFTCompletion = new vscode.CompletionItem('LEFT');
                equalsDateLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsDateLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                equalsDateLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(equalsDateLEFTCompletion);
                const equalsDateRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                equalsDateRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsDateRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                equalsDateRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(equalsDateRIGHTCompletion);
            }
            if (/.*\s*equalsNum\s*\(.*/.test(linePrefix)) {
                const equalsNumLEFTCompletion = new vscode.CompletionItem('LEFT');
                equalsNumLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsNumLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                equalsNumLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(equalsNumLEFTCompletion);
                const equalsNumRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                equalsNumRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsNumRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                equalsNumRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(equalsNumRIGHTCompletion);
                const equalsNumEPSILONCompletion = new vscode.CompletionItem('EPSILON');
                equalsNumEPSILONCompletion.kind = vscode.CompletionItemKind.Field;
                equalsNumEPSILONCompletion.insertText = new vscode.SnippetString("EPSILON = \"${1}\"");
                equalsNumEPSILONCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der eine angibt, um welchen Betrag LEFT und RIGHT voneinander abweichen d\u00FCrfen. Default: 0.0');
                items.push(equalsNumEPSILONCompletion);
            }
            if (/.*\s*equalsRegex\s*\(.*/.test(linePrefix)) {
                const equalsRegexLEFTCompletion = new vscode.CompletionItem('LEFT');
                equalsRegexLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsRegexLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                equalsRegexLEFTCompletion.documentation = new vscode.MarkdownString('String, in dem gesucht wird.');
                items.push(equalsRegexLEFTCompletion);
                const equalsRegexRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                equalsRegexRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsRegexRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                equalsRegexRIGHTCompletion.documentation = new vscode.MarkdownString('Regul\u00E4rer Ausdruck, nach dem gesucht wird.');
                items.push(equalsRegexRIGHTCompletion);
                const equalsRegexSHORT_OUTPUTCompletion = new vscode.CompletionItem('SHORT_OUTPUT');
                equalsRegexSHORT_OUTPUTCompletion.kind = vscode.CompletionItemKind.Field;
                equalsRegexSHORT_OUTPUTCompletion.insertText = new vscode.SnippetString("SHORT_OUTPUT = \"${1}\"");
                equalsRegexSHORT_OUTPUTCompletion.documentation = new vscode.MarkdownString('Kurzes Ausgeben');
                items.push(equalsRegexSHORT_OUTPUTCompletion);
            }
            if (/.*\s*evaluate\s*\(.*/.test(linePrefix)) {
                const evaluateFILEPATH_OR_SCRIPTCompletion = new vscode.CompletionItem('FILEPATH_OR_SCRIPT');
                evaluateFILEPATH_OR_SCRIPTCompletion.kind = vscode.CompletionItemKind.Field;
                evaluateFILEPATH_OR_SCRIPTCompletion.insertText = new vscode.SnippetString("FILEPATH_OR_SCRIPT = \"${1}\"");
                evaluateFILEPATH_OR_SCRIPTCompletion.documentation = new vscode.MarkdownString('Groovy-Skript, das ausgef\u00FChrt werden soll oder Pfad zu einer .groovy-Datei, die dieses Skript enth\u00E4lt.      Bei einem Dateipfad muss der Parameterwert mit \'.groovy\' enden. Der Pfad kann absolut oder auch relativ zum Verzeichnis angegeben werden, das das Testset enth\u00E4lt.       Verzeichnisnamen in absoluten Pfade d\u00FCrfen unter Unix\/Linux\/MacOS nur durch \'\/\' getrennt werden, nicht durch \'\'.                Handelt es sich um eine einzelne Rechenoperation, wird dieser Wert zur\u00FCckgegeben.      Bei komplexeren Skripten muss das return-Statement verwendet werden.      Soll im Skript ein Wert aus einer Storage Variable als String verwendet werden, so muss dieser      bereits mit single quotes, double quotes oder forward slashes versehen sein. Darauf ist      insbesondere zu achten, wenn die Variable bspw. in einer Schleife durch das Groovy Skript mehrfach      ver\u00E4ndert wird. Soll also die Groovy-Ausgabe in einer Storage Variable f\u00FCr weitere Skripte als Text      weiterverwendet werden, muss das Ergebnis entsprechend mit quotes versehen werden.');
                items.push(evaluateFILEPATH_OR_SCRIPTCompletion);
                const evaluateAVAILABLE_STORAGE_VARIABLESCompletion = new vscode.CompletionItem('AVAILABLE_STORAGE_VARIABLES');
                evaluateAVAILABLE_STORAGE_VARIABLESCompletion.kind = vscode.CompletionItemKind.Field;
                evaluateAVAILABLE_STORAGE_VARIABLESCompletion.insertText = new vscode.SnippetString("AVAILABLE_STORAGE_VARIABLES = \"${1}\"");
                evaluateAVAILABLE_STORAGE_VARIABLESCompletion.documentation = new vscode.MarkdownString('Angabe der Variablen aus der Storage-Datei, die im Groovy Script verf\u00FCgbar sein sollen.       Werden einzelne Variablennamen angegeben, sind diese durch einfaches Komma (,) zu trennen.      Bei Angabe von \'ALL\' werden alle Variablen, die aktuell in der Storage-Datei abgelegt sind, zur Verf\u00FCgung gestellt.      Im Groovy-Script k\u00F6nnen diese Variablen durch direkte Nennung wie native Groovy-Variablen verwendet werden.      Gibt es also zum Beispiel in der Storage-Dateu ein Schl\u00FCssel-Wert-Paar \'abc=123\'       und wird AVAILABLE_STORAGE_VARIABLES=ALL oder AVAILABLE_STORAGE_VARIABLES=abc gesetzt,       so f\u00FChrt eine Ausf\u00FChrung eines Groovy-Scripts wie \'return abc;\' zum R\u00FCckgabewert \'123\'.');
                items.push(evaluateAVAILABLE_STORAGE_VARIABLESCompletion);
                const evaluateBOOLEAN_CHECKCompletion = new vscode.CompletionItem('BOOLEAN_CHECK');
                evaluateBOOLEAN_CHECKCompletion.kind = vscode.CompletionItemKind.Field;
                evaluateBOOLEAN_CHECKCompletion.insertText = new vscode.SnippetString("BOOLEAN_CHECK = \"${1}\"");
                evaluateBOOLEAN_CHECKCompletion.documentation = new vscode.MarkdownString('Falls dieser Parameter den Wert \'true\', wird \u00FCberpr\u00FCft ob das Resultat der Auswertung des Groovy-Skriptes den booleschen Wert \'true\' hat.      Sollte dies dann nicht der Fall sein, schl\u00E4gt das Kommando fehl.');
                items.push(evaluateBOOLEAN_CHECKCompletion);
                const evaluateADDITIONAL_CLASSPATHCompletion = new vscode.CompletionItem('ADDITIONAL_CLASSPATH');
                evaluateADDITIONAL_CLASSPATHCompletion.kind = vscode.CompletionItemKind.Field;
                evaluateADDITIONAL_CLASSPATHCompletion.insertText = new vscode.SnippetString("ADDITIONAL_CLASSPATH = \"${1}\"");
                evaluateADDITIONAL_CLASSPATHCompletion.documentation = new vscode.MarkdownString('Mit dieser Option k\u00F6nnen weitere Klassenpfade zur Groovy-Laufzeitumgebung hinzugef\u00FCgt werden, um weitere Bibliotheken einzuladen.\r\nWird mehr als ein Pfad ben\u00F6tigt, werden einzelne Eintr\u00E4ge mit einem Semikolon (`;`) voneinander getrennt. Etwaiger Whitespace vor und nach einem Semikolon sowie am Anfang und Ende des an diesen Parameter \u00FCbergebenen Wertes wird automatisch entfernt.\r\n**Hinweise:** Java-Quelldateien (i. d. R. `.java`) werden *nicht* automatisch geladen, sondern m\u00FCssen entweder \'lose\' als kompilierte `.class`-Dateien in einem \u00FCbergebenen Verzeichnis, oder zusammengefasst als `.jar`-Datei vorliegen. Etwaige `.jar`-Dateien m\u00FCssen *explizit einzeln* \u00FCbergeben werden (es reicht \u2013 im Gegensatz zu `.class`- und `.groovy`-Dateien \u2013 nicht, wenn Sie nur in einem \u00FCbergebenen Verzeichnis liegen).\r\n**Beispiel**\r\nMit diesem `ADDITIONAL_CLASSPATH`-Eintrag w\u00FCrden alle `.groovy`- und `.class`-Dateien aus dem Verzeichnis `D:\/lib` sowie die Datei `D:\/lib\/myLib.jar` zur Laufzeitumgebung hinzugef\u00FCgt werden:\r\n``` D:\/lib; D:\/lib\/myLib.jar ```');
                items.push(evaluateADDITIONAL_CLASSPATHCompletion);
                const evaluateRESOLVE_SCRIPTCompletion = new vscode.CompletionItem('RESOLVE_SCRIPT');
                evaluateRESOLVE_SCRIPTCompletion.kind = vscode.CompletionItemKind.Field;
                evaluateRESOLVE_SCRIPTCompletion.insertText = new vscode.SnippetString("RESOLVE_SCRIPT = \"${1}\"");
                evaluateRESOLVE_SCRIPTCompletion.documentation = new vscode.MarkdownString('Hier kann optional die Ersetzungen des Storage Resolver abgeschaltet werden, damit der Code exakt wie aus der Datei verwendet wird. Default ist: true (Resolution active)');
                items.push(evaluateRESOLVE_SCRIPTCompletion);
                const evaluateENCODING_TEXTCompletion = new vscode.CompletionItem('ENCODING_TEXT');
                evaluateENCODING_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                evaluateENCODING_TEXTCompletion.insertText = new vscode.SnippetString("ENCODING_TEXT = \"${1}\"");
                evaluateENCODING_TEXTCompletion.documentation = new vscode.MarkdownString('Hier kann optional angegeben werden, welche encoding unterst\u00FCtzt werden soll');
                items.push(evaluateENCODING_TEXTCompletion);
                const evaluateTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                evaluateTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                evaluateTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                evaluateTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein neuer Schl\u00FCssel gesetzt werden, unter dem der R\u00FCckgabewert der Groovy-Auswertung gespeichert wird.');
                items.push(evaluateTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*excelWriteCell\s*\(.*/.test(linePrefix)) {
                const excelWriteCellFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                excelWriteCellFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                excelWriteCellFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                excelWriteCellFILENAMECompletion.documentation = new vscode.MarkdownString('Pfad zur Excel-Datei, in die der \u00FCbergebene Wert eingetragen werden soll.');
                items.push(excelWriteCellFILENAMECompletion);
                const excelWriteCellSHEET_INDEXCompletion = new vscode.CompletionItem('SHEET_INDEX');
                excelWriteCellSHEET_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                excelWriteCellSHEET_INDEXCompletion.insertText = new vscode.SnippetString("SHEET_INDEX = \"${1}\"");
                excelWriteCellSHEET_INDEXCompletion.documentation = new vscode.MarkdownString('Index (Nummer) des Tabellenblatts in welches geschrieben werden soll.');
                items.push(excelWriteCellSHEET_INDEXCompletion);
                const excelWriteCellROW_INDEXCompletion = new vscode.CompletionItem('ROW_INDEX');
                excelWriteCellROW_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                excelWriteCellROW_INDEXCompletion.insertText = new vscode.SnippetString("ROW_INDEX = \"${1}\"");
                excelWriteCellROW_INDEXCompletion.documentation = new vscode.MarkdownString('Index (Nummer) der Zeile, in der sich die Zelle befindet, in welche der Wert     eingetragen werden soll, der mit Hilfe des 2. Parameters \u00FCbergeben wurde.');
                items.push(excelWriteCellROW_INDEXCompletion);
                const excelWriteCellCOLUMN_INDEXCompletion = new vscode.CompletionItem('COLUMN_INDEX');
                excelWriteCellCOLUMN_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                excelWriteCellCOLUMN_INDEXCompletion.insertText = new vscode.SnippetString("COLUMN_INDEX = \"${1}\"");
                excelWriteCellCOLUMN_INDEXCompletion.documentation = new vscode.MarkdownString('Index (Nummer) der Spalte, in der sich die Zelle befindet, in welche der Wert     eingetragen werden soll, der mit Hilfe des 2. Parameters \u00FCbergeben wurde.');
                items.push(excelWriteCellCOLUMN_INDEXCompletion);
                const excelWriteCellVALUECompletion = new vscode.CompletionItem('VALUE');
                excelWriteCellVALUECompletion.kind = vscode.CompletionItemKind.Field;
                excelWriteCellVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                excelWriteCellVALUECompletion.documentation = new vscode.MarkdownString('Der zu schreibende Wert.');
                items.push(excelWriteCellVALUECompletion);
            }
            if (/.*\s*excelWriterFromDatabase\s*\(.*/.test(linePrefix)) {
                const excelWriterFromDatabaseJDBC_URLCompletion = new vscode.CompletionItem('JDBC_URL');
                excelWriterFromDatabaseJDBC_URLCompletion.kind = vscode.CompletionItemKind.Field;
                excelWriterFromDatabaseJDBC_URLCompletion.insertText = new vscode.SnippetString("JDBC_URL = \"${1}\"");
                excelWriterFromDatabaseJDBC_URLCompletion.documentation = new vscode.MarkdownString('JDBC URL der auszulesenden Datenbank. (Zu Setzen bei Verwendung einer Oracle DB)');
                items.push(excelWriterFromDatabaseJDBC_URLCompletion);
                const excelWriterFromDatabaseEXCEL_FILENAMECompletion = new vscode.CompletionItem('EXCEL_FILENAME');
                excelWriterFromDatabaseEXCEL_FILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                excelWriterFromDatabaseEXCEL_FILENAMECompletion.insertText = new vscode.SnippetString("EXCEL_FILENAME = \"${1}\"");
                excelWriterFromDatabaseEXCEL_FILENAMECompletion.documentation = new vscode.MarkdownString('Dateipfad der Ziel-Excel-Datei');
                items.push(excelWriterFromDatabaseEXCEL_FILENAMECompletion);
                const excelWriterFromDatabaseCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                excelWriterFromDatabaseCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                excelWriterFromDatabaseCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                excelWriterFromDatabaseCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Statt JDBC_URL zu setzen wenn keine Oracle DB verwendet wird.');
                items.push(excelWriterFromDatabaseCONNECTION_NAMECompletion);
                const excelWriterFromDatabaseSQL_STATEMENTCompletion = new vscode.CompletionItem('SQL_STATEMENT');
                excelWriterFromDatabaseSQL_STATEMENTCompletion.kind = vscode.CompletionItemKind.Field;
                excelWriterFromDatabaseSQL_STATEMENTCompletion.insertText = new vscode.SnippetString("SQL_STATEMENT = \"${1}\"");
                excelWriterFromDatabaseSQL_STATEMENTCompletion.documentation = new vscode.MarkdownString('Datenbankabfrage. Nur die erste Anfrage wird ausgef\u00FChrt.');
                items.push(excelWriterFromDatabaseSQL_STATEMENTCompletion);
                const excelWriterFromDatabaseSQL_JSON_PARAMETERSCompletion = new vscode.CompletionItem('SQL_JSON_PARAMETERS');
                excelWriterFromDatabaseSQL_JSON_PARAMETERSCompletion.kind = vscode.CompletionItemKind.Field;
                excelWriterFromDatabaseSQL_JSON_PARAMETERSCompletion.insertText = new vscode.SnippetString("SQL_JSON_PARAMETERS = \"${1}\"");
                excelWriterFromDatabaseSQL_JSON_PARAMETERSCompletion.documentation = new vscode.MarkdownString('Named Parameters in JSON-format zur Verwendung bei parametrisierten Statements, z. B. {name:Peter,age:30}');
                items.push(excelWriterFromDatabaseSQL_JSON_PARAMETERSCompletion);
            }
            if (/.*\s*executeApplicationWin\s*\(.*/.test(linePrefix)) {
                const executeApplicationWinEXPECTED_WINDOW_NAMECompletion = new vscode.CompletionItem('EXPECTED_WINDOW_NAME');
                executeApplicationWinEXPECTED_WINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                executeApplicationWinEXPECTED_WINDOW_NAMECompletion.insertText = new vscode.SnippetString("EXPECTED_WINDOW_NAME = \"${1}\"");
                executeApplicationWinEXPECTED_WINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das erwartet wird.');
                items.push(executeApplicationWinEXPECTED_WINDOW_NAMECompletion);
                const executeApplicationWinEXECUTABLE_PATHCompletion = new vscode.CompletionItem('EXECUTABLE_PATH');
                executeApplicationWinEXECUTABLE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                executeApplicationWinEXECUTABLE_PATHCompletion.insertText = new vscode.SnippetString("EXECUTABLE_PATH = \"${1}\"");
                executeApplicationWinEXECUTABLE_PATHCompletion.documentation = new vscode.MarkdownString('Dateipfad der Anwendung');
                items.push(executeApplicationWinEXECUTABLE_PATHCompletion);
                const executeApplicationWinPATH_IS_RELATIVECompletion = new vscode.CompletionItem('PATH_IS_RELATIVE');
                executeApplicationWinPATH_IS_RELATIVECompletion.kind = vscode.CompletionItemKind.Field;
                executeApplicationWinPATH_IS_RELATIVECompletion.insertText = new vscode.SnippetString("PATH_IS_RELATIVE = \"${1}\"");
                executeApplicationWinPATH_IS_RELATIVECompletion.documentation = new vscode.MarkdownString('Dateipfad wird relativ zum Skript angewendet, wenn auf \'true\' gesetzt');
                items.push(executeApplicationWinPATH_IS_RELATIVECompletion);
                const executeApplicationWinWAIT_MILLISECONDSCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS');
                executeApplicationWinWAIT_MILLISECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                executeApplicationWinWAIT_MILLISECONDSCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS = \"${1}\"");
                executeApplicationWinWAIT_MILLISECONDSCompletion.documentation = new vscode.MarkdownString('Zeit (in Millisekunden), die gewartet werden soll, bis das Fenster offen ist. Falls das Fenster nicht in der Zeit ge\u00F6ffnet wird, wird das Kommando einen Fehler melden.');
                items.push(executeApplicationWinWAIT_MILLISECONDSCompletion);
                const executeApplicationWinMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                executeApplicationWinMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                executeApplicationWinMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                executeApplicationWinMATCH_MODECompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(executeApplicationWinMATCH_MODECompletion);
            }
            if (/.*\s*executeJCL\s*\(.*/.test(linePrefix)) {
                const executeJCLJCLFILECompletion = new vscode.CompletionItem('JCLFILE');
                executeJCLJCLFILECompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLJCLFILECompletion.insertText = new vscode.SnippetString("JCLFILE = \"${1}\"");
                executeJCLJCLFILECompletion.documentation = new vscode.MarkdownString('Hochzuladene JCL');
                items.push(executeJCLJCLFILECompletion);
                const executeJCLUSERCompletion = new vscode.CompletionItem('USER');
                executeJCLUSERCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                executeJCLUSERCompletion.documentation = new vscode.MarkdownString('Userkennung des Host');
                items.push(executeJCLUSERCompletion);
                const executeJCLPWCompletion = new vscode.CompletionItem('PW');
                executeJCLPWCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLPWCompletion.insertText = new vscode.SnippetString("PW = \"${1}\"");
                executeJCLPWCompletion.documentation = new vscode.MarkdownString('Zugeh\u00F6riges Passwort des Hostusers');
                items.push(executeJCLPWCompletion);
                const executeJCLHOSTCompletion = new vscode.CompletionItem('HOST');
                executeJCLHOSTCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLHOSTCompletion.insertText = new vscode.SnippetString("HOST = \"${1}\"");
                executeJCLHOSTCompletion.documentation = new vscode.MarkdownString('Host, an den die Datei gesendet werden soll');
                items.push(executeJCLHOSTCompletion);
                const executeJCLRETURNCODECompletion = new vscode.CompletionItem('RETURNCODE');
                executeJCLRETURNCODECompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLRETURNCODECompletion.insertText = new vscode.SnippetString("RETURNCODE = \"${1}\"");
                executeJCLRETURNCODECompletion.documentation = new vscode.MarkdownString('Returncode des Jobs, der erwartet wird');
                items.push(executeJCLRETURNCODECompletion);
                const executeJCLWAIT_TIMECompletion = new vscode.CompletionItem('WAIT_TIME');
                executeJCLWAIT_TIMECompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLWAIT_TIMECompletion.insertText = new vscode.SnippetString("WAIT_TIME = \"${1}\"");
                executeJCLWAIT_TIMECompletion.documentation = new vscode.MarkdownString('Zu wartende Zeit, bis der Job ausgef\u00FChrt wurde');
                items.push(executeJCLWAIT_TIMECompletion);
                const executeJCLCANCEL_ON_TIMEOUTCompletion = new vscode.CompletionItem('CANCEL_ON_TIMEOUT');
                executeJCLCANCEL_ON_TIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLCANCEL_ON_TIMEOUTCompletion.insertText = new vscode.SnippetString("CANCEL_ON_TIMEOUT = \"${1}\"");
                executeJCLCANCEL_ON_TIMEOUTCompletion.documentation = new vscode.MarkdownString('Angabe, ob bei Timeout auch der Job auf dem Host beendet werden soll');
                items.push(executeJCLCANCEL_ON_TIMEOUTCompletion);
                const executeJCLDOWNLOAD_SYSOUTCompletion = new vscode.CompletionItem('DOWNLOAD_SYSOUT');
                executeJCLDOWNLOAD_SYSOUTCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLDOWNLOAD_SYSOUTCompletion.insertText = new vscode.SnippetString("DOWNLOAD_SYSOUT = \"${1}\"");
                executeJCLDOWNLOAD_SYSOUTCompletion.documentation = new vscode.MarkdownString('Name der Sysout-File, die beim erfolgreichen Durchlauf der Sysout runtergeladen werden soll. Wenn leer gelassen wird, dann geschieht nichts.');
                items.push(executeJCLDOWNLOAD_SYSOUTCompletion);
                const executeJCLIS_FILE_SERVERPATHCompletion = new vscode.CompletionItem('IS_FILE_SERVERPATH');
                executeJCLIS_FILE_SERVERPATHCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLIS_FILE_SERVERPATHCompletion.insertText = new vscode.SnippetString("IS_FILE_SERVERPATH = \"${1}\"");
                executeJCLIS_FILE_SERVERPATHCompletion.documentation = new vscode.MarkdownString('Angabe, ob die File Angabe auf einen Server zeigt statt eine jcl Datei zu enthalten. False per Default.');
                items.push(executeJCLIS_FILE_SERVERPATHCompletion);
                const executeJCLTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                executeJCLTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                executeJCLTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann ein neuer Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(executeJCLTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*executeJCLConnected\s*\(.*/.test(linePrefix)) {
                const executeJCLConnectedJCLFILECompletion = new vscode.CompletionItem('JCLFILE');
                executeJCLConnectedJCLFILECompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedJCLFILECompletion.insertText = new vscode.SnippetString("JCLFILE = \"${1}\"");
                executeJCLConnectedJCLFILECompletion.documentation = new vscode.MarkdownString('Hochzuladene JCL');
                items.push(executeJCLConnectedJCLFILECompletion);
                const executeJCLConnectedUSERCompletion = new vscode.CompletionItem('USER');
                executeJCLConnectedUSERCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                executeJCLConnectedUSERCompletion.documentation = new vscode.MarkdownString('Userkennung des Host');
                items.push(executeJCLConnectedUSERCompletion);
                const executeJCLConnectedCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                executeJCLConnectedCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                executeJCLConnectedCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Verbindungsname');
                items.push(executeJCLConnectedCONNECTION_NAMECompletion);
                const executeJCLConnectedHOSTCompletion = new vscode.CompletionItem('HOST');
                executeJCLConnectedHOSTCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedHOSTCompletion.insertText = new vscode.SnippetString("HOST = \"${1}\"");
                executeJCLConnectedHOSTCompletion.documentation = new vscode.MarkdownString('Host, an den die Datei gesendet werden soll');
                items.push(executeJCLConnectedHOSTCompletion);
                const executeJCLConnectedRETURNCODECompletion = new vscode.CompletionItem('RETURNCODE');
                executeJCLConnectedRETURNCODECompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedRETURNCODECompletion.insertText = new vscode.SnippetString("RETURNCODE = \"${1}\"");
                executeJCLConnectedRETURNCODECompletion.documentation = new vscode.MarkdownString('Returncode des Jobs, der erwartet wird');
                items.push(executeJCLConnectedRETURNCODECompletion);
                const executeJCLConnectedWAIT_TIMECompletion = new vscode.CompletionItem('WAIT_TIME');
                executeJCLConnectedWAIT_TIMECompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedWAIT_TIMECompletion.insertText = new vscode.SnippetString("WAIT_TIME = \"${1}\"");
                executeJCLConnectedWAIT_TIMECompletion.documentation = new vscode.MarkdownString('Zu wartende Zeit, bis der Job ausgef\u00FChrt wurde');
                items.push(executeJCLConnectedWAIT_TIMECompletion);
                const executeJCLConnectedCANCEL_ON_TIMEOUTCompletion = new vscode.CompletionItem('CANCEL_ON_TIMEOUT');
                executeJCLConnectedCANCEL_ON_TIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedCANCEL_ON_TIMEOUTCompletion.insertText = new vscode.SnippetString("CANCEL_ON_TIMEOUT = \"${1}\"");
                executeJCLConnectedCANCEL_ON_TIMEOUTCompletion.documentation = new vscode.MarkdownString('Angabe, ob bei Timeout auch der Job auf dem Host beendet werden soll');
                items.push(executeJCLConnectedCANCEL_ON_TIMEOUTCompletion);
                const executeJCLConnectedDOWNLOAD_SYSOUTCompletion = new vscode.CompletionItem('DOWNLOAD_SYSOUT');
                executeJCLConnectedDOWNLOAD_SYSOUTCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedDOWNLOAD_SYSOUTCompletion.insertText = new vscode.SnippetString("DOWNLOAD_SYSOUT = \"${1}\"");
                executeJCLConnectedDOWNLOAD_SYSOUTCompletion.documentation = new vscode.MarkdownString('Name der Sysout-File, die beim erfolgreichen Durchlauf der Sysout runtergeladen werden soll. Wenn leer gelassen wird, dann geschieht nichts.');
                items.push(executeJCLConnectedDOWNLOAD_SYSOUTCompletion);
                const executeJCLConnectedIS_FILE_SERVERPATHCompletion = new vscode.CompletionItem('IS_FILE_SERVERPATH');
                executeJCLConnectedIS_FILE_SERVERPATHCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedIS_FILE_SERVERPATHCompletion.insertText = new vscode.SnippetString("IS_FILE_SERVERPATH = \"${1}\"");
                executeJCLConnectedIS_FILE_SERVERPATHCompletion.documentation = new vscode.MarkdownString('Angabe, ob die File Angabe auf einen Server zeigt statt eine jcl Datei zu enthalten. False per Default.');
                items.push(executeJCLConnectedIS_FILE_SERVERPATHCompletion);
                const executeJCLConnectedTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                executeJCLConnectedTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                executeJCLConnectedTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                executeJCLConnectedTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann ein neuer Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(executeJCLConnectedTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*executeJava\s*\(.*/.test(linePrefix)) {
                const executeJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                executeJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                executeJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                executeJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(executeJavaTARGETCompletion);
                const executeJavaPARAM1Completion = new vscode.CompletionItem('PARAM1');
                executeJavaPARAM1Completion.kind = vscode.CompletionItemKind.Field;
                executeJavaPARAM1Completion.insertText = new vscode.SnippetString("PARAM1 = \"${1}\"");
                executeJavaPARAM1Completion.documentation = new vscode.MarkdownString('Erster Parameter der Methode');
                items.push(executeJavaPARAM1Completion);
                const executeJavaPARAM2Completion = new vscode.CompletionItem('PARAM2');
                executeJavaPARAM2Completion.kind = vscode.CompletionItemKind.Field;
                executeJavaPARAM2Completion.insertText = new vscode.SnippetString("PARAM2 = \"${1}\"");
                executeJavaPARAM2Completion.documentation = new vscode.MarkdownString('Zweiter Parameter der Methode');
                items.push(executeJavaPARAM2Completion);
                const executeJavaPARAM3Completion = new vscode.CompletionItem('PARAM3');
                executeJavaPARAM3Completion.kind = vscode.CompletionItemKind.Field;
                executeJavaPARAM3Completion.insertText = new vscode.SnippetString("PARAM3 = \"${1}\"");
                executeJavaPARAM3Completion.documentation = new vscode.MarkdownString('Dritter Parameter der Methode');
                items.push(executeJavaPARAM3Completion);
                const executeJavaPARAM4Completion = new vscode.CompletionItem('PARAM4');
                executeJavaPARAM4Completion.kind = vscode.CompletionItemKind.Field;
                executeJavaPARAM4Completion.insertText = new vscode.SnippetString("PARAM4 = \"${1}\"");
                executeJavaPARAM4Completion.documentation = new vscode.MarkdownString('Vierter Parameter der Methode');
                items.push(executeJavaPARAM4Completion);
                const executeJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                executeJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                executeJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                executeJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(executeJavaWAIT_MILLISCompletion);
                const executeJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                executeJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                executeJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                executeJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(executeJavaBY_NAMECompletion);
                const executeJavaMETHODCompletion = new vscode.CompletionItem('METHOD');
                executeJavaMETHODCompletion.kind = vscode.CompletionItemKind.Field;
                executeJavaMETHODCompletion.insertText = new vscode.SnippetString("METHOD = \"${1}\"");
                executeJavaMETHODCompletion.documentation = new vscode.MarkdownString('Auszuf\u00FChrende Methode der Komponente');
                items.push(executeJavaMETHODCompletion);
                const executeJavaTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                executeJavaTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                executeJavaTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                executeJavaTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Optionaler Key im Storage um den R\u00FCckgabewert zu speichern');
                items.push(executeJavaTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*executeSQL\s*\(.*/.test(linePrefix)) {
                const executeSQLJDBC_URLCompletion = new vscode.CompletionItem('JDBC_URL');
                executeSQLJDBC_URLCompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLJDBC_URLCompletion.insertText = new vscode.SnippetString("JDBC_URL = \"${1}\"");
                executeSQLJDBC_URLCompletion.documentation = new vscode.MarkdownString('JDBC-URL zur Verbindung mit der Datenbank. Z. B. jdbc:mysql:\/\/localhost\/Test.');
                items.push(executeSQLJDBC_URLCompletion);
                const executeSQLDB_USERNAMECompletion = new vscode.CompletionItem('DB_USERNAME');
                executeSQLDB_USERNAMECompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLDB_USERNAMECompletion.insertText = new vscode.SnippetString("DB_USERNAME = \"${1}\"");
                executeSQLDB_USERNAMECompletion.documentation = new vscode.MarkdownString('Name des DB-Users');
                items.push(executeSQLDB_USERNAMECompletion);
                const executeSQLDB_PASSWORDCompletion = new vscode.CompletionItem('DB_PASSWORD');
                executeSQLDB_PASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLDB_PASSWORDCompletion.insertText = new vscode.SnippetString("DB_PASSWORD = \"${1}\"");
                executeSQLDB_PASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort des DB-Users');
                items.push(executeSQLDB_PASSWORDCompletion);
                const executeSQLSQL_STATEMENT_OR_FILECompletion = new vscode.CompletionItem('SQL_STATEMENT_OR_FILE');
                executeSQLSQL_STATEMENT_OR_FILECompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLSQL_STATEMENT_OR_FILECompletion.insertText = new vscode.SnippetString("SQL_STATEMENT_OR_FILE = \"${1}\"");
                executeSQLSQL_STATEMENT_OR_FILECompletion.documentation = new vscode.MarkdownString('2 M\u00F6glichkeiten:           1) Absoluter, vollst\u00E4ndig qualifizierter Dateiname (sollte als Separator immer \'\/\' verwenden) einer Datei, die ein oder mehrere auszuf\u00FChrende SQL-Statements enth\u00E4lt (Dateiendung muss .sql sein). Beispiel: C:\/sql\/commands.sql        2) Ein oder mehrere SQL-Statements. Mehrere SQL-statements sind durch \';\' zu trennen (wird nur eins vorgegeben, ist dies optional).');
                items.push(executeSQLSQL_STATEMENT_OR_FILECompletion);
                const executeSQLSQL_JSON_PARAMETERSCompletion = new vscode.CompletionItem('SQL_JSON_PARAMETERS');
                executeSQLSQL_JSON_PARAMETERSCompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLSQL_JSON_PARAMETERSCompletion.insertText = new vscode.SnippetString("SQL_JSON_PARAMETERS = \"${1}\"");
                executeSQLSQL_JSON_PARAMETERSCompletion.documentation = new vscode.MarkdownString('Named Parameters in JSON-format zur Verwendung bei parametrisierten Statements, z. B. {\'name\':\'Peter\',\'age\':30}\'');
                items.push(executeSQLSQL_JSON_PARAMETERSCompletion);
                const executeSQLSQL_EXPECTED_RESULTCompletion = new vscode.CompletionItem('SQL_EXPECTED_RESULT');
                executeSQLSQL_EXPECTED_RESULTCompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLSQL_EXPECTED_RESULTCompletion.insertText = new vscode.SnippetString("SQL_EXPECTED_RESULT = \"${1}\"");
                executeSQLSQL_EXPECTED_RESULTCompletion.documentation = new vscode.MarkdownString('String im JSON-Format, der mit dem Ergebnis der SQL statements verglichen wird.');
                items.push(executeSQLSQL_EXPECTED_RESULTCompletion);
                const executeSQLFAIL_ON_ERRORCompletion = new vscode.CompletionItem('FAIL_ON_ERROR');
                executeSQLFAIL_ON_ERRORCompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLFAIL_ON_ERRORCompletion.insertText = new vscode.SnippetString("FAIL_ON_ERROR = \"${1}\"");
                executeSQLFAIL_ON_ERRORCompletion.documentation = new vscode.MarkdownString('Falls gesetzt (beliebiger Wert), resultiert ein Fehler bei der Ausf\u00FChrung eines SQL Statements in einem gescheiterten Testschritt.');
                items.push(executeSQLFAIL_ON_ERRORCompletion);
                const executeSQLJDBC_DRIVERCompletion = new vscode.CompletionItem('JDBC_DRIVER');
                executeSQLJDBC_DRIVERCompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLJDBC_DRIVERCompletion.insertText = new vscode.SnippetString("JDBC_DRIVER = \"${1}\"");
                executeSQLJDBC_DRIVERCompletion.documentation = new vscode.MarkdownString('Sollte mit angegeben werden. Falls angegeben, wird der gegebene JDBC driver (z. B. com.mysql.jdbc.Driver) geladen. Sonst wird der Autoload-Mechanismus von JDBC 4.0 genutzt.');
                items.push(executeSQLJDBC_DRIVERCompletion);
                const executeSQLTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                executeSQLTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                executeSQLTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Falls angegeben, wird das Resultat in der durch diesen Schl\u00FCssel identifizierten Laufzeitvariable gespeichert (durch Hinzuf\u00FCgen oder Ersetzen). Das Resultat wird dabei im Format eines JSON-Array gespeichert, wobei jede zur\u00FCckgegebene Zeile einem Eintrag des JSON-Arrays entspricht. F\u00FCr den Sonderfall, das nur ein einzelner Wert aus einer einzelnen Zeile abgefragt wird, kann es notwendig sein, diesen vor der weiteren Verwendung zu parsen (z.B. wird anstelle des gesamten Ergebnisses [{\'ID\':123}] nur der Wert 123 ben\u00F6tigt. Dazu ist das Kommando changeStorageValue mit der Option extractSingleSqlResultFromJson zu verwenden.');
                items.push(executeSQLTARGET_STORAGE_KEYCompletion);
                const executeSQLENCODINGCompletion = new vscode.CompletionItem('ENCODING');
                executeSQLENCODINGCompletion.kind = vscode.CompletionItemKind.Field;
                executeSQLENCODINGCompletion.insertText = new vscode.SnippetString("ENCODING = \"${1}\"");
                executeSQLENCODINGCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(executeSQLENCODINGCompletion);
            }
            if (/.*\s*executeSql\s*\(.*/.test(linePrefix)) {
                const executeSqlCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                executeSqlCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                executeSqlCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                executeSqlCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der bereits bestehenden Datenbankverbindung');
                items.push(executeSqlCONNECTION_NAMECompletion);
                const executeSqlSQL_STATEMENT_OR_FILECompletion = new vscode.CompletionItem('SQL_STATEMENT_OR_FILE');
                executeSqlSQL_STATEMENT_OR_FILECompletion.kind = vscode.CompletionItemKind.Field;
                executeSqlSQL_STATEMENT_OR_FILECompletion.insertText = new vscode.SnippetString("SQL_STATEMENT_OR_FILE = \"${1}\"");
                executeSqlSQL_STATEMENT_OR_FILECompletion.documentation = new vscode.MarkdownString('1) Absoluter, vollst\u00E4ndig qualifizierter Dateiname (sollte als Separator immer \'\/\' verwenden) einer Datei, die ein oder mehrere auszuf\u00FChrende SQL-Statements enth\u00E4lt (Dateiendung muss .sql sein). Beispiel: C:\/sql\/commands.sql        2) Ein oder mehrere SQL-Statements. Mehrere SQL-statements sind durch \';\' zu trennen (wird nur eins vorgegeben, ist dies optional).');
                items.push(executeSqlSQL_STATEMENT_OR_FILECompletion);
                const executeSqlEXECUTE_ENTIRE_FILE_AT_ONCECompletion = new vscode.CompletionItem('EXECUTE_ENTIRE_FILE_AT_ONCE');
                executeSqlEXECUTE_ENTIRE_FILE_AT_ONCECompletion.kind = vscode.CompletionItemKind.Field;
                executeSqlEXECUTE_ENTIRE_FILE_AT_ONCECompletion.insertText = new vscode.SnippetString("EXECUTE_ENTIRE_FILE_AT_ONCE = \"${1}\"");
                executeSqlEXECUTE_ENTIRE_FILE_AT_ONCECompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(executeSqlEXECUTE_ENTIRE_FILE_AT_ONCECompletion);
                const executeSqlENCODINGCompletion = new vscode.CompletionItem('ENCODING');
                executeSqlENCODINGCompletion.kind = vscode.CompletionItemKind.Field;
                executeSqlENCODINGCompletion.insertText = new vscode.SnippetString("ENCODING = \"${1}\"");
                executeSqlENCODINGCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(executeSqlENCODINGCompletion);
            }
            if (/.*\s*executeWindowsCommand\s*\(.*/.test(linePrefix)) {
                const executeWindowsCommandCOMMANDCompletion = new vscode.CompletionItem('COMMAND');
                executeWindowsCommandCOMMANDCompletion.kind = vscode.CompletionItemKind.Field;
                executeWindowsCommandCOMMANDCompletion.insertText = new vscode.SnippetString("COMMAND = \"${1}\"");
                executeWindowsCommandCOMMANDCompletion.documentation = new vscode.MarkdownString('Auszuf\u00FChrendes Kommandos');
                items.push(executeWindowsCommandCOMMANDCompletion);
            }
            if (/.*\s*expectAttributeMobile\s*\(.*/.test(linePrefix)) {
                const expectAttributeMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                expectAttributeMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                expectAttributeMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                expectAttributeMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(expectAttributeMobileBY_CRITERIACompletion);
                const expectAttributeMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                expectAttributeMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                expectAttributeMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                expectAttributeMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(expectAttributeMobileEXPRESSION_TEXTCompletion);
                const expectAttributeMobileEXPECTED_VALUECompletion = new vscode.CompletionItem('EXPECTED_VALUE');
                expectAttributeMobileEXPECTED_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                expectAttributeMobileEXPECTED_VALUECompletion.insertText = new vscode.SnippetString("EXPECTED_VALUE = \"${1}\"");
                expectAttributeMobileEXPECTED_VALUECompletion.documentation = new vscode.MarkdownString('Der Parameter gibt den Soll-Wert des Attributs an.');
                items.push(expectAttributeMobileEXPECTED_VALUECompletion);
                const expectAttributeMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                expectAttributeMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                expectAttributeMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                expectAttributeMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange vor der Attributspr\u00FCfung gewartet werden soll bis das Kommando durchgef\u00FChrt wird. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(expectAttributeMobileWAIT_SECONDSCompletion);
                const expectAttributeMobileATTRIBUTE_NAMECompletion = new vscode.CompletionItem('ATTRIBUTE_NAME');
                expectAttributeMobileATTRIBUTE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                expectAttributeMobileATTRIBUTE_NAMECompletion.insertText = new vscode.SnippetString("ATTRIBUTE_NAME = \"${1}\"");
                expectAttributeMobileATTRIBUTE_NAMECompletion.documentation = new vscode.MarkdownString('Name des Attributs, das \u00FCberpr\u00FCft werden soll.');
                items.push(expectAttributeMobileATTRIBUTE_NAMECompletion);
            }
            if (/.*\s*expectDisplayedMobile\s*\(.*/.test(linePrefix)) {
                const expectDisplayedMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                expectDisplayedMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                expectDisplayedMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                expectDisplayedMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(expectDisplayedMobileBY_CRITERIACompletion);
                const expectDisplayedMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                expectDisplayedMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                expectDisplayedMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                expectDisplayedMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(expectDisplayedMobileEXPRESSION_TEXTCompletion);
                const expectDisplayedMobileEXPECTED_VALUECompletion = new vscode.CompletionItem('EXPECTED_VALUE');
                expectDisplayedMobileEXPECTED_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                expectDisplayedMobileEXPECTED_VALUECompletion.insertText = new vscode.SnippetString("EXPECTED_VALUE = \"${1}\"");
                expectDisplayedMobileEXPECTED_VALUECompletion.documentation = new vscode.MarkdownString('Der Parameter gibt den Soll-Wert des Attributs an. M\u00F6gich sind: \'True\', oder \'False\'.');
                items.push(expectDisplayedMobileEXPECTED_VALUECompletion);
                const expectDisplayedMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                expectDisplayedMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                expectDisplayedMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                expectDisplayedMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange vor der Attributspr\u00FCfung gewartet werden soll bis das Kommando durchgef\u00FChrt wird. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(expectDisplayedMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*expectEnabledMobile\s*\(.*/.test(linePrefix)) {
                const expectEnabledMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                expectEnabledMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                expectEnabledMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                expectEnabledMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(expectEnabledMobileBY_CRITERIACompletion);
                const expectEnabledMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                expectEnabledMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                expectEnabledMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                expectEnabledMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(expectEnabledMobileEXPRESSION_TEXTCompletion);
                const expectEnabledMobileEXPECTED_VALUECompletion = new vscode.CompletionItem('EXPECTED_VALUE');
                expectEnabledMobileEXPECTED_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                expectEnabledMobileEXPECTED_VALUECompletion.insertText = new vscode.SnippetString("EXPECTED_VALUE = \"${1}\"");
                expectEnabledMobileEXPECTED_VALUECompletion.documentation = new vscode.MarkdownString('Der Parameter gibt den Soll-Wert des Attributs an. M\u00F6glich sind: \'True\', oder \'False\'.');
                items.push(expectEnabledMobileEXPECTED_VALUECompletion);
                const expectEnabledMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                expectEnabledMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                expectEnabledMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                expectEnabledMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange vor der Sperrungsspr\u00FCfung gewartet werden soll bis das Kommando durchgef\u00FChrt wird. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(expectEnabledMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*expectNotSelectedMobile\s*\(.*/.test(linePrefix)) {
                const expectNotSelectedMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                expectNotSelectedMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                expectNotSelectedMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                expectNotSelectedMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(expectNotSelectedMobileBY_CRITERIACompletion);
                const expectNotSelectedMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                expectNotSelectedMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                expectNotSelectedMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                expectNotSelectedMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(expectNotSelectedMobileEXPRESSION_TEXTCompletion);
                const expectNotSelectedMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                expectNotSelectedMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                expectNotSelectedMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                expectNotSelectedMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange vor der Attributspr\u00FCfung gewartet werden soll bis das Kommando durchgef\u00FChrt wird. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(expectNotSelectedMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*expectPresentMobile\s*\(.*/.test(linePrefix)) {
                const expectPresentMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                expectPresentMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                expectPresentMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                expectPresentMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(expectPresentMobileBY_CRITERIACompletion);
                const expectPresentMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                expectPresentMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                expectPresentMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                expectPresentMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(expectPresentMobileEXPRESSION_TEXTCompletion);
                const expectPresentMobileEXPECTED_VALUECompletion = new vscode.CompletionItem('EXPECTED_VALUE');
                expectPresentMobileEXPECTED_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                expectPresentMobileEXPECTED_VALUECompletion.insertText = new vscode.SnippetString("EXPECTED_VALUE = \"${1}\"");
                expectPresentMobileEXPECTED_VALUECompletion.documentation = new vscode.MarkdownString('Der Parameter gibt den Soll-Wert des Attributs an. M\u00F6gich sind: \'True\', oder \'False\'.');
                items.push(expectPresentMobileEXPECTED_VALUECompletion);
                const expectPresentMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                expectPresentMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                expectPresentMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                expectPresentMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange vor der Attributspr\u00FCfung gewartet werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(expectPresentMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*expectSelectedMobile\s*\(.*/.test(linePrefix)) {
                const expectSelectedMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                expectSelectedMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                expectSelectedMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                expectSelectedMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(expectSelectedMobileBY_CRITERIACompletion);
                const expectSelectedMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                expectSelectedMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                expectSelectedMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                expectSelectedMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(expectSelectedMobileEXPRESSION_TEXTCompletion);
                const expectSelectedMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                expectSelectedMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                expectSelectedMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                expectSelectedMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange vor der Attributspr\u00FCfung gewartet werden soll bis das Kommando durchgef\u00FChrt wird. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(expectSelectedMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*expectTextMobile\s*\(.*/.test(linePrefix)) {
                const expectTextMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                expectTextMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                expectTextMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                expectTextMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(expectTextMobileBY_CRITERIACompletion);
                const expectTextMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                expectTextMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                expectTextMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                expectTextMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(expectTextMobileEXPRESSION_TEXTCompletion);
                const expectTextMobileEXPECTED_VALUECompletion = new vscode.CompletionItem('EXPECTED_VALUE');
                expectTextMobileEXPECTED_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                expectTextMobileEXPECTED_VALUECompletion.insertText = new vscode.SnippetString("EXPECTED_VALUE = \"${1}\"");
                expectTextMobileEXPECTED_VALUECompletion.documentation = new vscode.MarkdownString('Der Parameter gibt an, welcher Text erwartet wird. Wird der Text nicht in dem Element gefunden, wird eine Warnung herausgegeben.');
                items.push(expectTextMobileEXPECTED_VALUECompletion);
                const expectTextMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                expectTextMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                expectTextMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                expectTextMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange gewartet werden soll bis nach dem Text gesucht werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(expectTextMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*extractTextFromPDF\s*\(.*/.test(linePrefix)) {
                const extractTextFromPDFPDF_PATHCompletion = new vscode.CompletionItem('PDF_PATH');
                extractTextFromPDFPDF_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                extractTextFromPDFPDF_PATHCompletion.insertText = new vscode.SnippetString("PDF_PATH = \"${1}\"");
                extractTextFromPDFPDF_PATHCompletion.documentation = new vscode.MarkdownString('Pfad der zu durchsuchenden Datei');
                items.push(extractTextFromPDFPDF_PATHCompletion);
                const extractTextFromPDFPATH_IS_RELATIVECompletion = new vscode.CompletionItem('PATH_IS_RELATIVE');
                extractTextFromPDFPATH_IS_RELATIVECompletion.kind = vscode.CompletionItemKind.Field;
                extractTextFromPDFPATH_IS_RELATIVECompletion.insertText = new vscode.SnippetString("PATH_IS_RELATIVE = \"${1}\"");
                extractTextFromPDFPATH_IS_RELATIVECompletion.documentation = new vscode.MarkdownString('Wenn true, muss unter PDF_PATH nur der relative Pfad vom die Testset-XLSM beinahltenden Ordner ausgehend anagegeben werden');
                items.push(extractTextFromPDFPATH_IS_RELATIVECompletion);
                const extractTextFromPDFTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                extractTextFromPDFTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                extractTextFromPDFTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                extractTextFromPDFTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Name der Laufzeitvariablen, unter der der PDF Inhalt in der Storage-Datei abgelegt werden soll');
                items.push(extractTextFromPDFTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*fail\s*\(.*/.test(linePrefix)) {
                const failMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                failMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                failMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                failMESSAGECompletion.documentation = new vscode.MarkdownString('Nachricht, die im Bericht angezeigt werden soll.');
                items.push(failMESSAGECompletion);
            }
            if (/.*\s*fileTextDiff\s*\(.*/.test(linePrefix)) {
                const fileTextDiffFILE_ONECompletion = new vscode.CompletionItem('FILE_ONE');
                fileTextDiffFILE_ONECompletion.kind = vscode.CompletionItemKind.Field;
                fileTextDiffFILE_ONECompletion.insertText = new vscode.SnippetString("FILE_ONE = \"${1}\"");
                fileTextDiffFILE_ONECompletion.documentation = new vscode.MarkdownString('Dateiname\/pfad der ersten Datei');
                items.push(fileTextDiffFILE_ONECompletion);
                const fileTextDiffFILE_TWOCompletion = new vscode.CompletionItem('FILE_TWO');
                fileTextDiffFILE_TWOCompletion.kind = vscode.CompletionItemKind.Field;
                fileTextDiffFILE_TWOCompletion.insertText = new vscode.SnippetString("FILE_TWO = \"${1}\"");
                fileTextDiffFILE_TWOCompletion.documentation = new vscode.MarkdownString('Dateiname\/pfad der zweiten Datei');
                items.push(fileTextDiffFILE_TWOCompletion);
                const fileTextDiffFILE_ONE_PATH_IS_RELATIVECompletion = new vscode.CompletionItem('FILE_ONE_PATH_IS_RELATIVE');
                fileTextDiffFILE_ONE_PATH_IS_RELATIVECompletion.kind = vscode.CompletionItemKind.Field;
                fileTextDiffFILE_ONE_PATH_IS_RELATIVECompletion.insertText = new vscode.SnippetString("FILE_ONE_PATH_IS_RELATIVE = \"${1}\"");
                fileTextDiffFILE_ONE_PATH_IS_RELATIVECompletion.documentation = new vscode.MarkdownString('Angabe, ob der Pfad relativ ist oder nicht (true oder false)');
                items.push(fileTextDiffFILE_ONE_PATH_IS_RELATIVECompletion);
                const fileTextDiffFILE_TWO_PATH_IS_RELATIVECompletion = new vscode.CompletionItem('FILE_TWO_PATH_IS_RELATIVE');
                fileTextDiffFILE_TWO_PATH_IS_RELATIVECompletion.kind = vscode.CompletionItemKind.Field;
                fileTextDiffFILE_TWO_PATH_IS_RELATIVECompletion.insertText = new vscode.SnippetString("FILE_TWO_PATH_IS_RELATIVE = \"${1}\"");
                fileTextDiffFILE_TWO_PATH_IS_RELATIVECompletion.documentation = new vscode.MarkdownString('Angabe, ob der Pfad relativ ist oder nicht (true oder false)');
                items.push(fileTextDiffFILE_TWO_PATH_IS_RELATIVECompletion);
                const fileTextDiffSAVE_RESULT_FILE_NAMECompletion = new vscode.CompletionItem('SAVE_RESULT_FILE_NAME');
                fileTextDiffSAVE_RESULT_FILE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                fileTextDiffSAVE_RESULT_FILE_NAMECompletion.insertText = new vscode.SnippetString("SAVE_RESULT_FILE_NAME = \"${1}\"");
                fileTextDiffSAVE_RESULT_FILE_NAMECompletion.documentation = new vscode.MarkdownString('Dateiname in die das Ergebnis geschrieben wird (relativ)');
                items.push(fileTextDiffSAVE_RESULT_FILE_NAMECompletion);
                const fileTextDiffTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                fileTextDiffTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                fileTextDiffTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                fileTextDiffTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein neuer Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(fileTextDiffTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*findAndClickAndSendWin\s*\(.*/.test(linePrefix)) {
                const findAndClickAndSendWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                findAndClickAndSendWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickAndSendWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                findAndClickAndSendWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(findAndClickAndSendWinWINDOW_NAMECompletion);
                const findAndClickAndSendWinIMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('IMAGE_RELATIVE_PATH');
                findAndClickAndSendWinIMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickAndSendWinIMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_RELATIVE_PATH = \"${1}\"");
                findAndClickAndSendWinIMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(findAndClickAndSendWinIMAGE_RELATIVE_PATHCompletion);
                const findAndClickAndSendWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                findAndClickAndSendWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickAndSendWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                findAndClickAndSendWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(findAndClickAndSendWinBASEDIRCompletion);
                const findAndClickAndSendWinTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                findAndClickAndSendWinTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickAndSendWinTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                findAndClickAndSendWinTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('zu sendender (schreibender) Text');
                items.push(findAndClickAndSendWinTEXT_TO_SENDCompletion);
                const findAndClickAndSendWinMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                findAndClickAndSendWinMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickAndSendWinMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                findAndClickAndSendWinMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{links,rechts} links ist default, muss daher nicht angegeben werden.');
                items.push(findAndClickAndSendWinMOUSE_BUTTONCompletion);
                const findAndClickAndSendWinRELATIVE_XCompletion = new vscode.CompletionItem('RELATIVE_X');
                findAndClickAndSendWinRELATIVE_XCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickAndSendWinRELATIVE_XCompletion.insertText = new vscode.SnippetString("RELATIVE_X = \"${1}\"");
                findAndClickAndSendWinRELATIVE_XCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der X-Achse. Links: Negativ. Rechts: Positiv');
                items.push(findAndClickAndSendWinRELATIVE_XCompletion);
                const findAndClickAndSendWinRELATIVE_YCompletion = new vscode.CompletionItem('RELATIVE_Y');
                findAndClickAndSendWinRELATIVE_YCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickAndSendWinRELATIVE_YCompletion.insertText = new vscode.SnippetString("RELATIVE_Y = \"${1}\"");
                findAndClickAndSendWinRELATIVE_YCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der Y-Achse. Oben: Negativ. Unten: Positiv');
                items.push(findAndClickAndSendWinRELATIVE_YCompletion);
            }
            if (/.*\s*findAndClickWin\s*\(.*/.test(linePrefix)) {
                const findAndClickWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                findAndClickWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                findAndClickWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(findAndClickWinWINDOW_NAMECompletion);
                const findAndClickWinIMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('IMAGE_RELATIVE_PATH');
                findAndClickWinIMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickWinIMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_RELATIVE_PATH = \"${1}\"");
                findAndClickWinIMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(findAndClickWinIMAGE_RELATIVE_PATHCompletion);
                const findAndClickWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                findAndClickWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                findAndClickWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(findAndClickWinBASEDIRCompletion);
                const findAndClickWinMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                findAndClickWinMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickWinMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                findAndClickWinMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('{links,rechts} links ist default, muss daher nicht angegeben werden.');
                items.push(findAndClickWinMOUSE_BUTTONCompletion);
                const findAndClickWinRELATIVE_XCompletion = new vscode.CompletionItem('RELATIVE_X');
                findAndClickWinRELATIVE_XCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickWinRELATIVE_XCompletion.insertText = new vscode.SnippetString("RELATIVE_X = \"${1}\"");
                findAndClickWinRELATIVE_XCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der X-Achse. Links: Negativ. Rechts: Positiv');
                items.push(findAndClickWinRELATIVE_XCompletion);
                const findAndClickWinRELATIVE_YCompletion = new vscode.CompletionItem('RELATIVE_Y');
                findAndClickWinRELATIVE_YCompletion.kind = vscode.CompletionItemKind.Field;
                findAndClickWinRELATIVE_YCompletion.insertText = new vscode.SnippetString("RELATIVE_Y = \"${1}\"");
                findAndClickWinRELATIVE_YCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der Y-Achse. Oben: Negativ. Unten: Positiv');
                items.push(findAndClickWinRELATIVE_YCompletion);
            }
            if (/.*\s*findPictureLocation\s*\(.*/.test(linePrefix)) {
                const findPictureLocationIMAGE_PATHCompletion = new vscode.CompletionItem('IMAGE_PATH');
                findPictureLocationIMAGE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationIMAGE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_PATH = \"${1}\"");
                findPictureLocationIMAGE_PATHCompletion.documentation = new vscode.MarkdownString('Relativer Pfad zu dem Bild');
                items.push(findPictureLocationIMAGE_PATHCompletion);
                const findPictureLocationBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                findPictureLocationBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                findPictureLocationBASEDIRCompletion.documentation = new vscode.MarkdownString('Base Directory');
                items.push(findPictureLocationBASEDIRCompletion);
                const findPictureLocationNUMBER_OF_TRIESCompletion = new vscode.CompletionItem('NUMBER_OF_TRIES');
                findPictureLocationNUMBER_OF_TRIESCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationNUMBER_OF_TRIESCompletion.insertText = new vscode.SnippetString("NUMBER_OF_TRIES = \"${1}\"");
                findPictureLocationNUMBER_OF_TRIESCompletion.documentation = new vscode.MarkdownString('Anzahl der Versuche das Bild zu finden. Default 5.');
                items.push(findPictureLocationNUMBER_OF_TRIESCompletion);
                const findPictureLocationSLEEP_BETWEEN_TRIESCompletion = new vscode.CompletionItem('SLEEP_BETWEEN_TRIES');
                findPictureLocationSLEEP_BETWEEN_TRIESCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationSLEEP_BETWEEN_TRIESCompletion.insertText = new vscode.SnippetString("SLEEP_BETWEEN_TRIES = \"${1}\"");
                findPictureLocationSLEEP_BETWEEN_TRIESCompletion.documentation = new vscode.MarkdownString('Dauer in Millisekunden, wie lange zwischen jedem Versuch gewartet werden soll. Default 500ms.');
                items.push(findPictureLocationSLEEP_BETWEEN_TRIESCompletion);
                const findPictureLocationMATCHING_THRESHOLDCompletion = new vscode.CompletionItem('MATCHING_THRESHOLD');
                findPictureLocationMATCHING_THRESHOLDCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationMATCHING_THRESHOLDCompletion.insertText = new vscode.SnippetString("MATCHING_THRESHOLD = \"${1}\"");
                findPictureLocationMATCHING_THRESHOLDCompletion.documentation = new vscode.MarkdownString('Threshold f\u00FCr das Matching');
                items.push(findPictureLocationMATCHING_THRESHOLDCompletion);
                const findPictureLocationTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                findPictureLocationTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                findPictureLocationTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(findPictureLocationTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*findPictureLocationAndClick\s*\(.*/.test(linePrefix)) {
                const findPictureLocationAndClickIMAGE_PATHCompletion = new vscode.CompletionItem('IMAGE_PATH');
                findPictureLocationAndClickIMAGE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickIMAGE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_PATH = \"${1}\"");
                findPictureLocationAndClickIMAGE_PATHCompletion.documentation = new vscode.MarkdownString('Relativer Pfad zu dem Bild');
                items.push(findPictureLocationAndClickIMAGE_PATHCompletion);
                const findPictureLocationAndClickBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                findPictureLocationAndClickBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                findPictureLocationAndClickBASEDIRCompletion.documentation = new vscode.MarkdownString('Base Directory');
                items.push(findPictureLocationAndClickBASEDIRCompletion);
                const findPictureLocationAndClickBUTTONCompletion = new vscode.CompletionItem('BUTTON');
                findPictureLocationAndClickBUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickBUTTONCompletion.insertText = new vscode.SnippetString("BUTTON = \"${1}\"");
                findPictureLocationAndClickBUTTONCompletion.documentation = new vscode.MarkdownString('Links- oder Rechtsklick');
                items.push(findPictureLocationAndClickBUTTONCompletion);
                const findPictureLocationAndClickNUMBER_OF_TRIESCompletion = new vscode.CompletionItem('NUMBER_OF_TRIES');
                findPictureLocationAndClickNUMBER_OF_TRIESCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickNUMBER_OF_TRIESCompletion.insertText = new vscode.SnippetString("NUMBER_OF_TRIES = \"${1}\"");
                findPictureLocationAndClickNUMBER_OF_TRIESCompletion.documentation = new vscode.MarkdownString('Anzahl der Versuche das Bild zu finden. Default 5.');
                items.push(findPictureLocationAndClickNUMBER_OF_TRIESCompletion);
                const findPictureLocationAndClickSLEEP_BETWEEN_TRIESCompletion = new vscode.CompletionItem('SLEEP_BETWEEN_TRIES');
                findPictureLocationAndClickSLEEP_BETWEEN_TRIESCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickSLEEP_BETWEEN_TRIESCompletion.insertText = new vscode.SnippetString("SLEEP_BETWEEN_TRIES = \"${1}\"");
                findPictureLocationAndClickSLEEP_BETWEEN_TRIESCompletion.documentation = new vscode.MarkdownString('Dauer in Millisekunden, wie lange zwischen jedem Versuch gewartet werden soll. Default 500ms.');
                items.push(findPictureLocationAndClickSLEEP_BETWEEN_TRIESCompletion);
                const findPictureLocationAndClickMATCHING_THRESHOLDCompletion = new vscode.CompletionItem('MATCHING_THRESHOLD');
                findPictureLocationAndClickMATCHING_THRESHOLDCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickMATCHING_THRESHOLDCompletion.insertText = new vscode.SnippetString("MATCHING_THRESHOLD = \"${1}\"");
                findPictureLocationAndClickMATCHING_THRESHOLDCompletion.documentation = new vscode.MarkdownString('Threshold f\u00FCr das Matching');
                items.push(findPictureLocationAndClickMATCHING_THRESHOLDCompletion);
                const findPictureLocationAndClickTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                findPictureLocationAndClickTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                findPictureLocationAndClickTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(findPictureLocationAndClickTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*findPictureLocationAndClickAndSend\s*\(.*/.test(linePrefix)) {
                const findPictureLocationAndClickAndSendIMAGE_PATHCompletion = new vscode.CompletionItem('IMAGE_PATH');
                findPictureLocationAndClickAndSendIMAGE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendIMAGE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_PATH = \"${1}\"");
                findPictureLocationAndClickAndSendIMAGE_PATHCompletion.documentation = new vscode.MarkdownString('Relativer Pfad zu dem Bild');
                items.push(findPictureLocationAndClickAndSendIMAGE_PATHCompletion);
                const findPictureLocationAndClickAndSendBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                findPictureLocationAndClickAndSendBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                findPictureLocationAndClickAndSendBASEDIRCompletion.documentation = new vscode.MarkdownString('Base Directory');
                items.push(findPictureLocationAndClickAndSendBASEDIRCompletion);
                const findPictureLocationAndClickAndSendBUTTONCompletion = new vscode.CompletionItem('BUTTON');
                findPictureLocationAndClickAndSendBUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendBUTTONCompletion.insertText = new vscode.SnippetString("BUTTON = \"${1}\"");
                findPictureLocationAndClickAndSendBUTTONCompletion.documentation = new vscode.MarkdownString('Links- oder Rechtsklick');
                items.push(findPictureLocationAndClickAndSendBUTTONCompletion);
                const findPictureLocationAndClickAndSendTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                findPictureLocationAndClickAndSendTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                findPictureLocationAndClickAndSendTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Der Text der gesendet werden soll');
                items.push(findPictureLocationAndClickAndSendTEXT_TO_SENDCompletion);
                const findPictureLocationAndClickAndSendNUMBER_OF_TRIESCompletion = new vscode.CompletionItem('NUMBER_OF_TRIES');
                findPictureLocationAndClickAndSendNUMBER_OF_TRIESCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendNUMBER_OF_TRIESCompletion.insertText = new vscode.SnippetString("NUMBER_OF_TRIES = \"${1}\"");
                findPictureLocationAndClickAndSendNUMBER_OF_TRIESCompletion.documentation = new vscode.MarkdownString('Anzahl der Versuche das Bild zu finden. Default 5.');
                items.push(findPictureLocationAndClickAndSendNUMBER_OF_TRIESCompletion);
                const findPictureLocationAndClickAndSendSLEEP_BETWEEN_TRIESCompletion = new vscode.CompletionItem('SLEEP_BETWEEN_TRIES');
                findPictureLocationAndClickAndSendSLEEP_BETWEEN_TRIESCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendSLEEP_BETWEEN_TRIESCompletion.insertText = new vscode.SnippetString("SLEEP_BETWEEN_TRIES = \"${1}\"");
                findPictureLocationAndClickAndSendSLEEP_BETWEEN_TRIESCompletion.documentation = new vscode.MarkdownString('Dauer in Millisekunden, wie lange zwischen jedem Versuch gewartet werden soll. Default 500ms.');
                items.push(findPictureLocationAndClickAndSendSLEEP_BETWEEN_TRIESCompletion);
                const findPictureLocationAndClickAndSendMATCHING_THRESHOLDCompletion = new vscode.CompletionItem('MATCHING_THRESHOLD');
                findPictureLocationAndClickAndSendMATCHING_THRESHOLDCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendMATCHING_THRESHOLDCompletion.insertText = new vscode.SnippetString("MATCHING_THRESHOLD = \"${1}\"");
                findPictureLocationAndClickAndSendMATCHING_THRESHOLDCompletion.documentation = new vscode.MarkdownString('Threshold f\u00FCr das Matching');
                items.push(findPictureLocationAndClickAndSendMATCHING_THRESHOLDCompletion);
                const findPictureLocationAndClickAndSendDELAYCompletion = new vscode.CompletionItem('DELAY');
                findPictureLocationAndClickAndSendDELAYCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendDELAYCompletion.insertText = new vscode.SnippetString("DELAY = \"${1}\"");
                findPictureLocationAndClickAndSendDELAYCompletion.documentation = new vscode.MarkdownString('Dauer in Millisekunden, wie lange zwischen dem Klicken und Senden gewartet werden soll. Default 1000ms');
                items.push(findPictureLocationAndClickAndSendDELAYCompletion);
                const findPictureLocationAndClickAndSendTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                findPictureLocationAndClickAndSendTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                findPictureLocationAndClickAndSendTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                findPictureLocationAndClickAndSendTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(findPictureLocationAndClickAndSendTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*findTextInPicture\s*\(.*/.test(linePrefix)) {
                const findTextInPictureFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                findTextInPictureFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                findTextInPictureFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                findTextInPictureFILENAMECompletion.documentation = new vscode.MarkdownString('Name der Bilddatei, die untersucht werden soll. Wenn keine Bilddatei angegeben wird, wird der Zwischenspeicher nach Bilddaten durchsucht. Ist auch hier kein Bild vorhanden, wird ein Screenshot erstellt.');
                items.push(findTextInPictureFILENAMECompletion);
                const findTextInPictureBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                findTextInPictureBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                findTextInPictureBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                findTextInPictureBASEDIRCompletion.documentation = new vscode.MarkdownString('Gibt das Basisverzeichnis an.');
                items.push(findTextInPictureBASEDIRCompletion);
                const findTextInPictureTEXT_TO_FINDCompletion = new vscode.CompletionItem('TEXT_TO_FIND');
                findTextInPictureTEXT_TO_FINDCompletion.kind = vscode.CompletionItemKind.Field;
                findTextInPictureTEXT_TO_FINDCompletion.insertText = new vscode.SnippetString("TEXT_TO_FIND = \"${1}\"");
                findTextInPictureTEXT_TO_FINDCompletion.documentation = new vscode.MarkdownString('Text der gesucht werden soll');
                items.push(findTextInPictureTEXT_TO_FINDCompletion);
                const findTextInPictureX1Completion = new vscode.CompletionItem('X1');
                findTextInPictureX1Completion.kind = vscode.CompletionItemKind.Field;
                findTextInPictureX1Completion.insertText = new vscode.SnippetString("X1 = \"${1}\"");
                findTextInPictureX1Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: X-Koordinate der linken oberen Ecke.');
                items.push(findTextInPictureX1Completion);
                const findTextInPictureY1Completion = new vscode.CompletionItem('Y1');
                findTextInPictureY1Completion.kind = vscode.CompletionItemKind.Field;
                findTextInPictureY1Completion.insertText = new vscode.SnippetString("Y1 = \"${1}\"");
                findTextInPictureY1Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: Y-Koordinate der linken oberen Ecke.');
                items.push(findTextInPictureY1Completion);
                const findTextInPictureX2Completion = new vscode.CompletionItem('X2');
                findTextInPictureX2Completion.kind = vscode.CompletionItemKind.Field;
                findTextInPictureX2Completion.insertText = new vscode.SnippetString("X2 = \"${1}\"");
                findTextInPictureX2Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: X-Koordinate der rechten unteren Ecke.');
                items.push(findTextInPictureX2Completion);
                const findTextInPictureY2Completion = new vscode.CompletionItem('Y2');
                findTextInPictureY2Completion.kind = vscode.CompletionItemKind.Field;
                findTextInPictureY2Completion.insertText = new vscode.SnippetString("Y2 = \"${1}\"");
                findTextInPictureY2Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: Y-Koordinate der rechten unteren Ecke.');
                items.push(findTextInPictureY2Completion);
                const findTextInPictureOCR_IMPLEMENTATIONCompletion = new vscode.CompletionItem('OCR_IMPLEMENTATION');
                findTextInPictureOCR_IMPLEMENTATIONCompletion.kind = vscode.CompletionItemKind.Field;
                findTextInPictureOCR_IMPLEMENTATIONCompletion.insertText = new vscode.SnippetString("OCR_IMPLEMENTATION = \"${1}\"");
                findTextInPictureOCR_IMPLEMENTATIONCompletion.documentation = new vscode.MarkdownString('Wahl der verwendeten OCR Implementierung. GCP oder TESSERACT.');
                items.push(findTextInPictureOCR_IMPLEMENTATIONCompletion);
            }
            if (/.*\s*for\s*\(.*/.test(linePrefix)) {
                const forDATA_FILE_PATHCompletion = new vscode.CompletionItem('DATA_FILE_PATH');
                forDATA_FILE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                forDATA_FILE_PATHCompletion.insertText = new vscode.SnippetString("DATA_FILE_PATH = \"${1}\"");
                forDATA_FILE_PATHCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forDATA_FILE_PATHCompletion);
                const forCONTINUE_ON_WARNINGCompletion = new vscode.CompletionItem('CONTINUE_ON_WARNING');
                forCONTINUE_ON_WARNINGCompletion.kind = vscode.CompletionItemKind.Field;
                forCONTINUE_ON_WARNINGCompletion.insertText = new vscode.SnippetString("CONTINUE_ON_WARNING = \"${1}\"");
                forCONTINUE_ON_WARNINGCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forCONTINUE_ON_WARNINGCompletion);
                const forCONTINUE_ON_ERRORCompletion = new vscode.CompletionItem('CONTINUE_ON_ERROR');
                forCONTINUE_ON_ERRORCompletion.kind = vscode.CompletionItemKind.Field;
                forCONTINUE_ON_ERRORCompletion.insertText = new vscode.SnippetString("CONTINUE_ON_ERROR = \"${1}\"");
                forCONTINUE_ON_ERRORCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forCONTINUE_ON_ERRORCompletion);
                const forBACKUP_ERROR_NAMECompletion = new vscode.CompletionItem('BACKUP_ERROR_NAME');
                forBACKUP_ERROR_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                forBACKUP_ERROR_NAMECompletion.insertText = new vscode.SnippetString("BACKUP_ERROR_NAME = \"${1}\"");
                forBACKUP_ERROR_NAMECompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forBACKUP_ERROR_NAMECompletion);
                const forCONTINUE_UNTIL_SUCCESSCompletion = new vscode.CompletionItem('CONTINUE_UNTIL_SUCCESS');
                forCONTINUE_UNTIL_SUCCESSCompletion.kind = vscode.CompletionItemKind.Field;
                forCONTINUE_UNTIL_SUCCESSCompletion.insertText = new vscode.SnippetString("CONTINUE_UNTIL_SUCCESS = \"${1}\"");
                forCONTINUE_UNTIL_SUCCESSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forCONTINUE_UNTIL_SUCCESSCompletion);
                const forSEPARATORCompletion = new vscode.CompletionItem('SEPARATOR');
                forSEPARATORCompletion.kind = vscode.CompletionItemKind.Field;
                forSEPARATORCompletion.insertText = new vscode.SnippetString("SEPARATOR = \"${1}\"");
                forSEPARATORCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forSEPARATORCompletion);
                const forQUOTE_CHARACTERCompletion = new vscode.CompletionItem('QUOTE_CHARACTER');
                forQUOTE_CHARACTERCompletion.kind = vscode.CompletionItemKind.Field;
                forQUOTE_CHARACTERCompletion.insertText = new vscode.SnippetString("QUOTE_CHARACTER = \"${1}\"");
                forQUOTE_CHARACTERCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forQUOTE_CHARACTERCompletion);
                const forSHEET_NAMECompletion = new vscode.CompletionItem('SHEET_NAME');
                forSHEET_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                forSHEET_NAMECompletion.insertText = new vscode.SnippetString("SHEET_NAME = \"${1}\"");
                forSHEET_NAMECompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forSHEET_NAMECompletion);
                const forDATA_STARTS_AT_ROWCompletion = new vscode.CompletionItem('DATA_STARTS_AT_ROW');
                forDATA_STARTS_AT_ROWCompletion.kind = vscode.CompletionItemKind.Field;
                forDATA_STARTS_AT_ROWCompletion.insertText = new vscode.SnippetString("DATA_STARTS_AT_ROW = \"${1}\"");
                forDATA_STARTS_AT_ROWCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forDATA_STARTS_AT_ROWCompletion);
                const forDATA_STARTS_AT_COLUMNCompletion = new vscode.CompletionItem('DATA_STARTS_AT_COLUMN');
                forDATA_STARTS_AT_COLUMNCompletion.kind = vscode.CompletionItemKind.Field;
                forDATA_STARTS_AT_COLUMNCompletion.insertText = new vscode.SnippetString("DATA_STARTS_AT_COLUMN = \"${1}\"");
                forDATA_STARTS_AT_COLUMNCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forDATA_STARTS_AT_COLUMNCompletion);
                const forHEADER_ROWCompletion = new vscode.CompletionItem('HEADER_ROW');
                forHEADER_ROWCompletion.kind = vscode.CompletionItemKind.Field;
                forHEADER_ROWCompletion.insertText = new vscode.SnippetString("HEADER_ROW = \"${1}\"");
                forHEADER_ROWCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(forHEADER_ROWCompletion);
            }
            if (/.*\s*formatJson\s*\(.*/.test(linePrefix)) {
                const formatJsonJSONTEXTCompletion = new vscode.CompletionItem('JSONTEXT');
                formatJsonJSONTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                formatJsonJSONTEXTCompletion.insertText = new vscode.SnippetString("JSONTEXT = \"${1}\"");
                formatJsonJSONTEXTCompletion.documentation = new vscode.MarkdownString('Informationen im unformatierten JSON Format');
                items.push(formatJsonJSONTEXTCompletion);
                const formatJsonTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                formatJsonTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                formatJsonTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                formatJsonTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Element-Text geschrieben werden soll.');
                items.push(formatJsonTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*ftpConnect\s*\(.*/.test(linePrefix)) {
                const ftpConnectCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                ftpConnectCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                ftpConnectCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                ftpConnectCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der Verbindung. Dieser Name muss bei allen FTP*Connected-Kommandos, die mit der gleichen Verbindung arbeiten, \u00FCbereinstimmen.');
                items.push(ftpConnectCONNECTION_NAMECompletion);
                const ftpConnectSERVERCompletion = new vscode.CompletionItem('SERVER');
                ftpConnectSERVERCompletion.kind = vscode.CompletionItemKind.Field;
                ftpConnectSERVERCompletion.insertText = new vscode.SnippetString("SERVER = \"${1}\"");
                ftpConnectSERVERCompletion.documentation = new vscode.MarkdownString('Adresse des Servers');
                items.push(ftpConnectSERVERCompletion);
                const ftpConnectUSERCompletion = new vscode.CompletionItem('USER');
                ftpConnectUSERCompletion.kind = vscode.CompletionItemKind.Field;
                ftpConnectUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                ftpConnectUSERCompletion.documentation = new vscode.MarkdownString('Username. Bei leerem Wert wird anonymous eingesetzt.');
                items.push(ftpConnectUSERCompletion);
                const ftpConnectPWCompletion = new vscode.CompletionItem('PW');
                ftpConnectPWCompletion.kind = vscode.CompletionItemKind.Field;
                ftpConnectPWCompletion.insertText = new vscode.SnippetString("PW = \"${1}\"");
                ftpConnectPWCompletion.documentation = new vscode.MarkdownString('Passwort');
                items.push(ftpConnectPWCompletion);
                const ftpConnectPORTCompletion = new vscode.CompletionItem('PORT');
                ftpConnectPORTCompletion.kind = vscode.CompletionItemKind.Field;
                ftpConnectPORTCompletion.insertText = new vscode.SnippetString("PORT = \"${1}\"");
                ftpConnectPORTCompletion.documentation = new vscode.MarkdownString('Port des Servers');
                items.push(ftpConnectPORTCompletion);
                const ftpConnectIS_PASSIVECompletion = new vscode.CompletionItem('IS_PASSIVE');
                ftpConnectIS_PASSIVECompletion.kind = vscode.CompletionItemKind.Field;
                ftpConnectIS_PASSIVECompletion.insertText = new vscode.SnippetString("IS_PASSIVE = \"${1}\"");
                ftpConnectIS_PASSIVECompletion.documentation = new vscode.MarkdownString('True, falls im passiven Modus heruntergeladen werden soll. False per Default');
                items.push(ftpConnectIS_PASSIVECompletion);
            }
            if (/.*\s*ftpDelete\s*\(.*/.test(linePrefix)) {
                const ftpDeleteSERVERCompletion = new vscode.CompletionItem('SERVER');
                ftpDeleteSERVERCompletion.kind = vscode.CompletionItemKind.Field;
                ftpDeleteSERVERCompletion.insertText = new vscode.SnippetString("SERVER = \"${1}\"");
                ftpDeleteSERVERCompletion.documentation = new vscode.MarkdownString('Adresse des Servers');
                items.push(ftpDeleteSERVERCompletion);
                const ftpDeleteUSERCompletion = new vscode.CompletionItem('USER');
                ftpDeleteUSERCompletion.kind = vscode.CompletionItemKind.Field;
                ftpDeleteUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                ftpDeleteUSERCompletion.documentation = new vscode.MarkdownString('User');
                items.push(ftpDeleteUSERCompletion);
                const ftpDeletePWCompletion = new vscode.CompletionItem('PW');
                ftpDeletePWCompletion.kind = vscode.CompletionItemKind.Field;
                ftpDeletePWCompletion.insertText = new vscode.SnippetString("PW = \"${1}\"");
                ftpDeletePWCompletion.documentation = new vscode.MarkdownString('Passwort des Users');
                items.push(ftpDeletePWCompletion);
                const ftpDeleteSERVER_PATHCompletion = new vscode.CompletionItem('SERVER_PATH');
                ftpDeleteSERVER_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpDeleteSERVER_PATHCompletion.insertText = new vscode.SnippetString("SERVER_PATH = \"${1}\"");
                ftpDeleteSERVER_PATHCompletion.documentation = new vscode.MarkdownString('Auf dem Server befindlicher Pfad der zu l\u00F6schenden Datei oder des zu l\u00F6schenden Verzeichnisses.');
                items.push(ftpDeleteSERVER_PATHCompletion);
                const ftpDeletePORTCompletion = new vscode.CompletionItem('PORT');
                ftpDeletePORTCompletion.kind = vscode.CompletionItemKind.Field;
                ftpDeletePORTCompletion.insertText = new vscode.SnippetString("PORT = \"${1}\"");
                ftpDeletePORTCompletion.documentation = new vscode.MarkdownString('Port f\u00FCr die Verbindung');
                items.push(ftpDeletePORTCompletion);
                const ftpDeleteIS_PASSIVE_MODECompletion = new vscode.CompletionItem('IS_PASSIVE_MODE');
                ftpDeleteIS_PASSIVE_MODECompletion.kind = vscode.CompletionItemKind.Field;
                ftpDeleteIS_PASSIVE_MODECompletion.insertText = new vscode.SnippetString("IS_PASSIVE_MODE = \"${1}\"");
                ftpDeleteIS_PASSIVE_MODECompletion.documentation = new vscode.MarkdownString('Angabe, ob die Verbindung im Passive Mode ist. False per Default');
                items.push(ftpDeleteIS_PASSIVE_MODECompletion);
            }
            if (/.*\s*ftpDeleteConnected\s*\(.*/.test(linePrefix)) {
                const ftpDeleteConnectedCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                ftpDeleteConnectedCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                ftpDeleteConnectedCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                ftpDeleteConnectedCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der Verbindung. Dieser Name muss bei allen FTP*Connected-Kommandos, die mit der gleichen Verbindung arbeiten, \u00FCbereinstimmen.');
                items.push(ftpDeleteConnectedCONNECTION_NAMECompletion);
                const ftpDeleteConnectedSERVER_PATHCompletion = new vscode.CompletionItem('SERVER_PATH');
                ftpDeleteConnectedSERVER_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpDeleteConnectedSERVER_PATHCompletion.insertText = new vscode.SnippetString("SERVER_PATH = \"${1}\"");
                ftpDeleteConnectedSERVER_PATHCompletion.documentation = new vscode.MarkdownString('Auf dem Server befindlicher Pfad der zu l\u00F6schenden Datei oder des zu l\u00F6schenden Verzeichnisses.');
                items.push(ftpDeleteConnectedSERVER_PATHCompletion);
            }
            if (/.*\s*ftpDisconnect\s*\(.*/.test(linePrefix)) {
                const ftpDisconnectCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                ftpDisconnectCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                ftpDisconnectCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                ftpDisconnectCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der Verbindung. Dieser Name muss bei allen FTP*Connected-Kommandos, die mit der gleichen Verbindung arbeiten, \u00FCbereinstimmen.');
                items.push(ftpDisconnectCONNECTION_NAMECompletion);
            }
            if (/.*\s*ftpGet\s*\(.*/.test(linePrefix)) {
                const ftpGetSERVERCompletion = new vscode.CompletionItem('SERVER');
                ftpGetSERVERCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetSERVERCompletion.insertText = new vscode.SnippetString("SERVER = \"${1}\"");
                ftpGetSERVERCompletion.documentation = new vscode.MarkdownString('Adresse des Servers');
                items.push(ftpGetSERVERCompletion);
                const ftpGetUSERCompletion = new vscode.CompletionItem('USER');
                ftpGetUSERCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                ftpGetUSERCompletion.documentation = new vscode.MarkdownString('Username');
                items.push(ftpGetUSERCompletion);
                const ftpGetPWCompletion = new vscode.CompletionItem('PW');
                ftpGetPWCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetPWCompletion.insertText = new vscode.SnippetString("PW = \"${1}\"");
                ftpGetPWCompletion.documentation = new vscode.MarkdownString('Passwort');
                items.push(ftpGetPWCompletion);
                const ftpGetSERVER_PATHCompletion = new vscode.CompletionItem('SERVER_PATH');
                ftpGetSERVER_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetSERVER_PATHCompletion.insertText = new vscode.SnippetString("SERVER_PATH = \"${1}\"");
                ftpGetSERVER_PATHCompletion.documentation = new vscode.MarkdownString('Auf dem Server befindlicher Pfad der zu ladenden Datei oder des zu ladenden Verzeichnisses.');
                items.push(ftpGetSERVER_PATHCompletion);
                const ftpGetLOCAL_PATHCompletion = new vscode.CompletionItem('LOCAL_PATH');
                ftpGetLOCAL_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetLOCAL_PATHCompletion.insertText = new vscode.SnippetString("LOCAL_PATH = \"${1}\"");
                ftpGetLOCAL_PATHCompletion.documentation = new vscode.MarkdownString('Pfad auf dem lokalen System, unter dem der Ordner\/die Datei abzulegen ist.      Soll eine einzelne Datei abgelegt werden, ist der Dateiname ebenfalls hier anzugeben,       z.B. C:\/ftp-files\/dateiname, wobei \'dateiname\' eine noch nicht existierende lokale Datei bezeichnet.      Soll hingegen ein ganzer Ordner geladen werden, ist hier der Pfad zu diesem Ordner anzugeben,       z.B. C:\/ftp-files\/foldername\/, wobei \'foldername\' einen existierenden lokalen Ordner bezeichnet.');
                items.push(ftpGetLOCAL_PATHCompletion);
                const ftpGetPORTCompletion = new vscode.CompletionItem('PORT');
                ftpGetPORTCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetPORTCompletion.insertText = new vscode.SnippetString("PORT = \"${1}\"");
                ftpGetPORTCompletion.documentation = new vscode.MarkdownString('Port des Servers');
                items.push(ftpGetPORTCompletion);
                const ftpGetIS_BINARYCompletion = new vscode.CompletionItem('IS_BINARY');
                ftpGetIS_BINARYCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetIS_BINARYCompletion.insertText = new vscode.SnippetString("IS_BINARY = \"${1}\"");
                ftpGetIS_BINARYCompletion.documentation = new vscode.MarkdownString('True, falls die Daten im Bin\u00E4rformat \u00FCbertragen werden sollen. False per Default');
                items.push(ftpGetIS_BINARYCompletion);
                const ftpGetIS_PASSIVE_MODECompletion = new vscode.CompletionItem('IS_PASSIVE_MODE');
                ftpGetIS_PASSIVE_MODECompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetIS_PASSIVE_MODECompletion.insertText = new vscode.SnippetString("IS_PASSIVE_MODE = \"${1}\"");
                ftpGetIS_PASSIVE_MODECompletion.documentation = new vscode.MarkdownString('True, falls im passiven Modus heruntergeladen werden soll. False per Default');
                items.push(ftpGetIS_PASSIVE_MODECompletion);
            }
            if (/.*\s*ftpGetConnected\s*\(.*/.test(linePrefix)) {
                const ftpGetConnectedCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                ftpGetConnectedCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetConnectedCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                ftpGetConnectedCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der Verbindung. Dieser Name muss bei allen FTP*Connected-Kommandos, die mit der gleichen Verbindung arbeiten, \u00FCbereinstimmen.');
                items.push(ftpGetConnectedCONNECTION_NAMECompletion);
                const ftpGetConnectedSERVER_PATHCompletion = new vscode.CompletionItem('SERVER_PATH');
                ftpGetConnectedSERVER_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetConnectedSERVER_PATHCompletion.insertText = new vscode.SnippetString("SERVER_PATH = \"${1}\"");
                ftpGetConnectedSERVER_PATHCompletion.documentation = new vscode.MarkdownString('Auf dem Server befindlicher Pfad der zu ladenden Datei oder des zu ladenden Verzeichnisses.');
                items.push(ftpGetConnectedSERVER_PATHCompletion);
                const ftpGetConnectedLOCAL_PATHCompletion = new vscode.CompletionItem('LOCAL_PATH');
                ftpGetConnectedLOCAL_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetConnectedLOCAL_PATHCompletion.insertText = new vscode.SnippetString("LOCAL_PATH = \"${1}\"");
                ftpGetConnectedLOCAL_PATHCompletion.documentation = new vscode.MarkdownString('Pfad auf dem lokalen System, unter dem der Ordner\/die Datei abzulegen ist.      Soll eine einzelne Datei abgelegt werden, ist der Dateiname ebenfalls hier anzugeben,       z.B. C:\/ftp-files\/dateiname, wobei \'dateiname\' eine noch nicht existierende lokale Datei bezeichnet.      Soll hingegen ein ganzer Ordner geladen werden, ist hier der Pfad zu diesem Ordner anzugeben,       z.B. C:\/ftp-files\/foldername\/, wobei \'foldername\' einen existierenden lokalen Ordner bezeichnet.');
                items.push(ftpGetConnectedLOCAL_PATHCompletion);
                const ftpGetConnectedIS_BINARYCompletion = new vscode.CompletionItem('IS_BINARY');
                ftpGetConnectedIS_BINARYCompletion.kind = vscode.CompletionItemKind.Field;
                ftpGetConnectedIS_BINARYCompletion.insertText = new vscode.SnippetString("IS_BINARY = \"${1}\"");
                ftpGetConnectedIS_BINARYCompletion.documentation = new vscode.MarkdownString('Angabe, ob es sich um eine Bin\u00E4rdatei handelt. Default false.');
                items.push(ftpGetConnectedIS_BINARYCompletion);
            }
            if (/.*\s*ftpPut\s*\(.*/.test(linePrefix)) {
                const ftpPutSERVERCompletion = new vscode.CompletionItem('SERVER');
                ftpPutSERVERCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutSERVERCompletion.insertText = new vscode.SnippetString("SERVER = \"${1}\"");
                ftpPutSERVERCompletion.documentation = new vscode.MarkdownString('Adresse des Servers');
                items.push(ftpPutSERVERCompletion);
                const ftpPutUSERCompletion = new vscode.CompletionItem('USER');
                ftpPutUSERCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                ftpPutUSERCompletion.documentation = new vscode.MarkdownString('Username');
                items.push(ftpPutUSERCompletion);
                const ftpPutPWCompletion = new vscode.CompletionItem('PW');
                ftpPutPWCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutPWCompletion.insertText = new vscode.SnippetString("PW = \"${1}\"");
                ftpPutPWCompletion.documentation = new vscode.MarkdownString('Passwort');
                items.push(ftpPutPWCompletion);
                const ftpPutSERVER_PATHCompletion = new vscode.CompletionItem('SERVER_PATH');
                ftpPutSERVER_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutSERVER_PATHCompletion.insertText = new vscode.SnippetString("SERVER_PATH = \"${1}\"");
                ftpPutSERVER_PATHCompletion.documentation = new vscode.MarkdownString('Auf dem Server befindlicher Zielpfad der hochzuladenden Datei oder des zu hochzuladenden Verzeichnisses.');
                items.push(ftpPutSERVER_PATHCompletion);
                const ftpPutLOCAL_PATHCompletion = new vscode.CompletionItem('LOCAL_PATH');
                ftpPutLOCAL_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutLOCAL_PATHCompletion.insertText = new vscode.SnippetString("LOCAL_PATH = \"${1}\"");
                ftpPutLOCAL_PATHCompletion.documentation = new vscode.MarkdownString('Pfad auf dem lokalen System, aus dem der Ordner\/die Datei hochzuladen ist.');
                items.push(ftpPutLOCAL_PATHCompletion);
                const ftpPutPORTCompletion = new vscode.CompletionItem('PORT');
                ftpPutPORTCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutPORTCompletion.insertText = new vscode.SnippetString("PORT = \"${1}\"");
                ftpPutPORTCompletion.documentation = new vscode.MarkdownString('Port des Servers');
                items.push(ftpPutPORTCompletion);
                const ftpPutOPTIONAL_PARAMETERSCompletion = new vscode.CompletionItem('OPTIONAL_PARAMETERS');
                ftpPutOPTIONAL_PARAMETERSCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutOPTIONAL_PARAMETERSCompletion.insertText = new vscode.SnippetString("OPTIONAL_PARAMETERS = \"${1}\"");
                ftpPutOPTIONAL_PARAMETERSCompletion.documentation = new vscode.MarkdownString('Optionale Parameter, die per SITE \u00FCbergeben werden k\u00F6nnen');
                items.push(ftpPutOPTIONAL_PARAMETERSCompletion);
                const ftpPutIS_BINARYCompletion = new vscode.CompletionItem('IS_BINARY');
                ftpPutIS_BINARYCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutIS_BINARYCompletion.insertText = new vscode.SnippetString("IS_BINARY = \"${1}\"");
                ftpPutIS_BINARYCompletion.documentation = new vscode.MarkdownString('True, falls die Daten im Bin\u00E4rformat \u00FCbertragen werden sollen. False per Default');
                items.push(ftpPutIS_BINARYCompletion);
            }
            if (/.*\s*ftpPutConnected\s*\(.*/.test(linePrefix)) {
                const ftpPutConnectedCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                ftpPutConnectedCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutConnectedCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                ftpPutConnectedCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der Verbindung. Dieser Name muss bei allen FTP*Connected-Kommandos, die mit der gleichen Verbindung arbeiten, \u00FCbereinstimmen.');
                items.push(ftpPutConnectedCONNECTION_NAMECompletion);
                const ftpPutConnectedLOCAL_PATHCompletion = new vscode.CompletionItem('LOCAL_PATH');
                ftpPutConnectedLOCAL_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutConnectedLOCAL_PATHCompletion.insertText = new vscode.SnippetString("LOCAL_PATH = \"${1}\"");
                ftpPutConnectedLOCAL_PATHCompletion.documentation = new vscode.MarkdownString('Pfad auf dem lokalen System, aus dem der Ordner\/die Datei hochzuladen ist.');
                items.push(ftpPutConnectedLOCAL_PATHCompletion);
                const ftpPutConnectedSERVER_PATHCompletion = new vscode.CompletionItem('SERVER_PATH');
                ftpPutConnectedSERVER_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutConnectedSERVER_PATHCompletion.insertText = new vscode.SnippetString("SERVER_PATH = \"${1}\"");
                ftpPutConnectedSERVER_PATHCompletion.documentation = new vscode.MarkdownString('Auf dem Server befindlicher Zielpfad der hochzuladenden Datei oder des zu hochzuladenden Verzeichnisses.');
                items.push(ftpPutConnectedSERVER_PATHCompletion);
                const ftpPutConnectedOPTIONAL_PARAMETERSCompletion = new vscode.CompletionItem('OPTIONAL_PARAMETERS');
                ftpPutConnectedOPTIONAL_PARAMETERSCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutConnectedOPTIONAL_PARAMETERSCompletion.insertText = new vscode.SnippetString("OPTIONAL_PARAMETERS = \"${1}\"");
                ftpPutConnectedOPTIONAL_PARAMETERSCompletion.documentation = new vscode.MarkdownString('Optionaler Wert, ansonsten wird Standartwert verwendet');
                items.push(ftpPutConnectedOPTIONAL_PARAMETERSCompletion);
                const ftpPutConnectedIS_BINARYCompletion = new vscode.CompletionItem('IS_BINARY');
                ftpPutConnectedIS_BINARYCompletion.kind = vscode.CompletionItemKind.Field;
                ftpPutConnectedIS_BINARYCompletion.insertText = new vscode.SnippetString("IS_BINARY = \"${1}\"");
                ftpPutConnectedIS_BINARYCompletion.documentation = new vscode.MarkdownString('Angabe, ob es sich um eine Bin\u00E4rdatei handelt. Default false.');
                items.push(ftpPutConnectedIS_BINARYCompletion);
            }
            if (/.*\s*ftpSiteConnected\s*\(.*/.test(linePrefix)) {
                const ftpSiteConnectedCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                ftpSiteConnectedCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                ftpSiteConnectedCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                ftpSiteConnectedCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der Verbindung. Dieser Name muss bei allen FTP*Connected-Kommandos, die mit der gleichen Verbindung arbeiten, \u00FCbereinstimmen.');
                items.push(ftpSiteConnectedCONNECTION_NAMECompletion);
                const ftpSiteConnectedCOMMANDCompletion = new vscode.CompletionItem('COMMAND');
                ftpSiteConnectedCOMMANDCompletion.kind = vscode.CompletionItemKind.Field;
                ftpSiteConnectedCOMMANDCompletion.insertText = new vscode.SnippetString("COMMAND = \"${1}\"");
                ftpSiteConnectedCOMMANDCompletion.documentation = new vscode.MarkdownString('SITE Kommando');
                items.push(ftpSiteConnectedCOMMANDCompletion);
            }
            if (/.*\s*generateRandomWords\s*\(.*/.test(linePrefix)) {
                const generateRandomWordsROWNUMCompletion = new vscode.CompletionItem('ROWNUM');
                generateRandomWordsROWNUMCompletion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsROWNUMCompletion.insertText = new vscode.SnippetString("ROWNUM = \"${1}\"");
                generateRandomWordsROWNUMCompletion.documentation = new vscode.MarkdownString('Anzahl in der Zieldatei zu erzeugender Zeilen mit Zufallsw\u00F6rtern.');
                items.push(generateRandomWordsROWNUMCompletion);
                const generateRandomWordsFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                generateRandomWordsFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                generateRandomWordsFILENAMECompletion.documentation = new vscode.MarkdownString('Absoluter oder relativer Dateipfad der Zieldatei, in denen die Testdaten abgespeichert werden (z. B. C:\\temp\\xlsx01.xlsx oder xlsx01.xlsx) (als Testdatendatei in for-Schleife verwendbar).');
                items.push(generateRandomWordsFILENAMECompletion);
                const generateRandomWordsREGEX00Completion = new vscode.CompletionItem('REGEX00');
                generateRandomWordsREGEX00Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX00Completion.insertText = new vscode.SnippetString("REGEX00 = \"${1}\"");
                generateRandomWordsREGEX00Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX00Completion);
                const generateRandomWordsREGEX01Completion = new vscode.CompletionItem('REGEX01');
                generateRandomWordsREGEX01Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX01Completion.insertText = new vscode.SnippetString("REGEX01 = \"${1}\"");
                generateRandomWordsREGEX01Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX01Completion);
                const generateRandomWordsREGEX02Completion = new vscode.CompletionItem('REGEX02');
                generateRandomWordsREGEX02Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX02Completion.insertText = new vscode.SnippetString("REGEX02 = \"${1}\"");
                generateRandomWordsREGEX02Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX02Completion);
                const generateRandomWordsREGEX03Completion = new vscode.CompletionItem('REGEX03');
                generateRandomWordsREGEX03Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX03Completion.insertText = new vscode.SnippetString("REGEX03 = \"${1}\"");
                generateRandomWordsREGEX03Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX03Completion);
                const generateRandomWordsREGEX04Completion = new vscode.CompletionItem('REGEX04');
                generateRandomWordsREGEX04Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX04Completion.insertText = new vscode.SnippetString("REGEX04 = \"${1}\"");
                generateRandomWordsREGEX04Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX04Completion);
                const generateRandomWordsREGEX05Completion = new vscode.CompletionItem('REGEX05');
                generateRandomWordsREGEX05Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX05Completion.insertText = new vscode.SnippetString("REGEX05 = \"${1}\"");
                generateRandomWordsREGEX05Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX05Completion);
                const generateRandomWordsREGEX06Completion = new vscode.CompletionItem('REGEX06');
                generateRandomWordsREGEX06Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX06Completion.insertText = new vscode.SnippetString("REGEX06 = \"${1}\"");
                generateRandomWordsREGEX06Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX06Completion);
                const generateRandomWordsREGEX07Completion = new vscode.CompletionItem('REGEX07');
                generateRandomWordsREGEX07Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX07Completion.insertText = new vscode.SnippetString("REGEX07 = \"${1}\"");
                generateRandomWordsREGEX07Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX07Completion);
                const generateRandomWordsREGEX08Completion = new vscode.CompletionItem('REGEX08');
                generateRandomWordsREGEX08Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX08Completion.insertText = new vscode.SnippetString("REGEX08 = \"${1}\"");
                generateRandomWordsREGEX08Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX08Completion);
                const generateRandomWordsREGEX09Completion = new vscode.CompletionItem('REGEX09');
                generateRandomWordsREGEX09Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX09Completion.insertText = new vscode.SnippetString("REGEX09 = \"${1}\"");
                generateRandomWordsREGEX09Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX09Completion);
                const generateRandomWordsREGEX10Completion = new vscode.CompletionItem('REGEX10');
                generateRandomWordsREGEX10Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX10Completion.insertText = new vscode.SnippetString("REGEX10 = \"${1}\"");
                generateRandomWordsREGEX10Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX10Completion);
                const generateRandomWordsREGEX11Completion = new vscode.CompletionItem('REGEX11');
                generateRandomWordsREGEX11Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX11Completion.insertText = new vscode.SnippetString("REGEX11 = \"${1}\"");
                generateRandomWordsREGEX11Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX11Completion);
                const generateRandomWordsREGEX12Completion = new vscode.CompletionItem('REGEX12');
                generateRandomWordsREGEX12Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX12Completion.insertText = new vscode.SnippetString("REGEX12 = \"${1}\"");
                generateRandomWordsREGEX12Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX12Completion);
                const generateRandomWordsREGEX13Completion = new vscode.CompletionItem('REGEX13');
                generateRandomWordsREGEX13Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX13Completion.insertText = new vscode.SnippetString("REGEX13 = \"${1}\"");
                generateRandomWordsREGEX13Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX13Completion);
                const generateRandomWordsREGEX14Completion = new vscode.CompletionItem('REGEX14');
                generateRandomWordsREGEX14Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX14Completion.insertText = new vscode.SnippetString("REGEX14 = \"${1}\"");
                generateRandomWordsREGEX14Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX14Completion);
                const generateRandomWordsREGEX15Completion = new vscode.CompletionItem('REGEX15');
                generateRandomWordsREGEX15Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX15Completion.insertText = new vscode.SnippetString("REGEX15 = \"${1}\"");
                generateRandomWordsREGEX15Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX15Completion);
                const generateRandomWordsREGEX16Completion = new vscode.CompletionItem('REGEX16');
                generateRandomWordsREGEX16Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX16Completion.insertText = new vscode.SnippetString("REGEX16 = \"${1}\"");
                generateRandomWordsREGEX16Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX16Completion);
                const generateRandomWordsREGEX17Completion = new vscode.CompletionItem('REGEX17');
                generateRandomWordsREGEX17Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX17Completion.insertText = new vscode.SnippetString("REGEX17 = \"${1}\"");
                generateRandomWordsREGEX17Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX17Completion);
                const generateRandomWordsREGEX18Completion = new vscode.CompletionItem('REGEX18');
                generateRandomWordsREGEX18Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX18Completion.insertText = new vscode.SnippetString("REGEX18 = \"${1}\"");
                generateRandomWordsREGEX18Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX18Completion);
                const generateRandomWordsREGEX19Completion = new vscode.CompletionItem('REGEX19');
                generateRandomWordsREGEX19Completion.kind = vscode.CompletionItemKind.Field;
                generateRandomWordsREGEX19Completion.insertText = new vscode.SnippetString("REGEX19 = \"${1}\"");
                generateRandomWordsREGEX19Completion.documentation = new vscode.MarkdownString('REGEX');
                items.push(generateRandomWordsREGEX19Completion);
            }
            if (/.*\s*getAllFilesOfPath\s*\(.*/.test(linePrefix)) {
                const getAllFilesOfPathPATHCompletion = new vscode.CompletionItem('PATH');
                getAllFilesOfPathPATHCompletion.kind = vscode.CompletionItemKind.Field;
                getAllFilesOfPathPATHCompletion.insertText = new vscode.SnippetString("PATH = \"${1}\"");
                getAllFilesOfPathPATHCompletion.documentation = new vscode.MarkdownString('Pfad des Ordners');
                items.push(getAllFilesOfPathPATHCompletion);
                const getAllFilesOfPathABSOLUTE_PATHCompletion = new vscode.CompletionItem('ABSOLUTE_PATH');
                getAllFilesOfPathABSOLUTE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                getAllFilesOfPathABSOLUTE_PATHCompletion.insertText = new vscode.SnippetString("ABSOLUTE_PATH = \"${1}\"");
                getAllFilesOfPathABSOLUTE_PATHCompletion.documentation = new vscode.MarkdownString('Angabe, ob die Dateien mit einem absoluten Pfad angegeben werden soll oder nur der Dateiname (Dateiname als Default)');
                items.push(getAllFilesOfPathABSOLUTE_PATHCompletion);
                const getAllFilesOfPathCSV_FILECompletion = new vscode.CompletionItem('CSV_FILE');
                getAllFilesOfPathCSV_FILECompletion.kind = vscode.CompletionItemKind.Field;
                getAllFilesOfPathCSV_FILECompletion.insertText = new vscode.SnippetString("CSV_FILE = \"${1}\"");
                getAllFilesOfPathCSV_FILECompletion.documentation = new vscode.MarkdownString('Speicherort der CSV');
                items.push(getAllFilesOfPathCSV_FILECompletion);
                const getAllFilesOfPathFILE_EXTENSIONCompletion = new vscode.CompletionItem('FILE_EXTENSION');
                getAllFilesOfPathFILE_EXTENSIONCompletion.kind = vscode.CompletionItemKind.Field;
                getAllFilesOfPathFILE_EXTENSIONCompletion.insertText = new vscode.SnippetString("FILE_EXTENSION = \"${1}\"");
                getAllFilesOfPathFILE_EXTENSIONCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(getAllFilesOfPathFILE_EXTENSIONCompletion);
                const getAllFilesOfPathINCLUDE_HIDDEN_FILESCompletion = new vscode.CompletionItem('INCLUDE_HIDDEN_FILES');
                getAllFilesOfPathINCLUDE_HIDDEN_FILESCompletion.kind = vscode.CompletionItemKind.Field;
                getAllFilesOfPathINCLUDE_HIDDEN_FILESCompletion.insertText = new vscode.SnippetString("INCLUDE_HIDDEN_FILES = \"${1}\"");
                getAllFilesOfPathINCLUDE_HIDDEN_FILESCompletion.documentation = new vscode.MarkdownString('Versteckte Dateien werden angezeigt, falls true. Default false');
                items.push(getAllFilesOfPathINCLUDE_HIDDEN_FILESCompletion);
                const getAllFilesOfPathTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getAllFilesOfPathTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getAllFilesOfPathTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getAllFilesOfPathTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den die Anzahl der Dateien in einem Ordner geschrieben wird.');
                items.push(getAllFilesOfPathTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getAttributeFromElementWeb\s*\(.*/.test(linePrefix)) {
                const getAttributeFromElementWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                getAttributeFromElementWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                getAttributeFromElementWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                getAttributeFromElementWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, um das Element zu finden (z.B. CSS, xpath).');
                items.push(getAttributeFromElementWebBY_CRITERIACompletion);
                const getAttributeFromElementWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                getAttributeFromElementWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getAttributeFromElementWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                getAttributeFromElementWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Name des Elements, das Text enthalten soll.');
                items.push(getAttributeFromElementWebELEMENT_NAMECompletion);
                const getAttributeFromElementWebATTRIBUTE_NAMECompletion = new vscode.CompletionItem('ATTRIBUTE_NAME');
                getAttributeFromElementWebATTRIBUTE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getAttributeFromElementWebATTRIBUTE_NAMECompletion.insertText = new vscode.SnippetString("ATTRIBUTE_NAME = \"${1}\"");
                getAttributeFromElementWebATTRIBUTE_NAMECompletion.documentation = new vscode.MarkdownString('Name des Attributs des Elements.');
                items.push(getAttributeFromElementWebATTRIBUTE_NAMECompletion);
                const getAttributeFromElementWebTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getAttributeFromElementWebTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getAttributeFromElementWebTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getAttributeFromElementWebTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Element-Text geschrieben werden soll.');
                items.push(getAttributeFromElementWebTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getBrowserLog\s*\(.*/.test(linePrefix)) {
                const getBrowserLogOUTPUT_FILECompletion = new vscode.CompletionItem('OUTPUT_FILE');
                getBrowserLogOUTPUT_FILECompletion.kind = vscode.CompletionItemKind.Field;
                getBrowserLogOUTPUT_FILECompletion.insertText = new vscode.SnippetString("OUTPUT_FILE = \"${1}\"");
                getBrowserLogOUTPUT_FILECompletion.documentation = new vscode.MarkdownString('Datei, in die das Log gespeichert werden soll.');
                items.push(getBrowserLogOUTPUT_FILECompletion);
                const getBrowserLogOVERWRITE_EXISTING_OUTPUT_FILECompletion = new vscode.CompletionItem('OVERWRITE_EXISTING_OUTPUT_FILE');
                getBrowserLogOVERWRITE_EXISTING_OUTPUT_FILECompletion.kind = vscode.CompletionItemKind.Field;
                getBrowserLogOVERWRITE_EXISTING_OUTPUT_FILECompletion.insertText = new vscode.SnippetString("OVERWRITE_EXISTING_OUTPUT_FILE = \"${1}\"");
                getBrowserLogOVERWRITE_EXISTING_OUTPUT_FILECompletion.documentation = new vscode.MarkdownString('Soll der Inhalt einer bereits bestehenden Datei \u00FCberschrieben werden? (Default: True)');
                items.push(getBrowserLogOVERWRITE_EXISTING_OUTPUT_FILECompletion);
                const getBrowserLogOUTPUT_FILE_ENCODINGCompletion = new vscode.CompletionItem('OUTPUT_FILE_ENCODING');
                getBrowserLogOUTPUT_FILE_ENCODINGCompletion.kind = vscode.CompletionItemKind.Field;
                getBrowserLogOUTPUT_FILE_ENCODINGCompletion.insertText = new vscode.SnippetString("OUTPUT_FILE_ENCODING = \"${1}\"");
                getBrowserLogOUTPUT_FILE_ENCODINGCompletion.documentation = new vscode.MarkdownString('Encoding der Output-Datei (Default: UTF_8)');
                items.push(getBrowserLogOUTPUT_FILE_ENCODINGCompletion);
                const getBrowserLogPRINT_LOGCompletion = new vscode.CompletionItem('PRINT_LOG');
                getBrowserLogPRINT_LOGCompletion.kind = vscode.CompletionItemKind.Field;
                getBrowserLogPRINT_LOGCompletion.insertText = new vscode.SnippetString("PRINT_LOG = \"${1}\"");
                getBrowserLogPRINT_LOGCompletion.documentation = new vscode.MarkdownString('Soll der Inhalt des Browser-Logs auf der mateo-Konsole (mateo.log) ausgegeben werden? (Default: false)');
                items.push(getBrowserLogPRINT_LOGCompletion);
                const getBrowserLogLOG_LEVELCompletion = new vscode.CompletionItem('LOG_LEVEL');
                getBrowserLogLOG_LEVELCompletion.kind = vscode.CompletionItemKind.Field;
                getBrowserLogLOG_LEVELCompletion.insertText = new vscode.SnippetString("LOG_LEVEL = \"${1}\"");
                getBrowserLogLOG_LEVELCompletion.documentation = new vscode.MarkdownString('Log-Level, das herausgeschrieben werden soll. Einzelner Wert, keine Liste. Kritischere Log-Level sind mit eingeschlossen. Siehe java.util.logging.Level f\u00FCr Log-Level-Hierarchie.  Default ist INFO. M\u00F6glich sind:  OFF, SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST, ALL');
                items.push(getBrowserLogLOG_LEVELCompletion);
                const getBrowserLogLOG_TYPESCompletion = new vscode.CompletionItem('LOG_TYPES');
                getBrowserLogLOG_TYPESCompletion.kind = vscode.CompletionItemKind.Field;
                getBrowserLogLOG_TYPESCompletion.insertText = new vscode.SnippetString("LOG_TYPES = \"${1}\"");
                getBrowserLogLOG_TYPESCompletion.documentation = new vscode.MarkdownString('Liste (Separator: \';\') mit einem oder mehreren Typen von  Logs, die herausgeschrieben werden sollen (siehe org.openqa.selenium.logging.LogType). Default ist BROWSER. M\u00F6glich sind:  BROWSER, CLIENT, DRIVER, PERFORMANCE, PERFORMANCE, SERVER');
                items.push(getBrowserLogLOG_TYPESCompletion);
            }
            if (/.*\s*getColourFromFocussedWinEle\s*\(.*/.test(linePrefix)) {
                const getColourFromFocussedWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                getColourFromFocussedWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getColourFromFocussedWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                getColourFromFocussedWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(getColourFromFocussedWinEleWINDOW_NAMECompletion);
                const getColourFromFocussedWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                getColourFromFocussedWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getColourFromFocussedWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                getColourFromFocussedWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(getColourFromFocussedWinElePROCESS_NAMECompletion);
                const getColourFromFocussedWinEleEQUALS_COLOURCompletion = new vscode.CompletionItem('EQUALS_COLOUR');
                getColourFromFocussedWinEleEQUALS_COLOURCompletion.kind = vscode.CompletionItemKind.Field;
                getColourFromFocussedWinEleEQUALS_COLOURCompletion.insertText = new vscode.SnippetString("EQUALS_COLOUR = \"${1}\"");
                getColourFromFocussedWinEleEQUALS_COLOURCompletion.documentation = new vscode.MarkdownString('Farbe, mit dem die gefundene Farbe verglichen werden soll (Fromat: R-G-B)');
                items.push(getColourFromFocussedWinEleEQUALS_COLOURCompletion);
                const getColourFromFocussedWinEleTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getColourFromFocussedWinEleTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getColourFromFocussedWinEleTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getColourFromFocussedWinEleTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den das Resultat geschrieben werden soll.');
                items.push(getColourFromFocussedWinEleTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getCookiesWeb\s*\(.*/.test(linePrefix)) {
                const getCookiesWebURLCompletion = new vscode.CompletionItem('URL');
                getCookiesWebURLCompletion.kind = vscode.CompletionItemKind.Field;
                getCookiesWebURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                getCookiesWebURLCompletion.documentation = new vscode.MarkdownString('URL zu welcher die Cookies gel\u00F6scht werden sollen');
                items.push(getCookiesWebURLCompletion);
                const getCookiesWebCOOKIE_NAMECompletion = new vscode.CompletionItem('COOKIE_NAME');
                getCookiesWebCOOKIE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getCookiesWebCOOKIE_NAMECompletion.insertText = new vscode.SnippetString("COOKIE_NAME = \"${1}\"");
                getCookiesWebCOOKIE_NAMECompletion.documentation = new vscode.MarkdownString('Name des zu l\u00F6schenden Cookies');
                items.push(getCookiesWebCOOKIE_NAMECompletion);
                const getCookiesWebTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getCookiesWebTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getCookiesWebTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getCookiesWebTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel, worunter die Cookies in der Storage-Datei gespeichert werden sollen.');
                items.push(getCookiesWebTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getCurrentTitleWeb\s*\(.*/.test(linePrefix)) {
                const getCurrentTitleWebTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getCurrentTitleWebTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getCurrentTitleWebTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getCurrentTitleWebTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, unter dem der Titel abgelegt werden soll.');
                items.push(getCurrentTitleWebTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getCurrentURLMobile\s*\(.*/.test(linePrefix)) {
                const getCurrentURLMobileREGEX_FILTERCompletion = new vscode.CompletionItem('REGEX_FILTER');
                getCurrentURLMobileREGEX_FILTERCompletion.kind = vscode.CompletionItemKind.Field;
                getCurrentURLMobileREGEX_FILTERCompletion.insertText = new vscode.SnippetString("REGEX_FILTER = \"${1}\"");
                getCurrentURLMobileREGEX_FILTERCompletion.documentation = new vscode.MarkdownString('Ist der Parameter belegt, wird die erste Teilzeichenkette herausgegeben, die den regul\u00E4ren Ausdruck enth\u00E4lt.');
                items.push(getCurrentURLMobileREGEX_FILTERCompletion);
                const getCurrentURLMobileTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getCurrentURLMobileTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getCurrentURLMobileTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getCurrentURLMobileTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit dem Namen einer Variable belegt werden, in der die URL gespeichert werden soll.');
                items.push(getCurrentURLMobileTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getCurrentURLWeb\s*\(.*/.test(linePrefix)) {
                const getCurrentURLWebREGEX_FILTERCompletion = new vscode.CompletionItem('REGEX_FILTER');
                getCurrentURLWebREGEX_FILTERCompletion.kind = vscode.CompletionItemKind.Field;
                getCurrentURLWebREGEX_FILTERCompletion.insertText = new vscode.SnippetString("REGEX_FILTER = \"${1}\"");
                getCurrentURLWebREGEX_FILTERCompletion.documentation = new vscode.MarkdownString('Regul\u00E4rer Ausdruck, um den Text vor dem Speichern zu filtern');
                items.push(getCurrentURLWebREGEX_FILTERCompletion);
                const getCurrentURLWebTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getCurrentURLWebTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getCurrentURLWebTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getCurrentURLWebTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den die URL geschrieben werden soll.');
                items.push(getCurrentURLWebTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getItemByTextJava\s*\(.*/.test(linePrefix)) {
                const getItemByTextJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                getItemByTextJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                getItemByTextJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                getItemByTextJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(getItemByTextJavaTARGETCompletion);
                const getItemByTextJavaTEXTCompletion = new vscode.CompletionItem('TEXT');
                getItemByTextJavaTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                getItemByTextJavaTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                getItemByTextJavaTEXTCompletion.documentation = new vscode.MarkdownString('Text, welcher in dem Element geklickt werden soll');
                items.push(getItemByTextJavaTEXTCompletion);
                const getItemByTextJavaINDEXCompletion = new vscode.CompletionItem('INDEX');
                getItemByTextJavaINDEXCompletion.kind = vscode.CompletionItemKind.Field;
                getItemByTextJavaINDEXCompletion.insertText = new vscode.SnippetString("INDEX = \"${1}\"");
                getItemByTextJavaINDEXCompletion.documentation = new vscode.MarkdownString('Index der Zielspalte');
                items.push(getItemByTextJavaINDEXCompletion);
                const getItemByTextJavaOFFSETCompletion = new vscode.CompletionItem('OFFSET');
                getItemByTextJavaOFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                getItemByTextJavaOFFSETCompletion.insertText = new vscode.SnippetString("OFFSET = \"${1}\"");
                getItemByTextJavaOFFSETCompletion.documentation = new vscode.MarkdownString('Offset falls mehrere Elemente existieren');
                items.push(getItemByTextJavaOFFSETCompletion);
                const getItemByTextJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                getItemByTextJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                getItemByTextJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                getItemByTextJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(getItemByTextJavaWAIT_MILLISCompletion);
                const getItemByTextJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                getItemByTextJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getItemByTextJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                getItemByTextJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(getItemByTextJavaBY_NAMECompletion);
                const getItemByTextJavaCONTAINSCompletion = new vscode.CompletionItem('CONTAINS');
                getItemByTextJavaCONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                getItemByTextJavaCONTAINSCompletion.insertText = new vscode.SnippetString("CONTAINS = \"${1}\"");
                getItemByTextJavaCONTAINSCompletion.documentation = new vscode.MarkdownString('True, falls eine Zeichenreihenfolge eine Teilzeichenfolge enth\u00E4lt');
                items.push(getItemByTextJavaCONTAINSCompletion);
                const getItemByTextJavaTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getItemByTextJavaTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getItemByTextJavaTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getItemByTextJavaTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(getItemByTextJavaTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getSelectedElementDropDownWinEle\s*\(.*/.test(linePrefix)) {
                const getSelectedElementDropDownWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                getSelectedElementDropDownWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getSelectedElementDropDownWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                getSelectedElementDropDownWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(getSelectedElementDropDownWinEleWINDOW_NAMECompletion);
                const getSelectedElementDropDownWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                getSelectedElementDropDownWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getSelectedElementDropDownWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                getSelectedElementDropDownWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(getSelectedElementDropDownWinElePROCESS_NAMECompletion);
                const getSelectedElementDropDownWinEleDROPDOWN_NAMECompletion = new vscode.CompletionItem('DROPDOWN_NAME');
                getSelectedElementDropDownWinEleDROPDOWN_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getSelectedElementDropDownWinEleDROPDOWN_NAMECompletion.insertText = new vscode.SnippetString("DROPDOWN_NAME = \"${1}\"");
                getSelectedElementDropDownWinEleDROPDOWN_NAMECompletion.documentation = new vscode.MarkdownString('Name des Dropdown Men\u00FCs. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(getSelectedElementDropDownWinEleDROPDOWN_NAMECompletion);
                const getSelectedElementDropDownWinEleEQUALS_TEXTCompletion = new vscode.CompletionItem('EQUALS_TEXT');
                getSelectedElementDropDownWinEleEQUALS_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                getSelectedElementDropDownWinEleEQUALS_TEXTCompletion.insertText = new vscode.SnippetString("EQUALS_TEXT = \"${1}\"");
                getSelectedElementDropDownWinEleEQUALS_TEXTCompletion.documentation = new vscode.MarkdownString('Wert, mit dem der Inhalt verglichen werden soll');
                items.push(getSelectedElementDropDownWinEleEQUALS_TEXTCompletion);
                const getSelectedElementDropDownWinEleDROPDOWN_INDEXCompletion = new vscode.CompletionItem('DROPDOWN_INDEX');
                getSelectedElementDropDownWinEleDROPDOWN_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                getSelectedElementDropDownWinEleDROPDOWN_INDEXCompletion.insertText = new vscode.SnippetString("DROPDOWN_INDEX = \"${1}\"");
                getSelectedElementDropDownWinEleDROPDOWN_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Dropdown-menues des Fensers bezieht.');
                items.push(getSelectedElementDropDownWinEleDROPDOWN_INDEXCompletion);
                const getSelectedElementDropDownWinEleTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getSelectedElementDropDownWinEleTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getSelectedElementDropDownWinEleTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getSelectedElementDropDownWinEleTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den das Resultat geschrieben werden soll.');
                items.push(getSelectedElementDropDownWinEleTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getTextFromElementWeb\s*\(.*/.test(linePrefix)) {
                const getTextFromElementWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                getTextFromElementWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                getTextFromElementWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                getTextFromElementWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, um das Element zu finden (z.B. CSS, xpath).');
                items.push(getTextFromElementWebBY_CRITERIACompletion);
                const getTextFromElementWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                getTextFromElementWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getTextFromElementWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                getTextFromElementWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Name des Elements, das Text enthalten soll.');
                items.push(getTextFromElementWebELEMENT_NAMECompletion);
                const getTextFromElementWebREGEX_FILTERCompletion = new vscode.CompletionItem('REGEX_FILTER');
                getTextFromElementWebREGEX_FILTERCompletion.kind = vscode.CompletionItemKind.Field;
                getTextFromElementWebREGEX_FILTERCompletion.insertText = new vscode.SnippetString("REGEX_FILTER = \"${1}\"");
                getTextFromElementWebREGEX_FILTERCompletion.documentation = new vscode.MarkdownString('Regul\u00E4rer Ausdruck, um den Text vor dem Speichern zu filtern');
                items.push(getTextFromElementWebREGEX_FILTERCompletion);
                const getTextFromElementWebTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getTextFromElementWebTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getTextFromElementWebTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getTextFromElementWebTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Element-Text geschrieben werden soll.');
                items.push(getTextFromElementWebTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getTextFromFocussedWinEle\s*\(.*/.test(linePrefix)) {
                const getTextFromFocussedWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                getTextFromFocussedWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getTextFromFocussedWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                getTextFromFocussedWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(getTextFromFocussedWinEleWINDOW_NAMECompletion);
                const getTextFromFocussedWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                getTextFromFocussedWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getTextFromFocussedWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                getTextFromFocussedWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(getTextFromFocussedWinElePROCESS_NAMECompletion);
                const getTextFromFocussedWinEleEQUALS_TEXTCompletion = new vscode.CompletionItem('EQUALS_TEXT');
                getTextFromFocussedWinEleEQUALS_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                getTextFromFocussedWinEleEQUALS_TEXTCompletion.insertText = new vscode.SnippetString("EQUALS_TEXT = \"${1}\"");
                getTextFromFocussedWinEleEQUALS_TEXTCompletion.documentation = new vscode.MarkdownString('String, mit dem der gefundene Text verglichen werden soll. Wird \'BLANK\' \u00FCbergeben, wird gepr\u00FCft ob das Feld leer ist.');
                items.push(getTextFromFocussedWinEleEQUALS_TEXTCompletion);
                const getTextFromFocussedWinEleTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getTextFromFocussedWinEleTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getTextFromFocussedWinEleTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getTextFromFocussedWinEleTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den das Resultat geschrieben werden soll.');
                items.push(getTextFromFocussedWinEleTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getTextJava\s*\(.*/.test(linePrefix)) {
                const getTextJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                getTextJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                getTextJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                getTextJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(getTextJavaTARGETCompletion);
                const getTextJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                getTextJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                getTextJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                getTextJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(getTextJavaWAIT_MILLISCompletion);
                const getTextJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                getTextJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getTextJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                getTextJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(getTextJavaBY_NAMECompletion);
                const getTextJavaTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getTextJavaTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getTextJavaTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getTextJavaTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Optionaler Key im Storage um den R\u00FCckgabewert zu speichern');
                items.push(getTextJavaTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getTextMobile\s*\(.*/.test(linePrefix)) {
                const getTextMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                getTextMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                getTextMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                getTextMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(getTextMobileBY_CRITERIACompletion);
                const getTextMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                getTextMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                getTextMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                getTextMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(getTextMobileEXPRESSION_TEXTCompletion);
                const getTextMobileCOMPARE_TOCompletion = new vscode.CompletionItem('COMPARE_TO');
                getTextMobileCOMPARE_TOCompletion.kind = vscode.CompletionItemKind.Field;
                getTextMobileCOMPARE_TOCompletion.insertText = new vscode.SnippetString("COMPARE_TO = \"${1}\"");
                getTextMobileCOMPARE_TOCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit einem Text belegt werden, mit dem der ausgegeben Text verglichen wird. Weicht der ausgegebene Text von diesem Parameter ab, wird eine Warnung ausgegeben. Wird der Parameter mit \'BLANK\' belegt, wird \u00FCberpr\u00FCft, ob der Text leer ist.');
                items.push(getTextMobileCOMPARE_TOCompletion);
                const getTextMobileTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getTextMobileTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getTextMobileTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getTextMobileTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Ist der Parameter belegt, wird der Text, der ausgegeben wird, in eine Variable mit diesem Namen gespeichert.');
                items.push(getTextMobileTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*getTextWindow\s*\(.*/.test(linePrefix)) {
                const getTextWindowWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                getTextWindowWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                getTextWindowWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                getTextWindowWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(getTextWindowWINDOW_NAMECompletion);
                const getTextWindowTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                getTextWindowTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                getTextWindowTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                getTextWindowTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier muss ein Schl\u00FCssel gesetzt werden, unter dem der Text des Fensters gespeichert wird.');
                items.push(getTextWindowTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*greaterThanAlpha\s*\(.*/.test(linePrefix)) {
                const greaterThanAlphaLEFTCompletion = new vscode.CompletionItem('LEFT');
                greaterThanAlphaLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                greaterThanAlphaLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                greaterThanAlphaLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(greaterThanAlphaLEFTCompletion);
                const greaterThanAlphaRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                greaterThanAlphaRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                greaterThanAlphaRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                greaterThanAlphaRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(greaterThanAlphaRIGHTCompletion);
            }
            if (/.*\s*greaterThanDate\s*\(.*/.test(linePrefix)) {
                const greaterThanDateLEFTCompletion = new vscode.CompletionItem('LEFT');
                greaterThanDateLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                greaterThanDateLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                greaterThanDateLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(greaterThanDateLEFTCompletion);
                const greaterThanDateRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                greaterThanDateRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                greaterThanDateRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                greaterThanDateRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(greaterThanDateRIGHTCompletion);
            }
            if (/.*\s*greaterThanNum\s*\(.*/.test(linePrefix)) {
                const greaterThanNumLEFTCompletion = new vscode.CompletionItem('LEFT');
                greaterThanNumLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                greaterThanNumLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                greaterThanNumLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(greaterThanNumLEFTCompletion);
                const greaterThanNumRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                greaterThanNumRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                greaterThanNumRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                greaterThanNumRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(greaterThanNumRIGHTCompletion);
            }
            if (/.*\s*help\s*\(.*/.test(linePrefix)) {
                const helpMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                helpMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                helpMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                helpMESSAGECompletion.documentation = new vscode.MarkdownString('Abzulegende Nachricht.');
                items.push(helpMESSAGECompletion);
                const helpFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                helpFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                helpFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                helpFILENAMECompletion.documentation = new vscode.MarkdownString('Pfad und Name der Datei.');
                items.push(helpFILENAMECompletion);
            }
            if (/.*\s*hideCommandOverlay\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*hideKeyboard\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*hoverAndClickWeb\s*\(.*/.test(linePrefix)) {
                const hoverAndClickWebBY_CRITERIA_HOVERCompletion = new vscode.CompletionItem('BY_CRITERIA_HOVER');
                hoverAndClickWebBY_CRITERIA_HOVERCompletion.kind = vscode.CompletionItemKind.Field;
                hoverAndClickWebBY_CRITERIA_HOVERCompletion.insertText = new vscode.SnippetString("BY_CRITERIA_HOVER = \"${1}\"");
                hoverAndClickWebBY_CRITERIA_HOVERCompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Hover-Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden.');
                items.push(hoverAndClickWebBY_CRITERIA_HOVERCompletion);
                const hoverAndClickWebELEMENT_NAME_HOVERCompletion = new vscode.CompletionItem('ELEMENT_NAME_HOVER');
                hoverAndClickWebELEMENT_NAME_HOVERCompletion.kind = vscode.CompletionItemKind.Field;
                hoverAndClickWebELEMENT_NAME_HOVERCompletion.insertText = new vscode.SnippetString("ELEMENT_NAME_HOVER = \"${1}\"");
                hoverAndClickWebELEMENT_NAME_HOVERCompletion.documentation = new vscode.MarkdownString('Bezeichner des Hover-Elements abh\u00E4ngig vom Kriterium.');
                items.push(hoverAndClickWebELEMENT_NAME_HOVERCompletion);
                const hoverAndClickWebBY_CRITERIA_CLICKCompletion = new vscode.CompletionItem('BY_CRITERIA_CLICK');
                hoverAndClickWebBY_CRITERIA_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                hoverAndClickWebBY_CRITERIA_CLICKCompletion.insertText = new vscode.SnippetString("BY_CRITERIA_CLICK = \"${1}\"");
                hoverAndClickWebBY_CRITERIA_CLICKCompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Click-Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden.');
                items.push(hoverAndClickWebBY_CRITERIA_CLICKCompletion);
                const hoverAndClickWebELEMENT_NAME_CLICKCompletion = new vscode.CompletionItem('ELEMENT_NAME_CLICK');
                hoverAndClickWebELEMENT_NAME_CLICKCompletion.kind = vscode.CompletionItemKind.Field;
                hoverAndClickWebELEMENT_NAME_CLICKCompletion.insertText = new vscode.SnippetString("ELEMENT_NAME_CLICK = \"${1}\"");
                hoverAndClickWebELEMENT_NAME_CLICKCompletion.documentation = new vscode.MarkdownString('Bezeichner des Click-Elements abh\u00E4ngig vom Kriterium.');
                items.push(hoverAndClickWebELEMENT_NAME_CLICKCompletion);
                const hoverAndClickWebSCROLL_XCompletion = new vscode.CompletionItem('SCROLL_X');
                hoverAndClickWebSCROLL_XCompletion.kind = vscode.CompletionItemKind.Field;
                hoverAndClickWebSCROLL_XCompletion.insertText = new vscode.SnippetString("SCROLL_X = \"${1}\"");
                hoverAndClickWebSCROLL_XCompletion.documentation = new vscode.MarkdownString('Anzahl des Pixel in horizontaler Richtung, um die das Fenster in Verh\u00E4ltnis zum Hover-Punkt vor dem Klicken des Click-Punkts verschoben werden soll.');
                items.push(hoverAndClickWebSCROLL_XCompletion);
                const hoverAndClickWebSCROLL_YCompletion = new vscode.CompletionItem('SCROLL_Y');
                hoverAndClickWebSCROLL_YCompletion.kind = vscode.CompletionItemKind.Field;
                hoverAndClickWebSCROLL_YCompletion.insertText = new vscode.SnippetString("SCROLL_Y = \"${1}\"");
                hoverAndClickWebSCROLL_YCompletion.documentation = new vscode.MarkdownString('Anzahl des Pixel in vertikaler Richtung, um die das Fenster in Verh\u00E4ltnis zum Hover-Punkt vor dem Klicken des Click-Punkts verschoben werden soll.');
                items.push(hoverAndClickWebSCROLL_YCompletion);
                const hoverAndClickWebCLICK_ON_HOVER_ELEMENTCompletion = new vscode.CompletionItem('CLICK_ON_HOVER_ELEMENT');
                hoverAndClickWebCLICK_ON_HOVER_ELEMENTCompletion.kind = vscode.CompletionItemKind.Field;
                hoverAndClickWebCLICK_ON_HOVER_ELEMENTCompletion.insertText = new vscode.SnippetString("CLICK_ON_HOVER_ELEMENT = \"${1}\"");
                hoverAndClickWebCLICK_ON_HOVER_ELEMENTCompletion.documentation = new vscode.MarkdownString('Soll das nach dem Bewegen der Maus auf das Hover-Element auch ein Klick auf das Hover-Element erfolgen? Default: true');
                items.push(hoverAndClickWebCLICK_ON_HOVER_ELEMENTCompletion);
            }
            if (/.*\s*httpDelete\s*\(.*/.test(linePrefix)) {
                const httpDeleteURLCompletion = new vscode.CompletionItem('URL');
                httpDeleteURLCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                httpDeleteURLCompletion.documentation = new vscode.MarkdownString('URL des Webservices');
                items.push(httpDeleteURLCompletion);
                const httpDeleteUSERNAMECompletion = new vscode.CompletionItem('USERNAME');
                httpDeleteUSERNAMECompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteUSERNAMECompletion.insertText = new vscode.SnippetString("USERNAME = \"${1}\"");
                httpDeleteUSERNAMECompletion.documentation = new vscode.MarkdownString('Username f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpDeleteUSERNAMECompletion);
                const httpDeletePASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                httpDeletePASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeletePASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                httpDeletePASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpDeletePASSWORDCompletion);
                const httpDeleteBODYCompletion = new vscode.CompletionItem('BODY');
                httpDeleteBODYCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteBODYCompletion.insertText = new vscode.SnippetString("BODY = \"${1}\"");
                httpDeleteBODYCompletion.documentation = new vscode.MarkdownString('HTTP Body');
                items.push(httpDeleteBODYCompletion);
                const httpDeleteCONTENT_TYPECompletion = new vscode.CompletionItem('CONTENT_TYPE');
                httpDeleteCONTENT_TYPECompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteCONTENT_TYPECompletion.insertText = new vscode.SnippetString("CONTENT_TYPE = \"${1}\"");
                httpDeleteCONTENT_TYPECompletion.documentation = new vscode.MarkdownString('Content Type');
                items.push(httpDeleteCONTENT_TYPECompletion);
                const httpDeleteIS_FILE_BODYCompletion = new vscode.CompletionItem('IS_FILE_BODY');
                httpDeleteIS_FILE_BODYCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteIS_FILE_BODYCompletion.insertText = new vscode.SnippetString("IS_FILE_BODY = \"${1}\"");
                httpDeleteIS_FILE_BODYCompletion.documentation = new vscode.MarkdownString('\'true\' wenn im Parameter Body eine Datei angegeben werden soll.');
                items.push(httpDeleteIS_FILE_BODYCompletion);
                const httpDeleteHEADERCompletion = new vscode.CompletionItem('HEADER');
                httpDeleteHEADERCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteHEADERCompletion.insertText = new vscode.SnippetString("HEADER = \"${1}\"");
                httpDeleteHEADERCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(httpDeleteHEADERCompletion);
                const httpDeleteSHORT_OUTPUTCompletion = new vscode.CompletionItem('SHORT_OUTPUT');
                httpDeleteSHORT_OUTPUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteSHORT_OUTPUTCompletion.insertText = new vscode.SnippetString("SHORT_OUTPUT = \"${1}\"");
                httpDeleteSHORT_OUTPUTCompletion.documentation = new vscode.MarkdownString('kurze Ausgabe');
                items.push(httpDeleteSHORT_OUTPUTCompletion);
                const httpDeleteTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                httpDeleteTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                httpDeleteTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis des Aufrufs gespeichert wird.');
                items.push(httpDeleteTARGET_STORAGE_KEYCompletion);
                const httpDeleteWRITE_TO_FILECompletion = new vscode.CompletionItem('WRITE_TO_FILE');
                httpDeleteWRITE_TO_FILECompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteWRITE_TO_FILECompletion.insertText = new vscode.SnippetString("WRITE_TO_FILE = \"${1}\"");
                httpDeleteWRITE_TO_FILECompletion.documentation = new vscode.MarkdownString('Ins Verzeichnis schreiben');
                items.push(httpDeleteWRITE_TO_FILECompletion);
                const httpDeleteHTTPSTATUS_STORAGE_KEYCompletion = new vscode.CompletionItem('HTTPSTATUS_STORAGE_KEY');
                httpDeleteHTTPSTATUS_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteHTTPSTATUS_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("HTTPSTATUS_STORAGE_KEY = \"${1}\"");
                httpDeleteHTTPSTATUS_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem der Status des Aufrufsergebnisses gespeichert wird.');
                items.push(httpDeleteHTTPSTATUS_STORAGE_KEYCompletion);
                const httpDeleteSAVE_HEADERSCompletion = new vscode.CompletionItem('SAVE_HEADERS');
                httpDeleteSAVE_HEADERSCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteSAVE_HEADERSCompletion.insertText = new vscode.SnippetString("SAVE_HEADERS = \"${1}\"");
                httpDeleteSAVE_HEADERSCompletion.documentation = new vscode.MarkdownString('Speichert die Header der Response in den Storage (httpheaders_<headername>)');
                items.push(httpDeleteSAVE_HEADERSCompletion);
                const httpDeleteTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                httpDeleteTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpDeleteTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                httpDeleteTIMEOUTCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Timeout gesetzt werden');
                items.push(httpDeleteTIMEOUTCompletion);
            }
            if (/.*\s*httpGet\s*\(.*/.test(linePrefix)) {
                const httpGetURLCompletion = new vscode.CompletionItem('URL');
                httpGetURLCompletion.kind = vscode.CompletionItemKind.Field;
                httpGetURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                httpGetURLCompletion.documentation = new vscode.MarkdownString('URL des Webservices');
                items.push(httpGetURLCompletion);
                const httpGetUSERNAMECompletion = new vscode.CompletionItem('USERNAME');
                httpGetUSERNAMECompletion.kind = vscode.CompletionItemKind.Field;
                httpGetUSERNAMECompletion.insertText = new vscode.SnippetString("USERNAME = \"${1}\"");
                httpGetUSERNAMECompletion.documentation = new vscode.MarkdownString('Username f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpGetUSERNAMECompletion);
                const httpGetPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                httpGetPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                httpGetPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                httpGetPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpGetPASSWORDCompletion);
                const httpGetHEADERCompletion = new vscode.CompletionItem('HEADER');
                httpGetHEADERCompletion.kind = vscode.CompletionItemKind.Field;
                httpGetHEADERCompletion.insertText = new vscode.SnippetString("HEADER = \"${1}\"");
                httpGetHEADERCompletion.documentation = new vscode.MarkdownString('Zusatzinformationen die Nutzdaten am Anfang eines Datenblocks erg\u00E4nzen');
                items.push(httpGetHEADERCompletion);
                const httpGetTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                httpGetTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpGetTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                httpGetTIMEOUTCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Timeout gesetzt werden');
                items.push(httpGetTIMEOUTCompletion);
                const httpGetSHORT_OUTPUTCompletion = new vscode.CompletionItem('SHORT_OUTPUT');
                httpGetSHORT_OUTPUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpGetSHORT_OUTPUTCompletion.insertText = new vscode.SnippetString("SHORT_OUTPUT = \"${1}\"");
                httpGetSHORT_OUTPUTCompletion.documentation = new vscode.MarkdownString('kurze Ausgabe');
                items.push(httpGetSHORT_OUTPUTCompletion);
                const httpGetTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                httpGetTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpGetTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                httpGetTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis des Aufrufs gespeichert wird.');
                items.push(httpGetTARGET_STORAGE_KEYCompletion);
                const httpGetWRITE_TO_FILECompletion = new vscode.CompletionItem('WRITE_TO_FILE');
                httpGetWRITE_TO_FILECompletion.kind = vscode.CompletionItemKind.Field;
                httpGetWRITE_TO_FILECompletion.insertText = new vscode.SnippetString("WRITE_TO_FILE = \"${1}\"");
                httpGetWRITE_TO_FILECompletion.documentation = new vscode.MarkdownString('Ins Verzeichnis schreiben');
                items.push(httpGetWRITE_TO_FILECompletion);
                const httpGetHTTPSTATUS_STORAGE_KEYCompletion = new vscode.CompletionItem('HTTPSTATUS_STORAGE_KEY');
                httpGetHTTPSTATUS_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpGetHTTPSTATUS_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("HTTPSTATUS_STORAGE_KEY = \"${1}\"");
                httpGetHTTPSTATUS_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem der Status des Aufrufsergebnisses gespeichert wird.');
                items.push(httpGetHTTPSTATUS_STORAGE_KEYCompletion);
                const httpGetSAVE_HEADERSCompletion = new vscode.CompletionItem('SAVE_HEADERS');
                httpGetSAVE_HEADERSCompletion.kind = vscode.CompletionItemKind.Field;
                httpGetSAVE_HEADERSCompletion.insertText = new vscode.SnippetString("SAVE_HEADERS = \"${1}\"");
                httpGetSAVE_HEADERSCompletion.documentation = new vscode.MarkdownString('Speichert die Header der Response in den Storage (httpheaders_<headername>)');
                items.push(httpGetSAVE_HEADERSCompletion);
            }
            if (/.*\s*httpPatch\s*\(.*/.test(linePrefix)) {
                const httpPatchURLCompletion = new vscode.CompletionItem('URL');
                httpPatchURLCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                httpPatchURLCompletion.documentation = new vscode.MarkdownString('URL des Webservices');
                items.push(httpPatchURLCompletion);
                const httpPatchUSERNAMECompletion = new vscode.CompletionItem('USERNAME');
                httpPatchUSERNAMECompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchUSERNAMECompletion.insertText = new vscode.SnippetString("USERNAME = \"${1}\"");
                httpPatchUSERNAMECompletion.documentation = new vscode.MarkdownString('Username f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpPatchUSERNAMECompletion);
                const httpPatchPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                httpPatchPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                httpPatchPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpPatchPASSWORDCompletion);
                const httpPatchBODYCompletion = new vscode.CompletionItem('BODY');
                httpPatchBODYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchBODYCompletion.insertText = new vscode.SnippetString("BODY = \"${1}\"");
                httpPatchBODYCompletion.documentation = new vscode.MarkdownString('HTTP Body');
                items.push(httpPatchBODYCompletion);
                const httpPatchCONTENT_TYPECompletion = new vscode.CompletionItem('CONTENT_TYPE');
                httpPatchCONTENT_TYPECompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchCONTENT_TYPECompletion.insertText = new vscode.SnippetString("CONTENT_TYPE = \"${1}\"");
                httpPatchCONTENT_TYPECompletion.documentation = new vscode.MarkdownString('Content Type');
                items.push(httpPatchCONTENT_TYPECompletion);
                const httpPatchIS_FILE_BODYCompletion = new vscode.CompletionItem('IS_FILE_BODY');
                httpPatchIS_FILE_BODYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchIS_FILE_BODYCompletion.insertText = new vscode.SnippetString("IS_FILE_BODY = \"${1}\"");
                httpPatchIS_FILE_BODYCompletion.documentation = new vscode.MarkdownString('\'true\' wenn im Parameter Body eine Datei angegeben werden soll.');
                items.push(httpPatchIS_FILE_BODYCompletion);
                const httpPatchHEADERCompletion = new vscode.CompletionItem('HEADER');
                httpPatchHEADERCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchHEADERCompletion.insertText = new vscode.SnippetString("HEADER = \"${1}\"");
                httpPatchHEADERCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(httpPatchHEADERCompletion);
                const httpPatchSHORT_OUTPUTCompletion = new vscode.CompletionItem('SHORT_OUTPUT');
                httpPatchSHORT_OUTPUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchSHORT_OUTPUTCompletion.insertText = new vscode.SnippetString("SHORT_OUTPUT = \"${1}\"");
                httpPatchSHORT_OUTPUTCompletion.documentation = new vscode.MarkdownString('kurze Ausgabe');
                items.push(httpPatchSHORT_OUTPUTCompletion);
                const httpPatchTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                httpPatchTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                httpPatchTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis des Aufrufs gespeichert wird.');
                items.push(httpPatchTARGET_STORAGE_KEYCompletion);
                const httpPatchWRITE_TO_FILECompletion = new vscode.CompletionItem('WRITE_TO_FILE');
                httpPatchWRITE_TO_FILECompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchWRITE_TO_FILECompletion.insertText = new vscode.SnippetString("WRITE_TO_FILE = \"${1}\"");
                httpPatchWRITE_TO_FILECompletion.documentation = new vscode.MarkdownString('Ins Verzeichnis schreiben');
                items.push(httpPatchWRITE_TO_FILECompletion);
                const httpPatchHTTPSTATUS_STORAGE_KEYCompletion = new vscode.CompletionItem('HTTPSTATUS_STORAGE_KEY');
                httpPatchHTTPSTATUS_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchHTTPSTATUS_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("HTTPSTATUS_STORAGE_KEY = \"${1}\"");
                httpPatchHTTPSTATUS_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem der Status des Aufrufsergebnisses gespeichert wird.');
                items.push(httpPatchHTTPSTATUS_STORAGE_KEYCompletion);
                const httpPatchSAVE_HEADERSCompletion = new vscode.CompletionItem('SAVE_HEADERS');
                httpPatchSAVE_HEADERSCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchSAVE_HEADERSCompletion.insertText = new vscode.SnippetString("SAVE_HEADERS = \"${1}\"");
                httpPatchSAVE_HEADERSCompletion.documentation = new vscode.MarkdownString('Speichert die Header der Response in den Storage (httpheaders_<headername>)');
                items.push(httpPatchSAVE_HEADERSCompletion);
                const httpPatchTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                httpPatchTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpPatchTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                httpPatchTIMEOUTCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Timeout gesetzt werden');
                items.push(httpPatchTIMEOUTCompletion);
            }
            if (/.*\s*httpPost\s*\(.*/.test(linePrefix)) {
                const httpPostURLCompletion = new vscode.CompletionItem('URL');
                httpPostURLCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                httpPostURLCompletion.documentation = new vscode.MarkdownString('URL des Webservices');
                items.push(httpPostURLCompletion);
                const httpPostUSERNAMECompletion = new vscode.CompletionItem('USERNAME');
                httpPostUSERNAMECompletion.kind = vscode.CompletionItemKind.Field;
                httpPostUSERNAMECompletion.insertText = new vscode.SnippetString("USERNAME = \"${1}\"");
                httpPostUSERNAMECompletion.documentation = new vscode.MarkdownString('Username f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpPostUSERNAMECompletion);
                const httpPostPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                httpPostPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                httpPostPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpPostPASSWORDCompletion);
                const httpPostBODYCompletion = new vscode.CompletionItem('BODY');
                httpPostBODYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostBODYCompletion.insertText = new vscode.SnippetString("BODY = \"${1}\"");
                httpPostBODYCompletion.documentation = new vscode.MarkdownString('HTTP Body');
                items.push(httpPostBODYCompletion);
                const httpPostCONTENT_TYPECompletion = new vscode.CompletionItem('CONTENT_TYPE');
                httpPostCONTENT_TYPECompletion.kind = vscode.CompletionItemKind.Field;
                httpPostCONTENT_TYPECompletion.insertText = new vscode.SnippetString("CONTENT_TYPE = \"${1}\"");
                httpPostCONTENT_TYPECompletion.documentation = new vscode.MarkdownString('Content Type');
                items.push(httpPostCONTENT_TYPECompletion);
                const httpPostIS_FILE_BODYCompletion = new vscode.CompletionItem('IS_FILE_BODY');
                httpPostIS_FILE_BODYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostIS_FILE_BODYCompletion.insertText = new vscode.SnippetString("IS_FILE_BODY = \"${1}\"");
                httpPostIS_FILE_BODYCompletion.documentation = new vscode.MarkdownString('\'true\' wenn im Parameter Body eine Datei angegeben werden soll.');
                items.push(httpPostIS_FILE_BODYCompletion);
                const httpPostHEADERCompletion = new vscode.CompletionItem('HEADER');
                httpPostHEADERCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostHEADERCompletion.insertText = new vscode.SnippetString("HEADER = \"${1}\"");
                httpPostHEADERCompletion.documentation = new vscode.MarkdownString('Zusatzinformationen die Nutzdaten am Anfang eines Datenblocks erg\u00E4nzen');
                items.push(httpPostHEADERCompletion);
                const httpPostSHORT_OUTPUTCompletion = new vscode.CompletionItem('SHORT_OUTPUT');
                httpPostSHORT_OUTPUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostSHORT_OUTPUTCompletion.insertText = new vscode.SnippetString("SHORT_OUTPUT = \"${1}\"");
                httpPostSHORT_OUTPUTCompletion.documentation = new vscode.MarkdownString('kurze Ausgabe');
                items.push(httpPostSHORT_OUTPUTCompletion);
                const httpPostTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                httpPostTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                httpPostTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis des Aufrufs gespeichert wird.');
                items.push(httpPostTARGET_STORAGE_KEYCompletion);
                const httpPostWRITE_TO_FILECompletion = new vscode.CompletionItem('WRITE_TO_FILE');
                httpPostWRITE_TO_FILECompletion.kind = vscode.CompletionItemKind.Field;
                httpPostWRITE_TO_FILECompletion.insertText = new vscode.SnippetString("WRITE_TO_FILE = \"${1}\"");
                httpPostWRITE_TO_FILECompletion.documentation = new vscode.MarkdownString('Ins Verzeichnis schreiben');
                items.push(httpPostWRITE_TO_FILECompletion);
                const httpPostHTTPSTATUS_STORAGE_KEYCompletion = new vscode.CompletionItem('HTTPSTATUS_STORAGE_KEY');
                httpPostHTTPSTATUS_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostHTTPSTATUS_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("HTTPSTATUS_STORAGE_KEY = \"${1}\"");
                httpPostHTTPSTATUS_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem der Status des Aufrufsergebnisses gespeichert wird.');
                items.push(httpPostHTTPSTATUS_STORAGE_KEYCompletion);
                const httpPostSAVE_HEADERSCompletion = new vscode.CompletionItem('SAVE_HEADERS');
                httpPostSAVE_HEADERSCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostSAVE_HEADERSCompletion.insertText = new vscode.SnippetString("SAVE_HEADERS = \"${1}\"");
                httpPostSAVE_HEADERSCompletion.documentation = new vscode.MarkdownString('Speichert die Header der Response in den Storage (httpheaders_<headername>)');
                items.push(httpPostSAVE_HEADERSCompletion);
                const httpPostTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                httpPostTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpPostTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                httpPostTIMEOUTCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Timeout gesetzt werden');
                items.push(httpPostTIMEOUTCompletion);
            }
            if (/.*\s*httpPut\s*\(.*/.test(linePrefix)) {
                const httpPutURLCompletion = new vscode.CompletionItem('URL');
                httpPutURLCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                httpPutURLCompletion.documentation = new vscode.MarkdownString('URL des Webservices');
                items.push(httpPutURLCompletion);
                const httpPutUSERNAMECompletion = new vscode.CompletionItem('USERNAME');
                httpPutUSERNAMECompletion.kind = vscode.CompletionItemKind.Field;
                httpPutUSERNAMECompletion.insertText = new vscode.SnippetString("USERNAME = \"${1}\"");
                httpPutUSERNAMECompletion.documentation = new vscode.MarkdownString('Username f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpPutUSERNAMECompletion);
                const httpPutPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                httpPutPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                httpPutPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr Webservice Call (BasicAuth)');
                items.push(httpPutPASSWORDCompletion);
                const httpPutBODYCompletion = new vscode.CompletionItem('BODY');
                httpPutBODYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutBODYCompletion.insertText = new vscode.SnippetString("BODY = \"${1}\"");
                httpPutBODYCompletion.documentation = new vscode.MarkdownString('HTTP Body');
                items.push(httpPutBODYCompletion);
                const httpPutCONTENT_TYPECompletion = new vscode.CompletionItem('CONTENT_TYPE');
                httpPutCONTENT_TYPECompletion.kind = vscode.CompletionItemKind.Field;
                httpPutCONTENT_TYPECompletion.insertText = new vscode.SnippetString("CONTENT_TYPE = \"${1}\"");
                httpPutCONTENT_TYPECompletion.documentation = new vscode.MarkdownString('Content Type');
                items.push(httpPutCONTENT_TYPECompletion);
                const httpPutIS_FILE_BODYCompletion = new vscode.CompletionItem('IS_FILE_BODY');
                httpPutIS_FILE_BODYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutIS_FILE_BODYCompletion.insertText = new vscode.SnippetString("IS_FILE_BODY = \"${1}\"");
                httpPutIS_FILE_BODYCompletion.documentation = new vscode.MarkdownString('\'true\' wenn im Parameter Body eine Datei angegeben werden soll.');
                items.push(httpPutIS_FILE_BODYCompletion);
                const httpPutHEADERCompletion = new vscode.CompletionItem('HEADER');
                httpPutHEADERCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutHEADERCompletion.insertText = new vscode.SnippetString("HEADER = \"${1}\"");
                httpPutHEADERCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(httpPutHEADERCompletion);
                const httpPutSHORT_OUTPUTCompletion = new vscode.CompletionItem('SHORT_OUTPUT');
                httpPutSHORT_OUTPUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutSHORT_OUTPUTCompletion.insertText = new vscode.SnippetString("SHORT_OUTPUT = \"${1}\"");
                httpPutSHORT_OUTPUTCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(httpPutSHORT_OUTPUTCompletion);
                const httpPutTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                httpPutTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                httpPutTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis des Aufrufs gespeichert wird.');
                items.push(httpPutTARGET_STORAGE_KEYCompletion);
                const httpPutWRITE_TO_FILECompletion = new vscode.CompletionItem('WRITE_TO_FILE');
                httpPutWRITE_TO_FILECompletion.kind = vscode.CompletionItemKind.Field;
                httpPutWRITE_TO_FILECompletion.insertText = new vscode.SnippetString("WRITE_TO_FILE = \"${1}\"");
                httpPutWRITE_TO_FILECompletion.documentation = new vscode.MarkdownString('Ins Verzeichnis schreiben');
                items.push(httpPutWRITE_TO_FILECompletion);
                const httpPutHTTPSTATUS_STORAGE_KEYCompletion = new vscode.CompletionItem('HTTPSTATUS_STORAGE_KEY');
                httpPutHTTPSTATUS_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutHTTPSTATUS_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("HTTPSTATUS_STORAGE_KEY = \"${1}\"");
                httpPutHTTPSTATUS_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem der Status des Aufrufsergebnisses gespeichert wird.');
                items.push(httpPutHTTPSTATUS_STORAGE_KEYCompletion);
                const httpPutSAVE_HEADERSCompletion = new vscode.CompletionItem('SAVE_HEADERS');
                httpPutSAVE_HEADERSCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutSAVE_HEADERSCompletion.insertText = new vscode.SnippetString("SAVE_HEADERS = \"${1}\"");
                httpPutSAVE_HEADERSCompletion.documentation = new vscode.MarkdownString('Speichert die Header der Response in den Storage (httpheaders_<headername>)');
                items.push(httpPutSAVE_HEADERSCompletion);
                const httpPutTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                httpPutTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                httpPutTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                httpPutTIMEOUTCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Timeout gesetzt werden');
                items.push(httpPutTIMEOUTCompletion);
            }
            if (/.*\s*if\s*\(.*/.test(linePrefix)) {
                const ifACCEPTABLE_RESULT_LEVELSCompletion = new vscode.CompletionItem('ACCEPTABLE_RESULT_LEVELS');
                ifACCEPTABLE_RESULT_LEVELSCompletion.kind = vscode.CompletionItemKind.Field;
                ifACCEPTABLE_RESULT_LEVELSCompletion.insertText = new vscode.SnippetString("ACCEPTABLE_RESULT_LEVELS = \"${1}\"");
                ifACCEPTABLE_RESULT_LEVELSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(ifACCEPTABLE_RESULT_LEVELSCompletion);
            }
            if (/.*\s*ifNot\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*inputDialog\s*\(.*/.test(linePrefix)) {
                const inputDialogMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                inputDialogMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                inputDialogMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                inputDialogMESSAGECompletion.documentation = new vscode.MarkdownString('Beschreibung\/Anweisung des Fensters');
                items.push(inputDialogMESSAGECompletion);
                const inputDialogTITLECompletion = new vscode.CompletionItem('TITLE');
                inputDialogTITLECompletion.kind = vscode.CompletionItemKind.Field;
                inputDialogTITLECompletion.insertText = new vscode.SnippetString("TITLE = \"${1}\"");
                inputDialogTITLECompletion.documentation = new vscode.MarkdownString('Title des Dialogfensters');
                items.push(inputDialogTITLECompletion);
                const inputDialogMAX_WAIT_TIMECompletion = new vscode.CompletionItem('MAX_WAIT_TIME');
                inputDialogMAX_WAIT_TIMECompletion.kind = vscode.CompletionItemKind.Field;
                inputDialogMAX_WAIT_TIMECompletion.insertText = new vscode.SnippetString("MAX_WAIT_TIME = \"${1}\"");
                inputDialogMAX_WAIT_TIMECompletion.documentation = new vscode.MarkdownString('Zeit bis das Fenster automatisch geschlossen und die Eingabe \u00FCbernommen wird (in Millisekunden)');
                items.push(inputDialogMAX_WAIT_TIMECompletion);
                const inputDialogDEFAULT_VALUECompletion = new vscode.CompletionItem('DEFAULT_VALUE');
                inputDialogDEFAULT_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                inputDialogDEFAULT_VALUECompletion.insertText = new vscode.SnippetString("DEFAULT_VALUE = \"${1}\"");
                inputDialogDEFAULT_VALUECompletion.documentation = new vscode.MarkdownString('Optionaler voreingegebener Wert');
                items.push(inputDialogDEFAULT_VALUECompletion);
                const inputDialogHIDE_CHARACTERSCompletion = new vscode.CompletionItem('HIDE_CHARACTERS');
                inputDialogHIDE_CHARACTERSCompletion.kind = vscode.CompletionItemKind.Field;
                inputDialogHIDE_CHARACTERSCompletion.insertText = new vscode.SnippetString("HIDE_CHARACTERS = \"${1}\"");
                inputDialogHIDE_CHARACTERSCompletion.documentation = new vscode.MarkdownString('Verdeckte Eingabe z.B. f\u00FCr Passw\u00F6rter aktiviert, wenn auf \'True\' gesetzt');
                items.push(inputDialogHIDE_CHARACTERSCompletion);
                const inputDialogTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                inputDialogTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                inputDialogTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                inputDialogTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem die Eingabe gespeichert wird.');
                items.push(inputDialogTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*lessThanAlpha\s*\(.*/.test(linePrefix)) {
                const lessThanAlphaLEFTCompletion = new vscode.CompletionItem('LEFT');
                lessThanAlphaLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                lessThanAlphaLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                lessThanAlphaLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(lessThanAlphaLEFTCompletion);
                const lessThanAlphaRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                lessThanAlphaRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                lessThanAlphaRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                lessThanAlphaRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(lessThanAlphaRIGHTCompletion);
            }
            if (/.*\s*lessThanDate\s*\(.*/.test(linePrefix)) {
                const lessThanDateLEFTCompletion = new vscode.CompletionItem('LEFT');
                lessThanDateLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                lessThanDateLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                lessThanDateLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(lessThanDateLEFTCompletion);
                const lessThanDateRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                lessThanDateRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                lessThanDateRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                lessThanDateRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(lessThanDateRIGHTCompletion);
            }
            if (/.*\s*lessThanNum\s*\(.*/.test(linePrefix)) {
                const lessThanNumLEFTCompletion = new vscode.CompletionItem('LEFT');
                lessThanNumLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                lessThanNumLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                lessThanNumLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(lessThanNumLEFTCompletion);
                const lessThanNumRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                lessThanNumRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                lessThanNumRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                lessThanNumRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(lessThanNumRIGHTCompletion);
            }
            if (/.*\s*loadCsvSql\s*\(.*/.test(linePrefix)) {
                const loadCsvSqlCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                loadCsvSqlCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                loadCsvSqlCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der bestehenden Datenbankverbindung');
                items.push(loadCsvSqlCONNECTION_NAMECompletion);
                const loadCsvSqlTARGET_TABLECompletion = new vscode.CompletionItem('TARGET_TABLE');
                loadCsvSqlTARGET_TABLECompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlTARGET_TABLECompletion.insertText = new vscode.SnippetString("TARGET_TABLE = \"${1}\"");
                loadCsvSqlTARGET_TABLECompletion.documentation = new vscode.MarkdownString('Name der Tabelle die erstellt werden soll.');
                items.push(loadCsvSqlTARGET_TABLECompletion);
                const loadCsvSqlCSV_FILECompletion = new vscode.CompletionItem('CSV_FILE');
                loadCsvSqlCSV_FILECompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlCSV_FILECompletion.insertText = new vscode.SnippetString("CSV_FILE = \"${1}\"");
                loadCsvSqlCSV_FILECompletion.documentation = new vscode.MarkdownString('Name der CSV Datei');
                items.push(loadCsvSqlCSV_FILECompletion);
                const loadCsvSqlSEPARATORCompletion = new vscode.CompletionItem('SEPARATOR');
                loadCsvSqlSEPARATORCompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlSEPARATORCompletion.insertText = new vscode.SnippetString("SEPARATOR = \"${1}\"");
                loadCsvSqlSEPARATORCompletion.documentation = new vscode.MarkdownString('Festlegen, welches Zeichen als Trennsymbol benutzt werden soll');
                items.push(loadCsvSqlSEPARATORCompletion);
                const loadCsvSqlDATA_TYPESCompletion = new vscode.CompletionItem('DATA_TYPES');
                loadCsvSqlDATA_TYPESCompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlDATA_TYPESCompletion.insertText = new vscode.SnippetString("DATA_TYPES = \"${1}\"");
                loadCsvSqlDATA_TYPESCompletion.documentation = new vscode.MarkdownString('Datentyp');
                items.push(loadCsvSqlDATA_TYPESCompletion);
                const loadCsvSqlHAS_HEADERSCompletion = new vscode.CompletionItem('HAS_HEADERS');
                loadCsvSqlHAS_HEADERSCompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlHAS_HEADERSCompletion.insertText = new vscode.SnippetString("HAS_HEADERS = \"${1}\"");
                loadCsvSqlHAS_HEADERSCompletion.documentation = new vscode.MarkdownString('True falls Kopfzeile vorhanden ist');
                items.push(loadCsvSqlHAS_HEADERSCompletion);
                const loadCsvSqlCREATE_TABLECompletion = new vscode.CompletionItem('CREATE_TABLE');
                loadCsvSqlCREATE_TABLECompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlCREATE_TABLECompletion.insertText = new vscode.SnippetString("CREATE_TABLE = \"${1}\"");
                loadCsvSqlCREATE_TABLECompletion.documentation = new vscode.MarkdownString('True, falls Tabelle erzeugt werden soll.');
                items.push(loadCsvSqlCREATE_TABLECompletion);
                const loadCsvSqlDROP_IF_EXISTSCompletion = new vscode.CompletionItem('DROP_IF_EXISTS');
                loadCsvSqlDROP_IF_EXISTSCompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlDROP_IF_EXISTSCompletion.insertText = new vscode.SnippetString("DROP_IF_EXISTS = \"${1}\"");
                loadCsvSqlDROP_IF_EXISTSCompletion.documentation = new vscode.MarkdownString('True falls, verwerfen falls bereits vorhanden.');
                items.push(loadCsvSqlDROP_IF_EXISTSCompletion);
                const loadCsvSqlENCODINGCompletion = new vscode.CompletionItem('ENCODING');
                loadCsvSqlENCODINGCompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlENCODINGCompletion.insertText = new vscode.SnippetString("ENCODING = \"${1}\"");
                loadCsvSqlENCODINGCompletion.documentation = new vscode.MarkdownString('Encoding der Output-Files (Default: UTF-8)');
                items.push(loadCsvSqlENCODINGCompletion);
                const loadCsvSqlDEFAULT_TEXT_TYPECompletion = new vscode.CompletionItem('DEFAULT_TEXT_TYPE');
                loadCsvSqlDEFAULT_TEXT_TYPECompletion.kind = vscode.CompletionItemKind.Field;
                loadCsvSqlDEFAULT_TEXT_TYPECompletion.insertText = new vscode.SnippetString("DEFAULT_TEXT_TYPE = \"${1}\"");
                loadCsvSqlDEFAULT_TEXT_TYPECompletion.documentation = new vscode.MarkdownString('Standarttext-Typ festlegen');
                items.push(loadCsvSqlDEFAULT_TEXT_TYPECompletion);
            }
            if (/.*\s*logAppendCase\s*\(.*/.test(linePrefix)) {
                const logAppendCaseMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                logAppendCaseMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                logAppendCaseMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                logAppendCaseMESSAGECompletion.documentation = new vscode.MarkdownString('Nachricht, die im Bericht angezeigt werden soll.');
                items.push(logAppendCaseMESSAGECompletion);
            }
            if (/.*\s*logAppendSet\s*\(.*/.test(linePrefix)) {
                const logAppendSetMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                logAppendSetMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                logAppendSetMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                logAppendSetMESSAGECompletion.documentation = new vscode.MarkdownString('Nachricht, die im Bericht angezeigt werden soll.');
                items.push(logAppendSetMESSAGECompletion);
            }
            if (/.*\s*logAppendStep\s*\(.*/.test(linePrefix)) {
                const logAppendStepMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                logAppendStepMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                logAppendStepMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                logAppendStepMESSAGECompletion.documentation = new vscode.MarkdownString('Nachricht, die im Bericht angezeigt werden soll.');
                items.push(logAppendStepMESSAGECompletion);
            }
            if (/.*\s*maximizeWindowWinEle\s*\(.*/.test(linePrefix)) {
                const maximizeWindowWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                maximizeWindowWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                maximizeWindowWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                maximizeWindowWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Names des Fenster, dessen Gr\u00F6\u00DFe maximiert werden soll.');
                items.push(maximizeWindowWinEleWINDOW_NAMECompletion);
                const maximizeWindowWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                maximizeWindowWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                maximizeWindowWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                maximizeWindowWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(maximizeWindowWinElePROCESS_NAMECompletion);
            }
            if (/.*\s*monkeyClick\s*\(.*/.test(linePrefix)) {
                const monkeyClickITERATIONSCompletion = new vscode.CompletionItem('ITERATIONS');
                monkeyClickITERATIONSCompletion.kind = vscode.CompletionItemKind.Field;
                monkeyClickITERATIONSCompletion.insertText = new vscode.SnippetString("ITERATIONS = \"${1}\"");
                monkeyClickITERATIONSCompletion.documentation = new vscode.MarkdownString('Anzahl Klicks');
                items.push(monkeyClickITERATIONSCompletion);
                const monkeyClickWAIT_BETWEENCompletion = new vscode.CompletionItem('WAIT_BETWEEN');
                monkeyClickWAIT_BETWEENCompletion.kind = vscode.CompletionItemKind.Field;
                monkeyClickWAIT_BETWEENCompletion.insertText = new vscode.SnippetString("WAIT_BETWEEN = \"${1}\"");
                monkeyClickWAIT_BETWEENCompletion.documentation = new vscode.MarkdownString('Wartezeit zwischen zwei Klicks.');
                items.push(monkeyClickWAIT_BETWEENCompletion);
            }
            if (/.*\s*mouseMoveToImageInWindowWin\s*\(.*/.test(linePrefix)) {
                const mouseMoveToImageInWindowWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                mouseMoveToImageInWindowWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                mouseMoveToImageInWindowWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                mouseMoveToImageInWindowWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(mouseMoveToImageInWindowWinWINDOW_NAMECompletion);
                const mouseMoveToImageInWindowWinIMAGE_RELATIVE_PATHCompletion = new vscode.CompletionItem('IMAGE_RELATIVE_PATH');
                mouseMoveToImageInWindowWinIMAGE_RELATIVE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                mouseMoveToImageInWindowWinIMAGE_RELATIVE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_RELATIVE_PATH = \"${1}\"");
                mouseMoveToImageInWindowWinIMAGE_RELATIVE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(mouseMoveToImageInWindowWinIMAGE_RELATIVE_PATHCompletion);
                const mouseMoveToImageInWindowWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                mouseMoveToImageInWindowWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                mouseMoveToImageInWindowWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                mouseMoveToImageInWindowWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(mouseMoveToImageInWindowWinBASEDIRCompletion);
                const mouseMoveToImageInWindowWinRELATIVE_XCompletion = new vscode.CompletionItem('RELATIVE_X');
                mouseMoveToImageInWindowWinRELATIVE_XCompletion.kind = vscode.CompletionItemKind.Field;
                mouseMoveToImageInWindowWinRELATIVE_XCompletion.insertText = new vscode.SnippetString("RELATIVE_X = \"${1}\"");
                mouseMoveToImageInWindowWinRELATIVE_XCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der X-Achse. Links: Negativ. Rechts: Positiv');
                items.push(mouseMoveToImageInWindowWinRELATIVE_XCompletion);
                const mouseMoveToImageInWindowWinRELATIVE_YCompletion = new vscode.CompletionItem('RELATIVE_Y');
                mouseMoveToImageInWindowWinRELATIVE_YCompletion.kind = vscode.CompletionItemKind.Field;
                mouseMoveToImageInWindowWinRELATIVE_YCompletion.insertText = new vscode.SnippetString("RELATIVE_Y = \"${1}\"");
                mouseMoveToImageInWindowWinRELATIVE_YCompletion.documentation = new vscode.MarkdownString('Verschiebung auf der Y-Achse. Oben: Negativ. Unten: Positiv');
                items.push(mouseMoveToImageInWindowWinRELATIVE_YCompletion);
            }
            if (/.*\s*moveFile\s*\(.*/.test(linePrefix)) {
                const moveFileFILENAME_FROMCompletion = new vscode.CompletionItem('FILENAME_FROM');
                moveFileFILENAME_FROMCompletion.kind = vscode.CompletionItemKind.Field;
                moveFileFILENAME_FROMCompletion.insertText = new vscode.SnippetString("FILENAME_FROM = \"${1}\"");
                moveFileFILENAME_FROMCompletion.documentation = new vscode.MarkdownString('Quelle');
                items.push(moveFileFILENAME_FROMCompletion);
                const moveFileFILENAME_TOCompletion = new vscode.CompletionItem('FILENAME_TO');
                moveFileFILENAME_TOCompletion.kind = vscode.CompletionItemKind.Field;
                moveFileFILENAME_TOCompletion.insertText = new vscode.SnippetString("FILENAME_TO = \"${1}\"");
                moveFileFILENAME_TOCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(moveFileFILENAME_TOCompletion);
                const moveFileMUST_DELETECompletion = new vscode.CompletionItem('MUST_DELETE');
                moveFileMUST_DELETECompletion.kind = vscode.CompletionItemKind.Field;
                moveFileMUST_DELETECompletion.insertText = new vscode.SnippetString("MUST_DELETE = \"${1}\"");
                moveFileMUST_DELETECompletion.documentation = new vscode.MarkdownString('Muss etwas gel\u00F6scht werden? {true, false} Default: true');
                items.push(moveFileMUST_DELETECompletion);
                const moveFileOLDER_THAN_DAYSCompletion = new vscode.CompletionItem('OLDER_THAN_DAYS');
                moveFileOLDER_THAN_DAYSCompletion.kind = vscode.CompletionItemKind.Field;
                moveFileOLDER_THAN_DAYSCompletion.insertText = new vscode.SnippetString("OLDER_THAN_DAYS = \"${1}\"");
                moveFileOLDER_THAN_DAYSCompletion.documentation = new vscode.MarkdownString('Alle Dateien in einem Verzeichnis (angegeben \u00FCber den FILENAME) verschieben die \u00E4lter als die angegebene Zahl Tage sind.');
                items.push(moveFileOLDER_THAN_DAYSCompletion);
            }
            if (/.*\s*moveFilesOlderThan\s*\(.*/.test(linePrefix)) {
                const moveFilesOlderThanFILENAME_FROMCompletion = new vscode.CompletionItem('FILENAME_FROM');
                moveFilesOlderThanFILENAME_FROMCompletion.kind = vscode.CompletionItemKind.Field;
                moveFilesOlderThanFILENAME_FROMCompletion.insertText = new vscode.SnippetString("FILENAME_FROM = \"${1}\"");
                moveFilesOlderThanFILENAME_FROMCompletion.documentation = new vscode.MarkdownString('Quelle');
                items.push(moveFilesOlderThanFILENAME_FROMCompletion);
                const moveFilesOlderThanFILENAME_TOCompletion = new vscode.CompletionItem('FILENAME_TO');
                moveFilesOlderThanFILENAME_TOCompletion.kind = vscode.CompletionItemKind.Field;
                moveFilesOlderThanFILENAME_TOCompletion.insertText = new vscode.SnippetString("FILENAME_TO = \"${1}\"");
                moveFilesOlderThanFILENAME_TOCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(moveFilesOlderThanFILENAME_TOCompletion);
                const moveFilesOlderThanMUST_DELETECompletion = new vscode.CompletionItem('MUST_DELETE');
                moveFilesOlderThanMUST_DELETECompletion.kind = vscode.CompletionItemKind.Field;
                moveFilesOlderThanMUST_DELETECompletion.insertText = new vscode.SnippetString("MUST_DELETE = \"${1}\"");
                moveFilesOlderThanMUST_DELETECompletion.documentation = new vscode.MarkdownString('Muss etwas gel\u00F6scht werden? {true, false} Default: true');
                items.push(moveFilesOlderThanMUST_DELETECompletion);
                const moveFilesOlderThanOLDER_THAN_DAYSCompletion = new vscode.CompletionItem('OLDER_THAN_DAYS');
                moveFilesOlderThanOLDER_THAN_DAYSCompletion.kind = vscode.CompletionItemKind.Field;
                moveFilesOlderThanOLDER_THAN_DAYSCompletion.insertText = new vscode.SnippetString("OLDER_THAN_DAYS = \"${1}\"");
                moveFilesOlderThanOLDER_THAN_DAYSCompletion.documentation = new vscode.MarkdownString('Alle Dateien in einem Verzeichnis (angegeben \u00FCber den FILENAME) verschieben die \u00E4lter als die angegebene Zahl Tage sind.');
                items.push(moveFilesOlderThanOLDER_THAN_DAYSCompletion);
            }
            if (/.*\s*moveMouseWin\s*\(.*/.test(linePrefix)) {
                const moveMouseWinWINDOWCompletion = new vscode.CompletionItem('WINDOW');
                moveMouseWinWINDOWCompletion.kind = vscode.CompletionItemKind.Field;
                moveMouseWinWINDOWCompletion.insertText = new vscode.SnippetString("WINDOW = \"${1}\"");
                moveMouseWinWINDOWCompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(moveMouseWinWINDOWCompletion);
                const moveMouseWinMOVE_TO_XCompletion = new vscode.CompletionItem('MOVE_TO_X');
                moveMouseWinMOVE_TO_XCompletion.kind = vscode.CompletionItemKind.Field;
                moveMouseWinMOVE_TO_XCompletion.insertText = new vscode.SnippetString("MOVE_TO_X = \"${1}\"");
                moveMouseWinMOVE_TO_XCompletion.documentation = new vscode.MarkdownString('X-Koordinate.');
                items.push(moveMouseWinMOVE_TO_XCompletion);
                const moveMouseWinMOVE_TO_YCompletion = new vscode.CompletionItem('MOVE_TO_Y');
                moveMouseWinMOVE_TO_YCompletion.kind = vscode.CompletionItemKind.Field;
                moveMouseWinMOVE_TO_YCompletion.insertText = new vscode.SnippetString("MOVE_TO_Y = \"${1}\"");
                moveMouseWinMOVE_TO_YCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(moveMouseWinMOVE_TO_YCompletion);
            }
            if (/.*\s*moveToWeb\s*\(.*/.test(linePrefix)) {
                const moveToWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                moveToWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                moveToWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                moveToWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(moveToWebBY_CRITERIACompletion);
                const moveToWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                moveToWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                moveToWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                moveToWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(moveToWebELEMENT_NAMECompletion);
                const moveToWebWITH_OFFSETCompletion = new vscode.CompletionItem('WITH_OFFSET');
                moveToWebWITH_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                moveToWebWITH_OFFSETCompletion.insertText = new vscode.SnippetString("WITH_OFFSET = \"${1}\"");
                moveToWebWITH_OFFSETCompletion.documentation = new vscode.MarkdownString('Muss auf \'true\' gesetzt werden, wenn ein Offset benutzt werden soll');
                items.push(moveToWebWITH_OFFSETCompletion);
                const moveToWebEND_OFFSET_XCompletion = new vscode.CompletionItem('END_OFFSET_X');
                moveToWebEND_OFFSET_XCompletion.kind = vscode.CompletionItemKind.Field;
                moveToWebEND_OFFSET_XCompletion.insertText = new vscode.SnippetString("END_OFFSET_X = \"${1}\"");
                moveToWebEND_OFFSET_XCompletion.documentation = new vscode.MarkdownString('Gibt den Offset zum ausgew\u00E4hlten Element in vertikale Richtung an');
                items.push(moveToWebEND_OFFSET_XCompletion);
                const moveToWebEND_OFFSET_YCompletion = new vscode.CompletionItem('END_OFFSET_Y');
                moveToWebEND_OFFSET_YCompletion.kind = vscode.CompletionItemKind.Field;
                moveToWebEND_OFFSET_YCompletion.insertText = new vscode.SnippetString("END_OFFSET_Y = \"${1}\"");
                moveToWebEND_OFFSET_YCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(moveToWebEND_OFFSET_YCompletion);
            }
            if (/.*\s*navigateMobile\s*\(.*/.test(linePrefix)) {
                const navigateMobileURLCompletion = new vscode.CompletionItem('URL');
                navigateMobileURLCompletion.kind = vscode.CompletionItemKind.Field;
                navigateMobileURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                navigateMobileURLCompletion.documentation = new vscode.MarkdownString('Der Parameter muss mit der URL der Webseite belegt werden, zu der navigiert werden soll.');
                items.push(navigateMobileURLCompletion);
                const navigateMobileDIRECTIONCompletion = new vscode.CompletionItem('DIRECTION');
                navigateMobileDIRECTIONCompletion.kind = vscode.CompletionItemKind.Field;
                navigateMobileDIRECTIONCompletion.insertText = new vscode.SnippetString("DIRECTION = \"${1}\"");
                navigateMobileDIRECTIONCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit den Werten \'BACK\' oder \'FORWARD\' belegt werden.');
                items.push(navigateMobileDIRECTIONCompletion);
            }
            if (/.*\s*navigateWeb\s*\(.*/.test(linePrefix)) {
                const navigateWebEXPECTED_WEBSITE_TITLECompletion = new vscode.CompletionItem('EXPECTED_WEBSITE_TITLE');
                navigateWebEXPECTED_WEBSITE_TITLECompletion.kind = vscode.CompletionItemKind.Field;
                navigateWebEXPECTED_WEBSITE_TITLECompletion.insertText = new vscode.SnippetString("EXPECTED_WEBSITE_TITLE = \"${1}\"");
                navigateWebEXPECTED_WEBSITE_TITLECompletion.documentation = new vscode.MarkdownString('Erwarteter Seiten-Titel.');
                items.push(navigateWebEXPECTED_WEBSITE_TITLECompletion);
                const navigateWebURLCompletion = new vscode.CompletionItem('URL');
                navigateWebURLCompletion.kind = vscode.CompletionItemKind.Field;
                navigateWebURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                navigateWebURLCompletion.documentation = new vscode.MarkdownString('Zu \u00F6ffnende URL (http:\/\/www...).');
                items.push(navigateWebURLCompletion);
            }
            if (/.*\s*networkAndroid\s*\(.*/.test(linePrefix)) {
                const networkAndroidWIFICompletion = new vscode.CompletionItem('WIFI');
                networkAndroidWIFICompletion.kind = vscode.CompletionItemKind.Field;
                networkAndroidWIFICompletion.insertText = new vscode.SnippetString("WIFI = \"${1}\"");
                networkAndroidWIFICompletion.documentation = new vscode.MarkdownString('Wird der Parameter mit \'on\' belegt, wird das WIFI eingeschaltet, wird er mit \'off\' belegt, wird es ausgeschaltet.');
                items.push(networkAndroidWIFICompletion);
                const networkAndroidDATACompletion = new vscode.CompletionItem('DATA');
                networkAndroidDATACompletion.kind = vscode.CompletionItemKind.Field;
                networkAndroidDATACompletion.insertText = new vscode.SnippetString("DATA = \"${1}\"");
                networkAndroidDATACompletion.documentation = new vscode.MarkdownString('Wird der Parameter mit \'on\' belegt, wird die mobile Datennutzung eingeschaltet, wird er mit \'off\' belegt, wird sie ausgeschaltet.');
                items.push(networkAndroidDATACompletion);
                const networkAndroidAIRPLANECompletion = new vscode.CompletionItem('AIRPLANE');
                networkAndroidAIRPLANECompletion.kind = vscode.CompletionItemKind.Field;
                networkAndroidAIRPLANECompletion.insertText = new vscode.SnippetString("AIRPLANE = \"${1}\"");
                networkAndroidAIRPLANECompletion.documentation = new vscode.MarkdownString('Wird der Parameter mit \'on\' belegt, wird der Flugzeugmodus eingeschaltet, wird er mit \'off\' belegt, wird er ausgeschaltet.');
                items.push(networkAndroidAIRPLANECompletion);
            }
            if (/.*\s*not\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*notEmpty\s*\(.*/.test(linePrefix)) {
                const notEmptyVALUECompletion = new vscode.CompletionItem('VALUE');
                notEmptyVALUECompletion.kind = vscode.CompletionItemKind.Field;
                notEmptyVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                notEmptyVALUECompletion.documentation = new vscode.MarkdownString('Zu \u00FCberpr\u00FCfender Parameter');
                items.push(notEmptyVALUECompletion);
            }
            if (/.*\s*notEqualsAlpha\s*\(.*/.test(linePrefix)) {
                const notEqualsAlphaLEFTCompletion = new vscode.CompletionItem('LEFT');
                notEqualsAlphaLEFTCompletion.kind = vscode.CompletionItemKind.Field;
                notEqualsAlphaLEFTCompletion.insertText = new vscode.SnippetString("LEFT = \"${1}\"");
                notEqualsAlphaLEFTCompletion.documentation = new vscode.MarkdownString('Parameter, der links vom Vergleichs-Operator stehen soll.');
                items.push(notEqualsAlphaLEFTCompletion);
                const notEqualsAlphaRIGHTCompletion = new vscode.CompletionItem('RIGHT');
                notEqualsAlphaRIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                notEqualsAlphaRIGHTCompletion.insertText = new vscode.SnippetString("RIGHT = \"${1}\"");
                notEqualsAlphaRIGHTCompletion.documentation = new vscode.MarkdownString('Parameter, der rechts vom Vergleichs-Operator stehen soll.');
                items.push(notEqualsAlphaRIGHTCompletion);
            }
            if (/.*\s*openNotificationAndroid\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*openSql\s*\(.*/.test(linePrefix)) {
                const openSqlCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                openSqlCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                openSqlCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                openSqlCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der zu er\u00F6ffenden Datenbankverbindung');
                items.push(openSqlCONNECTION_NAMECompletion);
                const openSqlJDBC_URLCompletion = new vscode.CompletionItem('JDBC_URL');
                openSqlJDBC_URLCompletion.kind = vscode.CompletionItemKind.Field;
                openSqlJDBC_URLCompletion.insertText = new vscode.SnippetString("JDBC_URL = \"${1}\"");
                openSqlJDBC_URLCompletion.documentation = new vscode.MarkdownString('JDBC-URL zur Verbindung mit der Datenbank. Z. B. jdbc:mysql:\/\/localhost\/Test.');
                items.push(openSqlJDBC_URLCompletion);
                const openSqlDB_USERNAMECompletion = new vscode.CompletionItem('DB_USERNAME');
                openSqlDB_USERNAMECompletion.kind = vscode.CompletionItemKind.Field;
                openSqlDB_USERNAMECompletion.insertText = new vscode.SnippetString("DB_USERNAME = \"${1}\"");
                openSqlDB_USERNAMECompletion.documentation = new vscode.MarkdownString('Name des DB-Users');
                items.push(openSqlDB_USERNAMECompletion);
                const openSqlDB_PASSWORDCompletion = new vscode.CompletionItem('DB_PASSWORD');
                openSqlDB_PASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                openSqlDB_PASSWORDCompletion.insertText = new vscode.SnippetString("DB_PASSWORD = \"${1}\"");
                openSqlDB_PASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort des DB-Users');
                items.push(openSqlDB_PASSWORDCompletion);
                const openSqlJDBC_DRIVERCompletion = new vscode.CompletionItem('JDBC_DRIVER');
                openSqlJDBC_DRIVERCompletion.kind = vscode.CompletionItemKind.Field;
                openSqlJDBC_DRIVERCompletion.insertText = new vscode.SnippetString("JDBC_DRIVER = \"${1}\"");
                openSqlJDBC_DRIVERCompletion.documentation = new vscode.MarkdownString('Falls angegeben, wird der gegebene JDBC driver (z. B. com.mysql.jdbc.Driver) geladen. Sonst wird der Autoload-Mechanismus von JDBC 4.0 genutzt.');
                items.push(openSqlJDBC_DRIVERCompletion);
            }
            if (/.*\s*pasteTextCP\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*pickNumericalFromPickerRoll\s*\(.*/.test(linePrefix)) {
                const pickNumericalFromPickerRollELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                pickNumericalFromPickerRollELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                pickNumericalFromPickerRollELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                pickNumericalFromPickerRollELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements als XPATH.');
                items.push(pickNumericalFromPickerRollELEMENT_NAMECompletion);
                const pickNumericalFromPickerRollDIRECTION_GREATERCompletion = new vscode.CompletionItem('DIRECTION_GREATER');
                pickNumericalFromPickerRollDIRECTION_GREATERCompletion.kind = vscode.CompletionItemKind.Field;
                pickNumericalFromPickerRollDIRECTION_GREATERCompletion.insertText = new vscode.SnippetString("DIRECTION_GREATER = \"${1}\"");
                pickNumericalFromPickerRollDIRECTION_GREATERCompletion.documentation = new vscode.MarkdownString('Richtung, in der die Werte gr\u00F6\u00DFer werden. Default ist \'down\'. Up ist die zweite Alternative.');
                items.push(pickNumericalFromPickerRollDIRECTION_GREATERCompletion);
                const pickNumericalFromPickerRollTARGET_VALUECompletion = new vscode.CompletionItem('TARGET_VALUE');
                pickNumericalFromPickerRollTARGET_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                pickNumericalFromPickerRollTARGET_VALUECompletion.insertText = new vscode.SnippetString("TARGET_VALUE = \"${1}\"");
                pickNumericalFromPickerRollTARGET_VALUECompletion.documentation = new vscode.MarkdownString('Zielwert, der erreicht werden soll.');
                items.push(pickNumericalFromPickerRollTARGET_VALUECompletion);
            }
            if (/.*\s*pinchMobile\s*\(.*/.test(linePrefix)) {
                const pinchMobileX_POSITIONCompletion = new vscode.CompletionItem('X_POSITION');
                pinchMobileX_POSITIONCompletion.kind = vscode.CompletionItemKind.Field;
                pinchMobileX_POSITIONCompletion.insertText = new vscode.SnippetString("X_POSITION = \"${1}\"");
                pinchMobileX_POSITIONCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt die X-Koordinate des Punktes in Pixeln an, an dem die Pinch-Geste durchgef\u00FChrt werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(pinchMobileX_POSITIONCompletion);
                const pinchMobileY_POSITIONCompletion = new vscode.CompletionItem('Y_POSITION');
                pinchMobileY_POSITIONCompletion.kind = vscode.CompletionItemKind.Field;
                pinchMobileY_POSITIONCompletion.insertText = new vscode.SnippetString("Y_POSITION = \"${1}\"");
                pinchMobileY_POSITIONCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt die Y-Koordinate des Punktes in Pixeln an, an dem die Pinch-Geste durchgef\u00FChrt werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(pinchMobileY_POSITIONCompletion);
            }
            if (/.*\s*queryJson\s*\(.*/.test(linePrefix)) {
                const queryJsonJSONTEXTCompletion = new vscode.CompletionItem('JSONTEXT');
                queryJsonJSONTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                queryJsonJSONTEXTCompletion.insertText = new vscode.SnippetString("JSONTEXT = \"${1}\"");
                queryJsonJSONTEXTCompletion.documentation = new vscode.MarkdownString('Zu durchsuchender Text im JSON Format');
                items.push(queryJsonJSONTEXTCompletion);
                const queryJsonQUERYCompletion = new vscode.CompletionItem('QUERY');
                queryJsonQUERYCompletion.kind = vscode.CompletionItemKind.Field;
                queryJsonQUERYCompletion.insertText = new vscode.SnippetString("QUERY = \"${1}\"");
                queryJsonQUERYCompletion.documentation = new vscode.MarkdownString('JsonPath-Query auf den JSONTEXT');
                items.push(queryJsonQUERYCompletion);
                const queryJsonTARGET_FILECompletion = new vscode.CompletionItem('TARGET_FILE');
                queryJsonTARGET_FILECompletion.kind = vscode.CompletionItemKind.Field;
                queryJsonTARGET_FILECompletion.insertText = new vscode.SnippetString("TARGET_FILE = \"${1}\"");
                queryJsonTARGET_FILECompletion.documentation = new vscode.MarkdownString('Dateipfad f\u00FCr csv Datei, in die das Ergebnis geschrieben werden soll.');
                items.push(queryJsonTARGET_FILECompletion);
                const queryJsonVALUE_DELIMITERCompletion = new vscode.CompletionItem('VALUE_DELIMITER');
                queryJsonVALUE_DELIMITERCompletion.kind = vscode.CompletionItemKind.Field;
                queryJsonVALUE_DELIMITERCompletion.insertText = new vscode.SnippetString("VALUE_DELIMITER = \"${1}\"");
                queryJsonVALUE_DELIMITERCompletion.documentation = new vscode.MarkdownString('Festlegen des Trennzeichen zwischn zwei Elementen.');
                items.push(queryJsonVALUE_DELIMITERCompletion);
                const queryJsonTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                queryJsonTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                queryJsonTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                queryJsonTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Element-Text geschrieben werden soll.');
                items.push(queryJsonTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*querySql\s*\(.*/.test(linePrefix)) {
                const querySqlCONNECTION_NAMECompletion = new vscode.CompletionItem('CONNECTION_NAME');
                querySqlCONNECTION_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                querySqlCONNECTION_NAMECompletion.insertText = new vscode.SnippetString("CONNECTION_NAME = \"${1}\"");
                querySqlCONNECTION_NAMECompletion.documentation = new vscode.MarkdownString('Name der bestehenden Datenbankverbindung');
                items.push(querySqlCONNECTION_NAMECompletion);
                const querySqlSQL_STATEMENT_OR_FILECompletion = new vscode.CompletionItem('SQL_STATEMENT_OR_FILE');
                querySqlSQL_STATEMENT_OR_FILECompletion.kind = vscode.CompletionItemKind.Field;
                querySqlSQL_STATEMENT_OR_FILECompletion.insertText = new vscode.SnippetString("SQL_STATEMENT_OR_FILE = \"${1}\"");
                querySqlSQL_STATEMENT_OR_FILECompletion.documentation = new vscode.MarkdownString('1) Absoluter, vollst\u00E4ndig qualifizierter Dateiname (sollte als Separator immer \'\/\' verwenden) einer Datei, die ein oder mehrere auszuf\u00FChrende SQL-Statements enth\u00E4lt (Dateiendung muss .sql sein). Beispiel: C:\/sql\/commands.sql        2) Ein oder mehrere SQL-Statements. Mehrere SQL-statements sind durch \';\' zu trennen (wird nur eins vorgegeben, ist dies optional).');
                items.push(querySqlSQL_STATEMENT_OR_FILECompletion);
                const querySqlTARGET_FILECompletion = new vscode.CompletionItem('TARGET_FILE');
                querySqlTARGET_FILECompletion.kind = vscode.CompletionItemKind.Field;
                querySqlTARGET_FILECompletion.insertText = new vscode.SnippetString("TARGET_FILE = \"${1}\"");
                querySqlTARGET_FILECompletion.documentation = new vscode.MarkdownString('Pfad zur CSV Datei, in welche das Ergebnis geschrieben wird.');
                items.push(querySqlTARGET_FILECompletion);
                const querySqlVALUE_DELIMITERCompletion = new vscode.CompletionItem('VALUE_DELIMITER');
                querySqlVALUE_DELIMITERCompletion.kind = vscode.CompletionItemKind.Field;
                querySqlVALUE_DELIMITERCompletion.insertText = new vscode.SnippetString("VALUE_DELIMITER = \"${1}\"");
                querySqlVALUE_DELIMITERCompletion.documentation = new vscode.MarkdownString('Festlegen des Trennzeichen zwischen zwei Elementen.');
                items.push(querySqlVALUE_DELIMITERCompletion);
                const querySqlWRITE_ENCODINGCompletion = new vscode.CompletionItem('WRITE_ENCODING');
                querySqlWRITE_ENCODINGCompletion.kind = vscode.CompletionItemKind.Field;
                querySqlWRITE_ENCODINGCompletion.insertText = new vscode.SnippetString("WRITE_ENCODING = \"${1}\"");
                querySqlWRITE_ENCODINGCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(querySqlWRITE_ENCODINGCompletion);
                const querySqlREAD_ENCODINGCompletion = new vscode.CompletionItem('READ_ENCODING');
                querySqlREAD_ENCODINGCompletion.kind = vscode.CompletionItemKind.Field;
                querySqlREAD_ENCODINGCompletion.insertText = new vscode.SnippetString("READ_ENCODING = \"${1}\"");
                querySqlREAD_ENCODINGCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(querySqlREAD_ENCODINGCompletion);
                const querySqlTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                querySqlTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                querySqlTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                querySqlTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Falls angegeben, wird das Resultat in der durch diesen Schl\u00FCssel identifizierten Laufzeitvariable gespeichert (durch Hinzuf\u00FCgen oder Ersetzen). Das Resultat wird dabei im Format eines JSON-Array gespeichert, wobei jede zur\u00FCckgegebene Zeile einem Eintrag des JSON-Arrays entspricht. F\u00FCr den Sonderfall, das nur ein einzelner Wert aus einer einzelnen Zeile abgefragt wird, kann es notwendig sein, diesen vor der weiteren Verwendung zu parsen (z.B. wird anstelle des gesamten Ergebnisses [{\'ID\':123}] nur der Wert 123 ben\u00F6tigt. Dazu ist das Kommando changeStorageValue mit der Option extractSingleSqlResultFromJson zu verwenden.');
                items.push(querySqlTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*queryXML\s*\(.*/.test(linePrefix)) {
                const queryXMLXMLTEXTCompletion = new vscode.CompletionItem('XMLTEXT');
                queryXMLXMLTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                queryXMLXMLTEXTCompletion.insertText = new vscode.SnippetString("XMLTEXT = \"${1}\"");
                queryXMLXMLTEXTCompletion.documentation = new vscode.MarkdownString('Pfad oder String im XML Format');
                items.push(queryXMLXMLTEXTCompletion);
                const queryXMLEXPRESSIONCompletion = new vscode.CompletionItem('EXPRESSION');
                queryXMLEXPRESSIONCompletion.kind = vscode.CompletionItemKind.Field;
                queryXMLEXPRESSIONCompletion.insertText = new vscode.SnippetString("EXPRESSION = \"${1}\"");
                queryXMLEXPRESSIONCompletion.documentation = new vscode.MarkdownString('XPath Expression');
                items.push(queryXMLEXPRESSIONCompletion);
                const queryXMLIS_FILECompletion = new vscode.CompletionItem('IS_FILE');
                queryXMLIS_FILECompletion.kind = vscode.CompletionItemKind.Field;
                queryXMLIS_FILECompletion.insertText = new vscode.SnippetString("IS_FILE = \"${1}\"");
                queryXMLIS_FILECompletion.documentation = new vscode.MarkdownString('True, falls es sich um eine lokale Datei handelt');
                items.push(queryXMLIS_FILECompletion);
                const queryXMLTARGET_FILECompletion = new vscode.CompletionItem('TARGET_FILE');
                queryXMLTARGET_FILECompletion.kind = vscode.CompletionItemKind.Field;
                queryXMLTARGET_FILECompletion.insertText = new vscode.SnippetString("TARGET_FILE = \"${1}\"");
                queryXMLTARGET_FILECompletion.documentation = new vscode.MarkdownString('Pfad der CSV Datei, in die das Abfrage-Ergebnis geschrieben wird.');
                items.push(queryXMLTARGET_FILECompletion);
                const queryXMLWRITE_AS_XMLCompletion = new vscode.CompletionItem('WRITE_AS_XML');
                queryXMLWRITE_AS_XMLCompletion.kind = vscode.CompletionItemKind.Field;
                queryXMLWRITE_AS_XMLCompletion.insertText = new vscode.SnippetString("WRITE_AS_XML = \"${1}\"");
                queryXMLWRITE_AS_XMLCompletion.documentation = new vscode.MarkdownString('Falls true, wird das Query Result in den Target Storage als XML geschrieben');
                items.push(queryXMLWRITE_AS_XMLCompletion);
                const queryXMLTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                queryXMLTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                queryXMLTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                queryXMLTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel der Storage-Variable, in die das Abfrage-Ergebnis geschrieben wird.');
                items.push(queryXMLTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*readFileToStorage\s*\(.*/.test(linePrefix)) {
                const readFileToStorageFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                readFileToStorageFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                readFileToStorageFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                readFileToStorageFILENAMECompletion.documentation = new vscode.MarkdownString('Dateiname der einzulesenden Datei');
                items.push(readFileToStorageFILENAMECompletion);
                const readFileToStorageENCODING_TEXTCompletion = new vscode.CompletionItem('ENCODING_TEXT');
                readFileToStorageENCODING_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                readFileToStorageENCODING_TEXTCompletion.insertText = new vscode.SnippetString("ENCODING_TEXT = \"${1}\"");
                readFileToStorageENCODING_TEXTCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(readFileToStorageENCODING_TEXTCompletion);
                const readFileToStorageTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                readFileToStorageTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                readFileToStorageTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                readFileToStorageTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Element-Text geschrieben werden soll.');
                items.push(readFileToStorageTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*readTextInPicture\s*\(.*/.test(linePrefix)) {
                const readTextInPictureFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                readTextInPictureFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                readTextInPictureFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                readTextInPictureFILENAMECompletion.documentation = new vscode.MarkdownString('Name der Bilddatei, die untersucht werden soll. Wenn keine Bilddatei angegeben wird, wird der Zwischenspeicher nach Bilddaten durchsucht. Ist auch hier kein Bild vorhanden, wird ein Screenshot erstellt.');
                items.push(readTextInPictureFILENAMECompletion);
                const readTextInPictureBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                readTextInPictureBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                readTextInPictureBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                readTextInPictureBASEDIRCompletion.documentation = new vscode.MarkdownString('Gibt das Basisverzeichnis an.');
                items.push(readTextInPictureBASEDIRCompletion);
                const readTextInPictureX1Completion = new vscode.CompletionItem('X1');
                readTextInPictureX1Completion.kind = vscode.CompletionItemKind.Field;
                readTextInPictureX1Completion.insertText = new vscode.SnippetString("X1 = \"${1}\"");
                readTextInPictureX1Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: X-Koordinate der linken oberen Ecke.');
                items.push(readTextInPictureX1Completion);
                const readTextInPictureY1Completion = new vscode.CompletionItem('Y1');
                readTextInPictureY1Completion.kind = vscode.CompletionItemKind.Field;
                readTextInPictureY1Completion.insertText = new vscode.SnippetString("Y1 = \"${1}\"");
                readTextInPictureY1Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: Y-Koordinate der linken oberen Ecke.');
                items.push(readTextInPictureY1Completion);
                const readTextInPictureX2Completion = new vscode.CompletionItem('X2');
                readTextInPictureX2Completion.kind = vscode.CompletionItemKind.Field;
                readTextInPictureX2Completion.insertText = new vscode.SnippetString("X2 = \"${1}\"");
                readTextInPictureX2Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: X-Koordinate der rechten unteren Ecke.');
                items.push(readTextInPictureX2Completion);
                const readTextInPictureY2Completion = new vscode.CompletionItem('Y2');
                readTextInPictureY2Completion.kind = vscode.CompletionItemKind.Field;
                readTextInPictureY2Completion.insertText = new vscode.SnippetString("Y2 = \"${1}\"");
                readTextInPictureY2Completion.documentation = new vscode.MarkdownString('Wenn nur ein Bildschnitt untersucht werden soll: Y-Koordinate der rechten unteren Ecke.');
                items.push(readTextInPictureY2Completion);
                const readTextInPictureTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                readTextInPictureTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                readTextInPictureTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                readTextInPictureTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel unter dem die gefundenen Worte, getrennt durch Leerzeichen, in der Storage-Datei abgelegt werden.');
                items.push(readTextInPictureTARGET_STORAGE_KEYCompletion);
                const readTextInPictureOCR_IMPLEMENTATIONCompletion = new vscode.CompletionItem('OCR_IMPLEMENTATION');
                readTextInPictureOCR_IMPLEMENTATIONCompletion.kind = vscode.CompletionItemKind.Field;
                readTextInPictureOCR_IMPLEMENTATIONCompletion.insertText = new vscode.SnippetString("OCR_IMPLEMENTATION = \"${1}\"");
                readTextInPictureOCR_IMPLEMENTATIONCompletion.documentation = new vscode.MarkdownString('Wahl der verwendeten OCR Implementierung. GCP oder TESSERACT.');
                items.push(readTextInPictureOCR_IMPLEMENTATIONCompletion);
            }
            if (/.*\s*receiveMail\s*\(.*/.test(linePrefix)) {
                const receiveMailSERVERCompletion = new vscode.CompletionItem('SERVER');
                receiveMailSERVERCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailSERVERCompletion.insertText = new vscode.SnippetString("SERVER = \"${1}\"");
                receiveMailSERVERCompletion.documentation = new vscode.MarkdownString('Servername des Mailanbieters.');
                items.push(receiveMailSERVERCompletion);
                const receiveMailUSERCompletion = new vscode.CompletionItem('USER');
                receiveMailUSERCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                receiveMailUSERCompletion.documentation = new vscode.MarkdownString('Benutzername f\u00FCr das Mailkonto');
                items.push(receiveMailUSERCompletion);
                const receiveMailPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                receiveMailPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                receiveMailPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr das Mailkonto');
                items.push(receiveMailPASSWORDCompletion);
                const receiveMailFOLDERCompletion = new vscode.CompletionItem('FOLDER');
                receiveMailFOLDERCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailFOLDERCompletion.insertText = new vscode.SnippetString("FOLDER = \"${1}\"");
                receiveMailFOLDERCompletion.documentation = new vscode.MarkdownString('Name des Ordners auf dem E-Mail-Server, auf den zugegriffen werden soll.');
                items.push(receiveMailFOLDERCompletion);
                const receiveMailSUBJECTCompletion = new vscode.CompletionItem('SUBJECT');
                receiveMailSUBJECTCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailSUBJECTCompletion.insertText = new vscode.SnippetString("SUBJECT = \"${1}\"");
                receiveMailSUBJECTCompletion.documentation = new vscode.MarkdownString('Betreff der empfangenden E-Mail.');
                items.push(receiveMailSUBJECTCompletion);
                const receiveMailSEARCHCompletion = new vscode.CompletionItem('SEARCH');
                receiveMailSEARCHCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailSEARCHCompletion.insertText = new vscode.SnippetString("SEARCH = \"${1}\"");
                receiveMailSEARCHCompletion.documentation = new vscode.MarkdownString('Regul\u00E4rer Ausdruck, nach dem gesucht werden soll.');
                items.push(receiveMailSEARCHCompletion);
                const receiveMailLOCATIONCompletion = new vscode.CompletionItem('LOCATION');
                receiveMailLOCATIONCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailLOCATIONCompletion.insertText = new vscode.SnippetString("LOCATION = \"${1}\"");
                receiveMailLOCATIONCompletion.documentation = new vscode.MarkdownString('Ort der Suche. M\u00F6glich sind \'body\' oder \'subject\'.');
                items.push(receiveMailLOCATIONCompletion);
                const receiveMailTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                receiveMailTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                receiveMailTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Name der Laufzeitvariablen, in der das Resultat des regul\u00E4ren Ausdrucks gespeichert wird.');
                items.push(receiveMailTARGET_STORAGE_KEYCompletion);
                const receiveMailATTACHMENT_LOCATIONCompletion = new vscode.CompletionItem('ATTACHMENT_LOCATION');
                receiveMailATTACHMENT_LOCATIONCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailATTACHMENT_LOCATIONCompletion.insertText = new vscode.SnippetString("ATTACHMENT_LOCATION = \"${1}\"");
                receiveMailATTACHMENT_LOCATIONCompletion.documentation = new vscode.MarkdownString('Pfad zu dem Ordner, in dem die Anh\u00E4nge gespeichert werden sollen.');
                items.push(receiveMailATTACHMENT_LOCATIONCompletion);
                const receiveMailATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('ATTACHMENT_NAME_TARGET_STORAGE_KEY');
                receiveMailATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                receiveMailATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("ATTACHMENT_NAME_TARGET_STORAGE_KEY = \"${1}\"");
                receiveMailATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Name der Laufzeitvariablen, in der die Namen der heruntergeladenen Anh\u00E4nge gespeichert werden.      Trennzeichen bei mehreren Anh\u00E4ngen ist dabei jeweils ein Semikolon (\';\').');
                items.push(receiveMailATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*receiveUnseenMailsSaveAttachment\s*\(.*/.test(linePrefix)) {
                const receiveUnseenMailsSaveAttachmentSERVERCompletion = new vscode.CompletionItem('SERVER');
                receiveUnseenMailsSaveAttachmentSERVERCompletion.kind = vscode.CompletionItemKind.Field;
                receiveUnseenMailsSaveAttachmentSERVERCompletion.insertText = new vscode.SnippetString("SERVER = \"${1}\"");
                receiveUnseenMailsSaveAttachmentSERVERCompletion.documentation = new vscode.MarkdownString('Servername des Mailanbieters.');
                items.push(receiveUnseenMailsSaveAttachmentSERVERCompletion);
                const receiveUnseenMailsSaveAttachmentUSERCompletion = new vscode.CompletionItem('USER');
                receiveUnseenMailsSaveAttachmentUSERCompletion.kind = vscode.CompletionItemKind.Field;
                receiveUnseenMailsSaveAttachmentUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                receiveUnseenMailsSaveAttachmentUSERCompletion.documentation = new vscode.MarkdownString('Benutzername f\u00FCr das Mailkonto');
                items.push(receiveUnseenMailsSaveAttachmentUSERCompletion);
                const receiveUnseenMailsSaveAttachmentPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                receiveUnseenMailsSaveAttachmentPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                receiveUnseenMailsSaveAttachmentPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                receiveUnseenMailsSaveAttachmentPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr das Mailkonto');
                items.push(receiveUnseenMailsSaveAttachmentPASSWORDCompletion);
                const receiveUnseenMailsSaveAttachmentSUBJECTCompletion = new vscode.CompletionItem('SUBJECT');
                receiveUnseenMailsSaveAttachmentSUBJECTCompletion.kind = vscode.CompletionItemKind.Field;
                receiveUnseenMailsSaveAttachmentSUBJECTCompletion.insertText = new vscode.SnippetString("SUBJECT = \"${1}\"");
                receiveUnseenMailsSaveAttachmentSUBJECTCompletion.documentation = new vscode.MarkdownString('Betreff der empfangenden E-Mail.');
                items.push(receiveUnseenMailsSaveAttachmentSUBJECTCompletion);
                const receiveUnseenMailsSaveAttachmentFOLDERCompletion = new vscode.CompletionItem('FOLDER');
                receiveUnseenMailsSaveAttachmentFOLDERCompletion.kind = vscode.CompletionItemKind.Field;
                receiveUnseenMailsSaveAttachmentFOLDERCompletion.insertText = new vscode.SnippetString("FOLDER = \"${1}\"");
                receiveUnseenMailsSaveAttachmentFOLDERCompletion.documentation = new vscode.MarkdownString('Name des Ordners auf dem E-Mail-Server, auf den zugegriffen werden soll.');
                items.push(receiveUnseenMailsSaveAttachmentFOLDERCompletion);
                const receiveUnseenMailsSaveAttachmentATTACHMENT_LOCATIONCompletion = new vscode.CompletionItem('ATTACHMENT_LOCATION');
                receiveUnseenMailsSaveAttachmentATTACHMENT_LOCATIONCompletion.kind = vscode.CompletionItemKind.Field;
                receiveUnseenMailsSaveAttachmentATTACHMENT_LOCATIONCompletion.insertText = new vscode.SnippetString("ATTACHMENT_LOCATION = \"${1}\"");
                receiveUnseenMailsSaveAttachmentATTACHMENT_LOCATIONCompletion.documentation = new vscode.MarkdownString('Pfad zu dem Ordner, in dem die Anh\u00E4nge gespeichert werden sollen.');
                items.push(receiveUnseenMailsSaveAttachmentATTACHMENT_LOCATIONCompletion);
                const receiveUnseenMailsSaveAttachmentATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('ATTACHMENT_NAME_TARGET_STORAGE_KEY');
                receiveUnseenMailsSaveAttachmentATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                receiveUnseenMailsSaveAttachmentATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("ATTACHMENT_NAME_TARGET_STORAGE_KEY = \"${1}\"");
                receiveUnseenMailsSaveAttachmentATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Name der Laufzeitvariablen, in der die Namen der heruntergeladenen Anh\u00E4nge gespeichert werden.      Trennzeichen bei mehreren Anh\u00E4ngen ist dabei jeweils ein Semikolon (\';\').');
                items.push(receiveUnseenMailsSaveAttachmentATTACHMENT_NAME_TARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*refreshWeb\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*removeDuplicates\s*\(.*/.test(linePrefix)) {
                const removeDuplicatesTEXTCompletion = new vscode.CompletionItem('TEXT');
                removeDuplicatesTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                removeDuplicatesTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                removeDuplicatesTEXTCompletion.documentation = new vscode.MarkdownString('Der zu ver\u00E4ndernde Text');
                items.push(removeDuplicatesTEXTCompletion);
                const removeDuplicatesIS_FILECompletion = new vscode.CompletionItem('IS_FILE');
                removeDuplicatesIS_FILECompletion.kind = vscode.CompletionItemKind.Field;
                removeDuplicatesIS_FILECompletion.insertText = new vscode.SnippetString("IS_FILE = \"${1}\"");
                removeDuplicatesIS_FILECompletion.documentation = new vscode.MarkdownString('Angabe, ob der \u00FCbergebene Text ein Dateipfad ist. Default false');
                items.push(removeDuplicatesIS_FILECompletion);
                const removeDuplicatesTARGET_FILECompletion = new vscode.CompletionItem('TARGET_FILE');
                removeDuplicatesTARGET_FILECompletion.kind = vscode.CompletionItemKind.Field;
                removeDuplicatesTARGET_FILECompletion.insertText = new vscode.SnippetString("TARGET_FILE = \"${1}\"");
                removeDuplicatesTARGET_FILECompletion.documentation = new vscode.MarkdownString('Dateipfad, in welche die bearbeitete Datei geschrieben werden soll. Wenn leer, wird in Storage geschrieben');
                items.push(removeDuplicatesTARGET_FILECompletion);
                const removeDuplicatesSEPARATE_BY_LINECompletion = new vscode.CompletionItem('SEPARATE_BY_LINE');
                removeDuplicatesSEPARATE_BY_LINECompletion.kind = vscode.CompletionItemKind.Field;
                removeDuplicatesSEPARATE_BY_LINECompletion.insertText = new vscode.SnippetString("SEPARATE_BY_LINE = \"${1}\"");
                removeDuplicatesSEPARATE_BY_LINECompletion.documentation = new vscode.MarkdownString('Angabe, ob es sich um eine zeilengetrennte Separarierung handelt. Wenn nicht, wird jeder kommaseparierte Wert beachtet.');
                items.push(removeDuplicatesSEPARATE_BY_LINECompletion);
                const removeDuplicatesTRIMCompletion = new vscode.CompletionItem('TRIM');
                removeDuplicatesTRIMCompletion.kind = vscode.CompletionItemKind.Field;
                removeDuplicatesTRIMCompletion.insertText = new vscode.SnippetString("TRIM = \"${1}\"");
                removeDuplicatesTRIMCompletion.documentation = new vscode.MarkdownString('Angabe, ob die .False per Default');
                items.push(removeDuplicatesTRIMCompletion);
                const removeDuplicatesTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                removeDuplicatesTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                removeDuplicatesTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                removeDuplicatesTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der resultierende Text geschrieben wird.');
                items.push(removeDuplicatesTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*renderFullscreenImage\s*\(.*/.test(linePrefix)) {
                const renderFullscreenImageURLCompletion = new vscode.CompletionItem('URL');
                renderFullscreenImageURLCompletion.kind = vscode.CompletionItemKind.Field;
                renderFullscreenImageURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                renderFullscreenImageURLCompletion.documentation = new vscode.MarkdownString('URL des anzuzeigenden Bildes. ');
                items.push(renderFullscreenImageURLCompletion);
                const renderFullscreenImageDURATIONCompletion = new vscode.CompletionItem('DURATION');
                renderFullscreenImageDURATIONCompletion.kind = vscode.CompletionItemKind.Field;
                renderFullscreenImageDURATIONCompletion.insertText = new vscode.SnippetString("DURATION = \"${1}\"");
                renderFullscreenImageDURATIONCompletion.documentation = new vscode.MarkdownString('Anzeigedauer des Bildes in Millisekunden. Default: 3000');
                items.push(renderFullscreenImageDURATIONCompletion);
                const renderFullscreenImageWAITCompletion = new vscode.CompletionItem('WAIT');
                renderFullscreenImageWAITCompletion.kind = vscode.CompletionItemKind.Field;
                renderFullscreenImageWAITCompletion.insertText = new vscode.SnippetString("WAIT = \"${1}\"");
                renderFullscreenImageWAITCompletion.documentation = new vscode.MarkdownString('Soll auf den Abschluss des Renderings gewartet werden? Default: true');
                items.push(renderFullscreenImageWAITCompletion);
                const renderFullscreenImageCLEARCompletion = new vscode.CompletionItem('CLEAR');
                renderFullscreenImageCLEARCompletion.kind = vscode.CompletionItemKind.Field;
                renderFullscreenImageCLEARCompletion.insertText = new vscode.SnippetString("CLEAR = \"${1}\"");
                renderFullscreenImageCLEARCompletion.documentation = new vscode.MarkdownString('Soll der Renderer nach dem Rendering geleert werden? Default: true');
                items.push(renderFullscreenImageCLEARCompletion);
            }
            if (/.*\s*renderOverlayImage\s*\(.*/.test(linePrefix)) {
                const renderOverlayImageURLCompletion = new vscode.CompletionItem('URL');
                renderOverlayImageURLCompletion.kind = vscode.CompletionItemKind.Field;
                renderOverlayImageURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                renderOverlayImageURLCompletion.documentation = new vscode.MarkdownString('URL, die auf das anzuzeigende Bild verweist. Diese URL kann auf eine Bilddatei auf dem lokalen Dateisystem verweisen (Beispiel: file:\/\/D:\/mateo\/splash.png) oder auf eine Bilddatei im Internet (Beispiel: https:\/\/mateo-web.de\/wp-content\/uploads\/2020\/04\/mateo-web_klein.png).');
                items.push(renderOverlayImageURLCompletion);
                const renderOverlayImageDURATIONCompletion = new vscode.CompletionItem('DURATION');
                renderOverlayImageDURATIONCompletion.kind = vscode.CompletionItemKind.Field;
                renderOverlayImageDURATIONCompletion.insertText = new vscode.SnippetString("DURATION = \"${1}\"");
                renderOverlayImageDURATIONCompletion.documentation = new vscode.MarkdownString('Anzeigedauer des Bildes in Millisekunden. Standardm\u00E4\u00DFig wird das Bild dauerhaft angezeigt.');
                items.push(renderOverlayImageDURATIONCompletion);
                const renderOverlayImageOPACITYCompletion = new vscode.CompletionItem('OPACITY');
                renderOverlayImageOPACITYCompletion.kind = vscode.CompletionItemKind.Field;
                renderOverlayImageOPACITYCompletion.insertText = new vscode.SnippetString("OPACITY = \"${1}\"");
                renderOverlayImageOPACITYCompletion.documentation = new vscode.MarkdownString('Deckkraft des Bildes. Default: 1.0');
                items.push(renderOverlayImageOPACITYCompletion);
                const renderOverlayImageWIDTHCompletion = new vscode.CompletionItem('WIDTH');
                renderOverlayImageWIDTHCompletion.kind = vscode.CompletionItemKind.Field;
                renderOverlayImageWIDTHCompletion.insertText = new vscode.SnippetString("WIDTH = \"${1}\"");
                renderOverlayImageWIDTHCompletion.documentation = new vscode.MarkdownString('Breite des anzuzeigenden Bildes. Es kann ein absoluter Wert in Form von \'500\', oder ein relativer Wert in Form vom \'50%\' angegeben werden. Default: Original-Breite des Bildes');
                items.push(renderOverlayImageWIDTHCompletion);
                const renderOverlayImageHEIGHTCompletion = new vscode.CompletionItem('HEIGHT');
                renderOverlayImageHEIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                renderOverlayImageHEIGHTCompletion.insertText = new vscode.SnippetString("HEIGHT = \"${1}\"");
                renderOverlayImageHEIGHTCompletion.documentation = new vscode.MarkdownString('H\u00F6he des anzuzeigenden Bildes. Es kann ein absoluter Wert in Form von \'500\', oder ein relativer Wert in Form vom \'50%\' angegeben werden. Default: Original-H\u00F6he des Bildes');
                items.push(renderOverlayImageHEIGHTCompletion);
                const renderOverlayImageHORIZ_ALIGNCompletion = new vscode.CompletionItem('HORIZ_ALIGN');
                renderOverlayImageHORIZ_ALIGNCompletion.kind = vscode.CompletionItemKind.Field;
                renderOverlayImageHORIZ_ALIGNCompletion.insertText = new vscode.SnippetString("HORIZ_ALIGN = \"${1}\"");
                renderOverlayImageHORIZ_ALIGNCompletion.documentation = new vscode.MarkdownString('Horizontale Ausrichtung des Bildes. M\u00F6gliche Werte: LEFT, CENTER, RIGHT. Default: right');
                items.push(renderOverlayImageHORIZ_ALIGNCompletion);
                const renderOverlayImageVERT_ALIGNCompletion = new vscode.CompletionItem('VERT_ALIGN');
                renderOverlayImageVERT_ALIGNCompletion.kind = vscode.CompletionItemKind.Field;
                renderOverlayImageVERT_ALIGNCompletion.insertText = new vscode.SnippetString("VERT_ALIGN = \"${1}\"");
                renderOverlayImageVERT_ALIGNCompletion.documentation = new vscode.MarkdownString('Vertikale Ausrichtung des Bildes. M\u00F6gliche Werte: TOP, CENTER, BOTTOM. Default: right');
                items.push(renderOverlayImageVERT_ALIGNCompletion);
            }
            if (/.*\s*renderText\s*\(.*/.test(linePrefix)) {
                const renderTextTEXTCompletion = new vscode.CompletionItem('TEXT');
                renderTextTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                renderTextTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                renderTextTEXTCompletion.documentation = new vscode.MarkdownString('Anzuzeigender Text. Zur Formatierung kann HTML verwendet werden. ');
                items.push(renderTextTEXTCompletion);
                const renderTextDURATIONCompletion = new vscode.CompletionItem('DURATION');
                renderTextDURATIONCompletion.kind = vscode.CompletionItemKind.Field;
                renderTextDURATIONCompletion.insertText = new vscode.SnippetString("DURATION = \"${1}\"");
                renderTextDURATIONCompletion.documentation = new vscode.MarkdownString('Anzeigedauer des Textes in Millisekunden. ');
                items.push(renderTextDURATIONCompletion);
                const renderTextVERT_ALIGNCompletion = new vscode.CompletionItem('VERT_ALIGN');
                renderTextVERT_ALIGNCompletion.kind = vscode.CompletionItemKind.Field;
                renderTextVERT_ALIGNCompletion.insertText = new vscode.SnippetString("VERT_ALIGN = \"${1}\"");
                renderTextVERT_ALIGNCompletion.documentation = new vscode.MarkdownString('Vertikale Ausrichtung des Textes. M\u00F6gliche Werte: TOP, CENTER, BOTTOM. Default: bottom');
                items.push(renderTextVERT_ALIGNCompletion);
                const renderTextWAITCompletion = new vscode.CompletionItem('WAIT');
                renderTextWAITCompletion.kind = vscode.CompletionItemKind.Field;
                renderTextWAITCompletion.insertText = new vscode.SnippetString("WAIT = \"${1}\"");
                renderTextWAITCompletion.documentation = new vscode.MarkdownString('Soll das n\u00E4chste Kommando erst nach Abschluss des Renderings - also nachdem das hier angezeigte Element wieder ausgeblendet wurde - ausgef\u00FChrt werden? Default: true');
                items.push(renderTextWAITCompletion);
                const renderTextCLEARCompletion = new vscode.CompletionItem('CLEAR');
                renderTextCLEARCompletion.kind = vscode.CompletionItemKind.Field;
                renderTextCLEARCompletion.insertText = new vscode.SnippetString("CLEAR = \"${1}\"");
                renderTextCLEARCompletion.documentation = new vscode.MarkdownString('Soll der Renderer nach dem Rendering geleert werden? Default: true');
                items.push(renderTextCLEARCompletion);
            }
            if (/.*\s*replaceInText\s*\(.*/.test(linePrefix)) {
                const replaceInTextTEXT_OR_FILECompletion = new vscode.CompletionItem('TEXT_OR_FILE');
                replaceInTextTEXT_OR_FILECompletion.kind = vscode.CompletionItemKind.Field;
                replaceInTextTEXT_OR_FILECompletion.insertText = new vscode.SnippetString("TEXT_OR_FILE = \"${1}\"");
                replaceInTextTEXT_OR_FILECompletion.documentation = new vscode.MarkdownString('Vollst\u00E4ndiger Text oder Dateipfad');
                items.push(replaceInTextTEXT_OR_FILECompletion);
                const replaceInTextWORD_TO_REPLACECompletion = new vscode.CompletionItem('WORD_TO_REPLACE');
                replaceInTextWORD_TO_REPLACECompletion.kind = vscode.CompletionItemKind.Field;
                replaceInTextWORD_TO_REPLACECompletion.insertText = new vscode.SnippetString("WORD_TO_REPLACE = \"${1}\"");
                replaceInTextWORD_TO_REPLACECompletion.documentation = new vscode.MarkdownString('Zu ersetzender Text. Entweder dieser Parameter, oder die beiden POS Werte m\u00FCssen gesetzt sein.');
                items.push(replaceInTextWORD_TO_REPLACECompletion);
                const replaceInTextSUBSTITUTECompletion = new vscode.CompletionItem('SUBSTITUTE');
                replaceInTextSUBSTITUTECompletion.kind = vscode.CompletionItemKind.Field;
                replaceInTextSUBSTITUTECompletion.insertText = new vscode.SnippetString("SUBSTITUTE = \"${1}\"");
                replaceInTextSUBSTITUTECompletion.documentation = new vscode.MarkdownString('Wort, durch das ersetzt werden soll. Falls leer, wird der gefundene Text gel\u00F6scht.');
                items.push(replaceInTextSUBSTITUTECompletion);
                const replaceInTextIS_FILECompletion = new vscode.CompletionItem('IS_FILE');
                replaceInTextIS_FILECompletion.kind = vscode.CompletionItemKind.Field;
                replaceInTextIS_FILECompletion.insertText = new vscode.SnippetString("IS_FILE = \"${1}\"");
                replaceInTextIS_FILECompletion.documentation = new vscode.MarkdownString('Boolean, ob es sich bei TEXT_OR_FILE um eine Datei handelt');
                items.push(replaceInTextIS_FILECompletion);
                const replaceInTextPOS_FROMCompletion = new vscode.CompletionItem('POS_FROM');
                replaceInTextPOS_FROMCompletion.kind = vscode.CompletionItemKind.Field;
                replaceInTextPOS_FROMCompletion.insertText = new vscode.SnippetString("POS_FROM = \"${1}\"");
                replaceInTextPOS_FROMCompletion.documentation = new vscode.MarkdownString('Positionsweises Ersetzen: ab dieser Position im Text wird durch das SUBSTITUE ersetzt. Wenn gesetzt, muss POS_TO auch gesetzt sein.');
                items.push(replaceInTextPOS_FROMCompletion);
                const replaceInTextPOS_TOCompletion = new vscode.CompletionItem('POS_TO');
                replaceInTextPOS_TOCompletion.kind = vscode.CompletionItemKind.Field;
                replaceInTextPOS_TOCompletion.insertText = new vscode.SnippetString("POS_TO = \"${1}\"");
                replaceInTextPOS_TOCompletion.documentation = new vscode.MarkdownString('Positionsweises Ersetzen, bis zu dieser Position im Text wird durch das SUBSTITUE ersetzt. Wenn gesetzt, muss POS_FROM auch gesetzt sein.');
                items.push(replaceInTextPOS_TOCompletion);
                const replaceInTextTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                replaceInTextTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                replaceInTextTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                replaceInTextTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Variable, in die der resultierende Text geschrieben wird.');
                items.push(replaceInTextTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*replaceStringInStorageValue\s*\(.*/.test(linePrefix)) {
                const replaceStringInStorageValueSOURCE_KEYCompletion = new vscode.CompletionItem('SOURCE_KEY');
                replaceStringInStorageValueSOURCE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                replaceStringInStorageValueSOURCE_KEYCompletion.insertText = new vscode.SnippetString("SOURCE_KEY = \"${1}\"");
                replaceStringInStorageValueSOURCE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel des urspr\u00FCnglichen Wertes. Hier wird gespeichert wenn kein TARGET_STORAGE_KEY angegeben ist.');
                items.push(replaceStringInStorageValueSOURCE_KEYCompletion);
                const replaceStringInStorageValueREGEX_TO_FINDCompletion = new vscode.CompletionItem('REGEX_TO_FIND');
                replaceStringInStorageValueREGEX_TO_FINDCompletion.kind = vscode.CompletionItemKind.Field;
                replaceStringInStorageValueREGEX_TO_FINDCompletion.insertText = new vscode.SnippetString("REGEX_TO_FIND = \"${1}\"");
                replaceStringInStorageValueREGEX_TO_FINDCompletion.documentation = new vscode.MarkdownString('Zu findender regul\u00E4rer Ausdruck.');
                items.push(replaceStringInStorageValueREGEX_TO_FINDCompletion);
                const replaceStringInStorageValueREPLACEMENTCompletion = new vscode.CompletionItem('REPLACEMENT');
                replaceStringInStorageValueREPLACEMENTCompletion.kind = vscode.CompletionItemKind.Field;
                replaceStringInStorageValueREPLACEMENTCompletion.insertText = new vscode.SnippetString("REPLACEMENT = \"${1}\"");
                replaceStringInStorageValueREPLACEMENTCompletion.documentation = new vscode.MarkdownString('Wert, mit dem Ersetzt werden soll.');
                items.push(replaceStringInStorageValueREPLACEMENTCompletion);
                const replaceStringInStorageValueTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                replaceStringInStorageValueTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                replaceStringInStorageValueTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                replaceStringInStorageValueTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann ein neuer Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(replaceStringInStorageValueTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*resetContext\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*rotateMobile\s*\(.*/.test(linePrefix)) {
                const rotateMobileORIENTATIONCompletion = new vscode.CompletionItem('ORIENTATION');
                rotateMobileORIENTATIONCompletion.kind = vscode.CompletionItemKind.Field;
                rotateMobileORIENTATIONCompletion.insertText = new vscode.SnippetString("ORIENTATION = \"${1}\"");
                rotateMobileORIENTATIONCompletion.documentation = new vscode.MarkdownString('Wird der Parameter mit \'LANDSCAPE\' belegt, wird das Display im Querformat angezeigt, wird der Parameter mit \'PORTRAIT\' belegt, wird das Display im \'Hochformat\' angezeigt.');
                items.push(rotateMobileORIENTATIONCompletion);
            }
            if (/.*\s*runAppInBackgroundMobile\s*\(.*/.test(linePrefix)) {
                const runAppInBackgroundMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                runAppInBackgroundMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                runAppInBackgroundMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                runAppInBackgroundMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt an, wie viele Millisekunden die App im Hintergrund gehalten werden soll.');
                items.push(runAppInBackgroundMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*runJavascriptAndroid\s*\(.*/.test(linePrefix)) {
                const runJavascriptAndroidJAVASCRIPT_TO_RUNCompletion = new vscode.CompletionItem('JAVASCRIPT_TO_RUN');
                runJavascriptAndroidJAVASCRIPT_TO_RUNCompletion.kind = vscode.CompletionItemKind.Field;
                runJavascriptAndroidJAVASCRIPT_TO_RUNCompletion.insertText = new vscode.SnippetString("JAVASCRIPT_TO_RUN = \"${1}\"");
                runJavascriptAndroidJAVASCRIPT_TO_RUNCompletion.documentation = new vscode.MarkdownString('Der Parameter muss mit dem Java-Code des Skripts belegt werden, das ausgef\u00FChrt werden soll.');
                items.push(runJavascriptAndroidJAVASCRIPT_TO_RUNCompletion);
            }
            if (/.*\s*runJavascriptWeb\s*\(.*/.test(linePrefix)) {
                const runJavascriptWebJS_SCRIPT_OR_FILECompletion = new vscode.CompletionItem('JS_SCRIPT_OR_FILE');
                runJavascriptWebJS_SCRIPT_OR_FILECompletion.kind = vscode.CompletionItemKind.Field;
                runJavascriptWebJS_SCRIPT_OR_FILECompletion.insertText = new vscode.SnippetString("JS_SCRIPT_OR_FILE = \"${1}\"");
                runJavascriptWebJS_SCRIPT_OR_FILECompletion.documentation = new vscode.MarkdownString('Javascript, das ausgef\u00FChrt werden soll oder Pfad zu einer .js-Datei, die dieses Javascript enth\u00E4lt.      Bei einem Dateipfad muss der Parameterwert mit \'.js\' enden. Der Pfad kann absolut oder auch relativ zum Verzeichnis angegeben werden, das das Testset enth\u00E4lt.       Verzeichnisnamen in absoluten Pfade d\u00FCrfen unter Unix\/Linux\/MacOS nur durch \'\/\' getrennt werden, nicht durch \'\'.        ');
                items.push(runJavascriptWebJS_SCRIPT_OR_FILECompletion);
                const runJavascriptWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                runJavascriptWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                runJavascriptWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                runJavascriptWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Falls das Javascript sich auf ein Element beziehen soll (in JS referenzierbar mit arguments[0]): Kriterium, um das Element zu finden (css, js, xpath, linktext, partiallinktext, tagname, id, name, firstLinkName, class).');
                items.push(runJavascriptWebBY_CRITERIACompletion);
                const runJavascriptWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                runJavascriptWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                runJavascriptWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                runJavascriptWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Falls das Javascript sich auf ein Element beziehen soll (in JS referenzierbar mit arguments[0]): Name des Elements, abh\u00E4ngig von BY_CRITERIA.');
                items.push(runJavascriptWebELEMENT_NAMECompletion);
                const runJavascriptWebRESOLVE_SCRIPTCompletion = new vscode.CompletionItem('RESOLVE_SCRIPT');
                runJavascriptWebRESOLVE_SCRIPTCompletion.kind = vscode.CompletionItemKind.Field;
                runJavascriptWebRESOLVE_SCRIPTCompletion.insertText = new vscode.SnippetString("RESOLVE_SCRIPT = \"${1}\"");
                runJavascriptWebRESOLVE_SCRIPTCompletion.documentation = new vscode.MarkdownString('Hier kann optional die Ersetzungen des Storage Resolver abgeschaltet werden, damit der Code exakt wie aus der Datei verwendet wird. Default ist: true (Resolution active)');
                items.push(runJavascriptWebRESOLVE_SCRIPTCompletion);
                const runJavascriptWebENCODING_TEXTCompletion = new vscode.CompletionItem('ENCODING_TEXT');
                runJavascriptWebENCODING_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                runJavascriptWebENCODING_TEXTCompletion.insertText = new vscode.SnippetString("ENCODING_TEXT = \"${1}\"");
                runJavascriptWebENCODING_TEXTCompletion.documentation = new vscode.MarkdownString('Hier kann optional angegeben werden, welche encoding unterst\u00FCtzt werden soll');
                items.push(runJavascriptWebENCODING_TEXTCompletion);
                const runJavascriptWebTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                runJavascriptWebTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                runJavascriptWebTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                runJavascriptWebTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Falls das Skript einen R\u00FCckgabewert hat (also mit einem Return-Statement abschlie\u00DFt),      kann dieser Wert unter dem hier angegebenen Schl\u00FCssel in der Storage-Datei abgelegt werden.');
                items.push(runJavascriptWebTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sapConnectionNumberClear\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*sapConnectionNumberSet\s*\(.*/.test(linePrefix)) {
                const sapConnectionNumberSetCONNECTION_NRCompletion = new vscode.CompletionItem('CONNECTION_NR');
                sapConnectionNumberSetCONNECTION_NRCompletion.kind = vscode.CompletionItemKind.Field;
                sapConnectionNumberSetCONNECTION_NRCompletion.insertText = new vscode.SnippetString("CONNECTION_NR = \"${1}\"");
                sapConnectionNumberSetCONNECTION_NRCompletion.documentation = new vscode.MarkdownString('Nummer der Connection.');
                items.push(sapConnectionNumberSetCONNECTION_NRCompletion);
            }
            if (/.*\s*sapContextMenu\s*\(.*/.test(linePrefix)) {
                const sapContextMenuOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapContextMenuOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapContextMenuOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapContextMenuOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapContextMenuOBJECT_IDCompletion);
            }
            if (/.*\s*sapDoubleClick\s*\(.*/.test(linePrefix)) {
                const sapDoubleClickOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapDoubleClickOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapDoubleClickOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapDoubleClickOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapDoubleClickOBJECT_IDCompletion);
            }
            if (/.*\s*sapFindStringInTreeAndDoubleClick\s*\(.*/.test(linePrefix)) {
                const sapFindStringInTreeAndDoubleClickOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapFindStringInTreeAndDoubleClickOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeAndDoubleClickOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapFindStringInTreeAndDoubleClickOBJECT_IDCompletion.documentation = new vscode.MarkdownString('SAP Objekt-Container innerhalb dessen gesucht werden soll (z.B. shell).');
                items.push(sapFindStringInTreeAndDoubleClickOBJECT_IDCompletion);
                const sapFindStringInTreeAndDoubleClickSUBSTRINGCompletion = new vscode.CompletionItem('SUBSTRING');
                sapFindStringInTreeAndDoubleClickSUBSTRINGCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeAndDoubleClickSUBSTRINGCompletion.insertText = new vscode.SnippetString("SUBSTRING = \"${1}\"");
                sapFindStringInTreeAndDoubleClickSUBSTRINGCompletion.documentation = new vscode.MarkdownString('Der Ausdruck nach dem gesucht werden soll.');
                items.push(sapFindStringInTreeAndDoubleClickSUBSTRINGCompletion);
            }
            if (/.*\s*sapFindStringInTreeAndSelect\s*\(.*/.test(linePrefix)) {
                const sapFindStringInTreeAndSelectOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapFindStringInTreeAndSelectOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeAndSelectOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapFindStringInTreeAndSelectOBJECT_IDCompletion.documentation = new vscode.MarkdownString('SAP Objekt-Container innerhalb dessen gesucht werden soll (z.B. shell).');
                items.push(sapFindStringInTreeAndSelectOBJECT_IDCompletion);
                const sapFindStringInTreeAndSelectSUBSTRINGCompletion = new vscode.CompletionItem('SUBSTRING');
                sapFindStringInTreeAndSelectSUBSTRINGCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeAndSelectSUBSTRINGCompletion.insertText = new vscode.SnippetString("SUBSTRING = \"${1}\"");
                sapFindStringInTreeAndSelectSUBSTRINGCompletion.documentation = new vscode.MarkdownString('Der Ausdruck nach dem gesucht werden soll.');
                items.push(sapFindStringInTreeAndSelectSUBSTRINGCompletion);
            }
            if (/.*\s*sapFindStringInTreeByRegexAndDoubleClick\s*\(.*/.test(linePrefix)) {
                const sapFindStringInTreeByRegexAndDoubleClickOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapFindStringInTreeByRegexAndDoubleClickOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeByRegexAndDoubleClickOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapFindStringInTreeByRegexAndDoubleClickOBJECT_IDCompletion.documentation = new vscode.MarkdownString('SAP Objekt-Container innerhalb dessen gesucht werden soll (z.B. shell).');
                items.push(sapFindStringInTreeByRegexAndDoubleClickOBJECT_IDCompletion);
                const sapFindStringInTreeByRegexAndDoubleClickSUBSTRINGCompletion = new vscode.CompletionItem('SUBSTRING');
                sapFindStringInTreeByRegexAndDoubleClickSUBSTRINGCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeByRegexAndDoubleClickSUBSTRINGCompletion.insertText = new vscode.SnippetString("SUBSTRING = \"${1}\"");
                sapFindStringInTreeByRegexAndDoubleClickSUBSTRINGCompletion.documentation = new vscode.MarkdownString('Der regul\u00E4re Ausdruck nach dem gesucht werden soll.');
                items.push(sapFindStringInTreeByRegexAndDoubleClickSUBSTRINGCompletion);
            }
            if (/.*\s*sapFindStringInTreeByRegexAndSelect\s*\(.*/.test(linePrefix)) {
                const sapFindStringInTreeByRegexAndSelectOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapFindStringInTreeByRegexAndSelectOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeByRegexAndSelectOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapFindStringInTreeByRegexAndSelectOBJECT_IDCompletion.documentation = new vscode.MarkdownString('SAP Objekt-Container innerhalb dessen gesucht werden soll (z.B. shell).');
                items.push(sapFindStringInTreeByRegexAndSelectOBJECT_IDCompletion);
                const sapFindStringInTreeByRegexAndSelectSUBSTRINGCompletion = new vscode.CompletionItem('SUBSTRING');
                sapFindStringInTreeByRegexAndSelectSUBSTRINGCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeByRegexAndSelectSUBSTRINGCompletion.insertText = new vscode.SnippetString("SUBSTRING = \"${1}\"");
                sapFindStringInTreeByRegexAndSelectSUBSTRINGCompletion.documentation = new vscode.MarkdownString('Der regul\u00E4re Ausdruck nach dem gesucht werden soll.');
                items.push(sapFindStringInTreeByRegexAndSelectSUBSTRINGCompletion);
            }
            if (/.*\s*sapFindStringInTreeUseFunction\s*\(.*/.test(linePrefix)) {
                const sapFindStringInTreeUseFunctionOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapFindStringInTreeUseFunctionOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeUseFunctionOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapFindStringInTreeUseFunctionOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapFindStringInTreeUseFunctionOBJECT_IDCompletion);
                const sapFindStringInTreeUseFunctionSUBSTRINGCompletion = new vscode.CompletionItem('SUBSTRING');
                sapFindStringInTreeUseFunctionSUBSTRINGCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeUseFunctionSUBSTRINGCompletion.insertText = new vscode.SnippetString("SUBSTRING = \"${1}\"");
                sapFindStringInTreeUseFunctionSUBSTRINGCompletion.documentation = new vscode.MarkdownString('Zu suchender Substring');
                items.push(sapFindStringInTreeUseFunctionSUBSTRINGCompletion);
                const sapFindStringInTreeUseFunctionFUNCTIONCompletion = new vscode.CompletionItem('FUNCTION');
                sapFindStringInTreeUseFunctionFUNCTIONCompletion.kind = vscode.CompletionItemKind.Field;
                sapFindStringInTreeUseFunctionFUNCTIONCompletion.insertText = new vscode.SnippetString("FUNCTION = \"${1}\"");
                sapFindStringInTreeUseFunctionFUNCTIONCompletion.documentation = new vscode.MarkdownString('Aufzurufende Funktion des Kontextmen\u00FCs');
                items.push(sapFindStringInTreeUseFunctionFUNCTIONCompletion);
            }
            if (/.*\s*sapGetCellValue\s*\(.*/.test(linePrefix)) {
                const sapGetCellValueOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapGetCellValueOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetCellValueOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapGetCellValueOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des SAP-Objekt-Containers');
                items.push(sapGetCellValueOBJECT_IDCompletion);
                const sapGetCellValueROW_NUMBERCompletion = new vscode.CompletionItem('ROW_NUMBER');
                sapGetCellValueROW_NUMBERCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetCellValueROW_NUMBERCompletion.insertText = new vscode.SnippetString("ROW_NUMBER = \"${1}\"");
                sapGetCellValueROW_NUMBERCompletion.documentation = new vscode.MarkdownString('Nummer der Zeile');
                items.push(sapGetCellValueROW_NUMBERCompletion);
                const sapGetCellValueCOLUMN_NAMECompletion = new vscode.CompletionItem('COLUMN_NAME');
                sapGetCellValueCOLUMN_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sapGetCellValueCOLUMN_NAMECompletion.insertText = new vscode.SnippetString("COLUMN_NAME = \"${1}\"");
                sapGetCellValueCOLUMN_NAMECompletion.documentation = new vscode.MarkdownString('SAP Bezeichnung der Spalte');
                items.push(sapGetCellValueCOLUMN_NAMECompletion);
                const sapGetCellValueTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sapGetCellValueTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetCellValueTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sapGetCellValueTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(sapGetCellValueTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sapGetRowNrWithRegex\s*\(.*/.test(linePrefix)) {
                const sapGetRowNrWithRegexOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapGetRowNrWithRegexOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetRowNrWithRegexOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapGetRowNrWithRegexOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapGetRowNrWithRegexOBJECT_IDCompletion);
                const sapGetRowNrWithRegexCOLUMN_NAMECompletion = new vscode.CompletionItem('COLUMN_NAME');
                sapGetRowNrWithRegexCOLUMN_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sapGetRowNrWithRegexCOLUMN_NAMECompletion.insertText = new vscode.SnippetString("COLUMN_NAME = \"${1}\"");
                sapGetRowNrWithRegexCOLUMN_NAMECompletion.documentation = new vscode.MarkdownString('Name der Spalte in der gesucht werden soll');
                items.push(sapGetRowNrWithRegexCOLUMN_NAMECompletion);
                const sapGetRowNrWithRegexREGEXCompletion = new vscode.CompletionItem('REGEX');
                sapGetRowNrWithRegexREGEXCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetRowNrWithRegexREGEXCompletion.insertText = new vscode.SnippetString("REGEX = \"${1}\"");
                sapGetRowNrWithRegexREGEXCompletion.documentation = new vscode.MarkdownString('Regul\u00E4rer Ausdruck nach dem gesucht werden soll');
                items.push(sapGetRowNrWithRegexREGEXCompletion);
                const sapGetRowNrWithRegexTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sapGetRowNrWithRegexTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetRowNrWithRegexTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sapGetRowNrWithRegexTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den die Zeilennummer geschrieben wird.');
                items.push(sapGetRowNrWithRegexTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sapGetValueOfRowWithRegex\s*\(.*/.test(linePrefix)) {
                const sapGetValueOfRowWithRegexOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapGetValueOfRowWithRegexOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetValueOfRowWithRegexOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapGetValueOfRowWithRegexOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapGetValueOfRowWithRegexOBJECT_IDCompletion);
                const sapGetValueOfRowWithRegexCOLUMN_NAMECompletion = new vscode.CompletionItem('COLUMN_NAME');
                sapGetValueOfRowWithRegexCOLUMN_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sapGetValueOfRowWithRegexCOLUMN_NAMECompletion.insertText = new vscode.SnippetString("COLUMN_NAME = \"${1}\"");
                sapGetValueOfRowWithRegexCOLUMN_NAMECompletion.documentation = new vscode.MarkdownString('Name der Spalte in der gesucht werden soll');
                items.push(sapGetValueOfRowWithRegexCOLUMN_NAMECompletion);
                const sapGetValueOfRowWithRegexREGEXCompletion = new vscode.CompletionItem('REGEX');
                sapGetValueOfRowWithRegexREGEXCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetValueOfRowWithRegexREGEXCompletion.insertText = new vscode.SnippetString("REGEX = \"${1}\"");
                sapGetValueOfRowWithRegexREGEXCompletion.documentation = new vscode.MarkdownString('Regul\u00E4rer Ausdruck nach dem gesucht werden soll');
                items.push(sapGetValueOfRowWithRegexREGEXCompletion);
                const sapGetValueOfRowWithRegexOFFSETCompletion = new vscode.CompletionItem('OFFSET');
                sapGetValueOfRowWithRegexOFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetValueOfRowWithRegexOFFSETCompletion.insertText = new vscode.SnippetString("OFFSET = \"${1}\"");
                sapGetValueOfRowWithRegexOFFSETCompletion.documentation = new vscode.MarkdownString('Position ab der im String gesucht werden soll');
                items.push(sapGetValueOfRowWithRegexOFFSETCompletion);
                const sapGetValueOfRowWithRegexTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sapGetValueOfRowWithRegexTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sapGetValueOfRowWithRegexTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sapGetValueOfRowWithRegexTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den das Ergebnis geschrieben werden soll.');
                items.push(sapGetValueOfRowWithRegexTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sapNodeCollapseByKey\s*\(.*/.test(linePrefix)) {
                const sapNodeCollapseByKeyOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapNodeCollapseByKeyOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapNodeCollapseByKeyOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapNodeCollapseByKeyOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapNodeCollapseByKeyOBJECT_IDCompletion);
                const sapNodeCollapseByKeyNODECompletion = new vscode.CompletionItem('NODE');
                sapNodeCollapseByKeyNODECompletion.kind = vscode.CompletionItemKind.Field;
                sapNodeCollapseByKeyNODECompletion.insertText = new vscode.SnippetString("NODE = \"${1}\"");
                sapNodeCollapseByKeyNODECompletion.documentation = new vscode.MarkdownString('Name der auszuw\u00E4hlenden Node');
                items.push(sapNodeCollapseByKeyNODECompletion);
            }
            if (/.*\s*sapNodeContextMenu\s*\(.*/.test(linePrefix)) {
                const sapNodeContextMenuOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapNodeContextMenuOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapNodeContextMenuOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapNodeContextMenuOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapNodeContextMenuOBJECT_IDCompletion);
                const sapNodeContextMenuNODECompletion = new vscode.CompletionItem('NODE');
                sapNodeContextMenuNODECompletion.kind = vscode.CompletionItemKind.Field;
                sapNodeContextMenuNODECompletion.insertText = new vscode.SnippetString("NODE = \"${1}\"");
                sapNodeContextMenuNODECompletion.documentation = new vscode.MarkdownString('Name der auszuw\u00E4hlenden Node');
                items.push(sapNodeContextMenuNODECompletion);
            }
            if (/.*\s*sapNodeDoubleClick\s*\(.*/.test(linePrefix)) {
                const sapNodeDoubleClickOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapNodeDoubleClickOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapNodeDoubleClickOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapNodeDoubleClickOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapNodeDoubleClickOBJECT_IDCompletion);
                const sapNodeDoubleClickNODECompletion = new vscode.CompletionItem('NODE');
                sapNodeDoubleClickNODECompletion.kind = vscode.CompletionItemKind.Field;
                sapNodeDoubleClickNODECompletion.insertText = new vscode.SnippetString("NODE = \"${1}\"");
                sapNodeDoubleClickNODECompletion.documentation = new vscode.MarkdownString('Name der auszuw\u00E4hlenden Node');
                items.push(sapNodeDoubleClickNODECompletion);
            }
            if (/.*\s*sapNodeExpandByKey\s*\(.*/.test(linePrefix)) {
                const sapNodeExpandByKeyOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapNodeExpandByKeyOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapNodeExpandByKeyOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapNodeExpandByKeyOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapNodeExpandByKeyOBJECT_IDCompletion);
                const sapNodeExpandByKeyNODECompletion = new vscode.CompletionItem('NODE');
                sapNodeExpandByKeyNODECompletion.kind = vscode.CompletionItemKind.Field;
                sapNodeExpandByKeyNODECompletion.insertText = new vscode.SnippetString("NODE = \"${1}\"");
                sapNodeExpandByKeyNODECompletion.documentation = new vscode.MarkdownString('Name der auszuw\u00E4hlenden Node');
                items.push(sapNodeExpandByKeyNODECompletion);
            }
            if (/.*\s*sapObjDeselect\s*\(.*/.test(linePrefix)) {
                const sapObjDeselectOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjDeselectOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjDeselectOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjDeselectOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjDeselectOBJECT_IDCompletion);
            }
            if (/.*\s*sapObjFindByRegex\s*\(.*/.test(linePrefix)) {
                const sapObjFindByRegexOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjFindByRegexOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByRegexOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjFindByRegexOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Elements unterhalb dessen gesucht werden soll (Falls nicht angegeben wird => \/usr verwendet)');
                items.push(sapObjFindByRegexOBJECT_IDCompletion);
                const sapObjFindByRegexREGEXCompletion = new vscode.CompletionItem('REGEX');
                sapObjFindByRegexREGEXCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByRegexREGEXCompletion.insertText = new vscode.SnippetString("REGEX = \"${1}\"");
                sapObjFindByRegexREGEXCompletion.documentation = new vscode.MarkdownString('Regul\u00E4rer Ausdruck nach dem gesucht wird');
                items.push(sapObjFindByRegexREGEXCompletion);
                const sapObjFindByRegexINSTANCECompletion = new vscode.CompletionItem('INSTANCE');
                sapObjFindByRegexINSTANCECompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByRegexINSTANCECompletion.insertText = new vscode.SnippetString("INSTANCE = \"${1}\"");
                sapObjFindByRegexINSTANCECompletion.documentation = new vscode.MarkdownString('Instanz des zu suchenden Werts. Bei INSTANCE = 3 wird erst das dritte Element mit dem passenden regul\u00E4ren Ausdruck zur\u00FCckgegeben.');
                items.push(sapObjFindByRegexINSTANCECompletion);
                const sapObjFindByRegexOBJECT_OFFSETCompletion = new vscode.CompletionItem('OBJECT_OFFSET');
                sapObjFindByRegexOBJECT_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByRegexOBJECT_OFFSETCompletion.insertText = new vscode.SnippetString("OBJECT_OFFSET = \"${1}\"");
                sapObjFindByRegexOBJECT_OFFSETCompletion.documentation = new vscode.MarkdownString('Offset vom gesuchten Objekt. Bei OBJECT_OFFSET = 3 wird das dritte Element hinter dem Gesuchten im Objektbaum zur\u00FCckgegeben.');
                items.push(sapObjFindByRegexOBJECT_OFFSETCompletion);
                const sapObjFindByRegexTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sapObjFindByRegexTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByRegexTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sapObjFindByRegexTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den das Ergebnis geschrieben werden soll.');
                items.push(sapObjFindByRegexTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sapObjFindByValue\s*\(.*/.test(linePrefix)) {
                const sapObjFindByValueOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjFindByValueOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByValueOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjFindByValueOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Elements unterhalb dessen gesucht werden soll (Falls nicht angegeben wird => \/usr verwendet)');
                items.push(sapObjFindByValueOBJECT_IDCompletion);
                const sapObjFindByValueOBJECT_VALUECompletion = new vscode.CompletionItem('OBJECT_VALUE');
                sapObjFindByValueOBJECT_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByValueOBJECT_VALUECompletion.insertText = new vscode.SnippetString("OBJECT_VALUE = \"${1}\"");
                sapObjFindByValueOBJECT_VALUECompletion.documentation = new vscode.MarkdownString('Wert des zu suchenden Elements');
                items.push(sapObjFindByValueOBJECT_VALUECompletion);
                const sapObjFindByValueMATCH_TYPECompletion = new vscode.CompletionItem('MATCH_TYPE');
                sapObjFindByValueMATCH_TYPECompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByValueMATCH_TYPECompletion.insertText = new vscode.SnippetString("MATCH_TYPE = \"${1}\"");
                sapObjFindByValueMATCH_TYPECompletion.documentation = new vscode.MarkdownString('Typ der Suche (0 => Wert gleich OBJECT_VALUE, 1 => Wert beinhaltet OBJECT_VALUE)');
                items.push(sapObjFindByValueMATCH_TYPECompletion);
                const sapObjFindByValueINSTANCECompletion = new vscode.CompletionItem('INSTANCE');
                sapObjFindByValueINSTANCECompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByValueINSTANCECompletion.insertText = new vscode.SnippetString("INSTANCE = \"${1}\"");
                sapObjFindByValueINSTANCECompletion.documentation = new vscode.MarkdownString('Instanz des zu suchenden Werts. Bei INSTANCE = 3 wird erst das Dritte Element mit dem gew\u00FCnschten OBJECT_VALUE zur\u00FCckgegeben.');
                items.push(sapObjFindByValueINSTANCECompletion);
                const sapObjFindByValueOBJECT_OFFSETCompletion = new vscode.CompletionItem('OBJECT_OFFSET');
                sapObjFindByValueOBJECT_OFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByValueOBJECT_OFFSETCompletion.insertText = new vscode.SnippetString("OBJECT_OFFSET = \"${1}\"");
                sapObjFindByValueOBJECT_OFFSETCompletion.documentation = new vscode.MarkdownString('Offset vom gesuchten Objekt. Bei OBJECT_OFFSET = 3 wird das dritte Element hinter dem Gesuchten im Objektbaum zur\u00FCckgegeben.');
                items.push(sapObjFindByValueOBJECT_OFFSETCompletion);
                const sapObjFindByValueTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sapObjFindByValueTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjFindByValueTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sapObjFindByValueTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den das Ergebnis geschrieben werden soll.');
                items.push(sapObjFindByValueTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sapObjPress\s*\(.*/.test(linePrefix)) {
                const sapObjPressOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjPressOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjPressOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjPressOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjPressOBJECT_IDCompletion);
            }
            if (/.*\s*sapObjPropertyGet\s*\(.*/.test(linePrefix)) {
                const sapObjPropertyGetOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjPropertyGetOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjPropertyGetOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjPropertyGetOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjPropertyGetOBJECT_IDCompletion);
                const sapObjPropertyGetOBJECT_PROPERTYCompletion = new vscode.CompletionItem('OBJECT_PROPERTY');
                sapObjPropertyGetOBJECT_PROPERTYCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjPropertyGetOBJECT_PROPERTYCompletion.insertText = new vscode.SnippetString("OBJECT_PROPERTY = \"${1}\"");
                sapObjPropertyGetOBJECT_PROPERTYCompletion.documentation = new vscode.MarkdownString('Name des Attributs');
                items.push(sapObjPropertyGetOBJECT_PROPERTYCompletion);
                const sapObjPropertyGetTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sapObjPropertyGetTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjPropertyGetTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sapObjPropertyGetTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den das Ergebnis geschrieben werden soll.');
                items.push(sapObjPropertyGetTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sapObjPropertySet\s*\(.*/.test(linePrefix)) {
                const sapObjPropertySetOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjPropertySetOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjPropertySetOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjPropertySetOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjPropertySetOBJECT_IDCompletion);
                const sapObjPropertySetOBJECT_PROPERTYCompletion = new vscode.CompletionItem('OBJECT_PROPERTY');
                sapObjPropertySetOBJECT_PROPERTYCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjPropertySetOBJECT_PROPERTYCompletion.insertText = new vscode.SnippetString("OBJECT_PROPERTY = \"${1}\"");
                sapObjPropertySetOBJECT_PROPERTYCompletion.documentation = new vscode.MarkdownString('Name des Attributs');
                items.push(sapObjPropertySetOBJECT_PROPERTYCompletion);
                const sapObjPropertySetOBJECT_VALUECompletion = new vscode.CompletionItem('OBJECT_VALUE');
                sapObjPropertySetOBJECT_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                sapObjPropertySetOBJECT_VALUECompletion.insertText = new vscode.SnippetString("OBJECT_VALUE = \"${1}\"");
                sapObjPropertySetOBJECT_VALUECompletion.documentation = new vscode.MarkdownString('Wert des Attributs');
                items.push(sapObjPropertySetOBJECT_VALUECompletion);
            }
            if (/.*\s*sapObjSelect\s*\(.*/.test(linePrefix)) {
                const sapObjSelectOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjSelectOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjSelectOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjSelectOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjSelectOBJECT_IDCompletion);
            }
            if (/.*\s*sapObjSelectColumn\s*\(.*/.test(linePrefix)) {
                const sapObjSelectColumnOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjSelectColumnOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjSelectColumnOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjSelectColumnOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjSelectColumnOBJECT_IDCompletion);
                const sapObjSelectColumnCOLUMN_IDCompletion = new vscode.CompletionItem('COLUMN_ID');
                sapObjSelectColumnCOLUMN_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjSelectColumnCOLUMN_IDCompletion.insertText = new vscode.SnippetString("COLUMN_ID = \"${1}\"");
                sapObjSelectColumnCOLUMN_IDCompletion.documentation = new vscode.MarkdownString('Name der auszuw\u00E4hlenden Spalte');
                items.push(sapObjSelectColumnCOLUMN_IDCompletion);
            }
            if (/.*\s*sapObjSelectKey\s*\(.*/.test(linePrefix)) {
                const sapObjSelectKeyOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjSelectKeyOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjSelectKeyOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjSelectKeyOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjSelectKeyOBJECT_IDCompletion);
                const sapObjSelectKeyKEY_VALUECompletion = new vscode.CompletionItem('KEY_VALUE');
                sapObjSelectKeyKEY_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                sapObjSelectKeyKEY_VALUECompletion.insertText = new vscode.SnippetString("KEY_VALUE = \"${1}\"");
                sapObjSelectKeyKEY_VALUECompletion.documentation = new vscode.MarkdownString('Objekt-Schl\u00FCssel');
                items.push(sapObjSelectKeyKEY_VALUECompletion);
            }
            if (/.*\s*sapObjSetFocus\s*\(.*/.test(linePrefix)) {
                const sapObjSetFocusOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjSetFocusOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjSetFocusOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjSetFocusOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjSetFocusOBJECT_IDCompletion);
            }
            if (/.*\s*sapObjValueGet\s*\(.*/.test(linePrefix)) {
                const sapObjValueGetOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjValueGetOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjValueGetOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjValueGetOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjValueGetOBJECT_IDCompletion);
                const sapObjValueGetTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sapObjValueGetTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjValueGetTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sapObjValueGetTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den das Ergebnis geschrieben werden soll.');
                items.push(sapObjValueGetTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sapObjValueSet\s*\(.*/.test(linePrefix)) {
                const sapObjValueSetOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapObjValueSetOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapObjValueSetOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapObjValueSetOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapObjValueSetOBJECT_IDCompletion);
                const sapObjValueSetOBJECT_VALUECompletion = new vscode.CompletionItem('OBJECT_VALUE');
                sapObjValueSetOBJECT_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                sapObjValueSetOBJECT_VALUECompletion.insertText = new vscode.SnippetString("OBJECT_VALUE = \"${1}\"");
                sapObjValueSetOBJECT_VALUECompletion.documentation = new vscode.MarkdownString('Wert des Objekts');
                items.push(sapObjValueSetOBJECT_VALUECompletion);
            }
            if (/.*\s*sapPressContextButton\s*\(.*/.test(linePrefix)) {
                const sapPressContextButtonOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapPressContextButtonOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapPressContextButtonOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapPressContextButtonOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapPressContextButtonOBJECT_IDCompletion);
                const sapPressContextButtonBUTTONCompletion = new vscode.CompletionItem('BUTTON');
                sapPressContextButtonBUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                sapPressContextButtonBUTTONCompletion.insertText = new vscode.SnippetString("BUTTON = \"${1}\"");
                sapPressContextButtonBUTTONCompletion.documentation = new vscode.MarkdownString('Zu dr\u00FCckender Button');
                items.push(sapPressContextButtonBUTTONCompletion);
            }
            if (/.*\s*sapSelectComboBoxEntryByValue\s*\(.*/.test(linePrefix)) {
                const sapSelectComboBoxEntryByValueOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapSelectComboBoxEntryByValueOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapSelectComboBoxEntryByValueOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapSelectComboBoxEntryByValueOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapSelectComboBoxEntryByValueOBJECT_IDCompletion);
                const sapSelectComboBoxEntryByValueSEARCHSTRINGCompletion = new vscode.CompletionItem('SEARCHSTRING');
                sapSelectComboBoxEntryByValueSEARCHSTRINGCompletion.kind = vscode.CompletionItemKind.Field;
                sapSelectComboBoxEntryByValueSEARCHSTRINGCompletion.insertText = new vscode.SnippetString("SEARCHSTRING = \"${1}\"");
                sapSelectComboBoxEntryByValueSEARCHSTRINGCompletion.documentation = new vscode.MarkdownString('Zu w\u00E4hlender String');
                items.push(sapSelectComboBoxEntryByValueSEARCHSTRINGCompletion);
            }
            if (/.*\s*sapSelectContextMenuItem\s*\(.*/.test(linePrefix)) {
                const sapSelectContextMenuItemOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapSelectContextMenuItemOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapSelectContextMenuItemOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapSelectContextMenuItemOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapSelectContextMenuItemOBJECT_IDCompletion);
                const sapSelectContextMenuItemITEMCompletion = new vscode.CompletionItem('ITEM');
                sapSelectContextMenuItemITEMCompletion.kind = vscode.CompletionItemKind.Field;
                sapSelectContextMenuItemITEMCompletion.insertText = new vscode.SnippetString("ITEM = \"${1}\"");
                sapSelectContextMenuItemITEMCompletion.documentation = new vscode.MarkdownString('Name des Eintrags');
                items.push(sapSelectContextMenuItemITEMCompletion);
            }
            if (/.*\s*sapSelectContextMenuItemByPosition\s*\(.*/.test(linePrefix)) {
                const sapSelectContextMenuItemByPositionOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapSelectContextMenuItemByPositionOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapSelectContextMenuItemByPositionOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapSelectContextMenuItemByPositionOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapSelectContextMenuItemByPositionOBJECT_IDCompletion);
                const sapSelectContextMenuItemByPositionPOSITIONCompletion = new vscode.CompletionItem('POSITION');
                sapSelectContextMenuItemByPositionPOSITIONCompletion.kind = vscode.CompletionItemKind.Field;
                sapSelectContextMenuItemByPositionPOSITIONCompletion.insertText = new vscode.SnippetString("POSITION = \"${1}\"");
                sapSelectContextMenuItemByPositionPOSITIONCompletion.documentation = new vscode.MarkdownString('Position des Eintrags');
                items.push(sapSelectContextMenuItemByPositionPOSITIONCompletion);
            }
            if (/.*\s*sapSessAttach\s*\(.*/.test(linePrefix)) {
                const sapSessAttachWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                sapSessAttachWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sapSessAttachWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                sapSessAttachWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des SAP Fensters (meist aktueller Titel)');
                items.push(sapSessAttachWINDOW_NAMECompletion);
            }
            if (/.*\s*sapSessCreate\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*sapSetCurrentCellFocus\s*\(.*/.test(linePrefix)) {
                const sapSetCurrentCellFocusOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapSetCurrentCellFocusOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapSetCurrentCellFocusOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapSetCurrentCellFocusOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des SAP-Objekt-Containers');
                items.push(sapSetCurrentCellFocusOBJECT_IDCompletion);
                const sapSetCurrentCellFocusCOLUMN_NAMECompletion = new vscode.CompletionItem('COLUMN_NAME');
                sapSetCurrentCellFocusCOLUMN_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sapSetCurrentCellFocusCOLUMN_NAMECompletion.insertText = new vscode.SnippetString("COLUMN_NAME = \"${1}\"");
                sapSetCurrentCellFocusCOLUMN_NAMECompletion.documentation = new vscode.MarkdownString('SAP Bezeichnung der Spalte');
                items.push(sapSetCurrentCellFocusCOLUMN_NAMECompletion);
                const sapSetCurrentCellFocusROW_NUMBERCompletion = new vscode.CompletionItem('ROW_NUMBER');
                sapSetCurrentCellFocusROW_NUMBERCompletion.kind = vscode.CompletionItemKind.Field;
                sapSetCurrentCellFocusROW_NUMBERCompletion.insertText = new vscode.SnippetString("ROW_NUMBER = \"${1}\"");
                sapSetCurrentCellFocusROW_NUMBERCompletion.documentation = new vscode.MarkdownString('Nummer der Zeile');
                items.push(sapSetCurrentCellFocusROW_NUMBERCompletion);
            }
            if (/.*\s*sapShowContextMenu\s*\(.*/.test(linePrefix)) {
                const sapShowContextMenuOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapShowContextMenuOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapShowContextMenuOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapShowContextMenuOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapShowContextMenuOBJECT_IDCompletion);
            }
            if (/.*\s*sapVKeysSend\s*\(.*/.test(linePrefix)) {
                const sapVKeysSendVKEYS_TO_SENDCompletion = new vscode.CompletionItem('VKEYS_TO_SEND');
                sapVKeysSendVKEYS_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sapVKeysSendVKEYS_TO_SENDCompletion.insertText = new vscode.SnippetString("VKEYS_TO_SEND = \"${1}\"");
                sapVKeysSendVKEYS_TO_SENDCompletion.documentation = new vscode.MarkdownString('Komma separierte Liste der zu sendenden VKeys (z.B.: Enter,Shift+F1,Ctrl+N)');
                items.push(sapVKeysSendVKEYS_TO_SENDCompletion);
            }
            if (/.*\s*sapVKeysSendUntilWinExists\s*\(.*/.test(linePrefix)) {
                const sapVKeysSendUntilWinExistsVKEYS_TO_SENDCompletion = new vscode.CompletionItem('VKEYS_TO_SEND');
                sapVKeysSendUntilWinExistsVKEYS_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sapVKeysSendUntilWinExistsVKEYS_TO_SENDCompletion.insertText = new vscode.SnippetString("VKEYS_TO_SEND = \"${1}\"");
                sapVKeysSendUntilWinExistsVKEYS_TO_SENDCompletion.documentation = new vscode.MarkdownString('Komma separierte Liste der zu sendenden VKeys (z.B.: Enter,Shift+F1,Ctrl+N)');
                items.push(sapVKeysSendUntilWinExistsVKEYS_TO_SENDCompletion);
                const sapVKeysSendUntilWinExistsWIN_TITLECompletion = new vscode.CompletionItem('WIN_TITLE');
                sapVKeysSendUntilWinExistsWIN_TITLECompletion.kind = vscode.CompletionItemKind.Field;
                sapVKeysSendUntilWinExistsWIN_TITLECompletion.insertText = new vscode.SnippetString("WIN_TITLE = \"${1}\"");
                sapVKeysSendUntilWinExistsWIN_TITLECompletion.documentation = new vscode.MarkdownString('Fenstername auf den gepr\u00FCft werden soll.');
                items.push(sapVKeysSendUntilWinExistsWIN_TITLECompletion);
            }
            if (/.*\s*sapVerticalScrollbarPosition\s*\(.*/.test(linePrefix)) {
                const sapVerticalScrollbarPositionOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapVerticalScrollbarPositionOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapVerticalScrollbarPositionOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapVerticalScrollbarPositionOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapVerticalScrollbarPositionOBJECT_IDCompletion);
                const sapVerticalScrollbarPositionPOSITIONCompletion = new vscode.CompletionItem('POSITION');
                sapVerticalScrollbarPositionPOSITIONCompletion.kind = vscode.CompletionItemKind.Field;
                sapVerticalScrollbarPositionPOSITIONCompletion.insertText = new vscode.SnippetString("POSITION = \"${1}\"");
                sapVerticalScrollbarPositionPOSITIONCompletion.documentation = new vscode.MarkdownString('Zu setzende Position der Scrollbar');
                items.push(sapVerticalScrollbarPositionPOSITIONCompletion);
            }
            if (/.*\s*sapVerticalScrollbarPositionIncrease\s*\(.*/.test(linePrefix)) {
                const sapVerticalScrollbarPositionIncreaseOBJECT_IDCompletion = new vscode.CompletionItem('OBJECT_ID');
                sapVerticalScrollbarPositionIncreaseOBJECT_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sapVerticalScrollbarPositionIncreaseOBJECT_IDCompletion.insertText = new vscode.SnippetString("OBJECT_ID = \"${1}\"");
                sapVerticalScrollbarPositionIncreaseOBJECT_IDCompletion.documentation = new vscode.MarkdownString('ID des Zielelements');
                items.push(sapVerticalScrollbarPositionIncreaseOBJECT_IDCompletion);
                const sapVerticalScrollbarPositionIncreaseINCREASECompletion = new vscode.CompletionItem('INCREASE');
                sapVerticalScrollbarPositionIncreaseINCREASECompletion.kind = vscode.CompletionItemKind.Field;
                sapVerticalScrollbarPositionIncreaseINCREASECompletion.insertText = new vscode.SnippetString("INCREASE = \"${1}\"");
                sapVerticalScrollbarPositionIncreaseINCREASECompletion.documentation = new vscode.MarkdownString('Ver\u00E4nderung der Position der Scrollbar)');
                items.push(sapVerticalScrollbarPositionIncreaseINCREASECompletion);
            }
            if (/.*\s*sapWinClose\s*\(.*/.test(linePrefix)) {
                const sapWinCloseWIN_TITLECompletion = new vscode.CompletionItem('WIN_TITLE');
                sapWinCloseWIN_TITLECompletion.kind = vscode.CompletionItemKind.Field;
                sapWinCloseWIN_TITLECompletion.insertText = new vscode.SnippetString("WIN_TITLE = \"${1}\"");
                sapWinCloseWIN_TITLECompletion.documentation = new vscode.MarkdownString('Fenstername auf den gepr\u00FCft werden soll.');
                items.push(sapWinCloseWIN_TITLECompletion);
            }
            if (/.*\s*sapWinExists\s*\(.*/.test(linePrefix)) {
                const sapWinExistsWIN_TITLECompletion = new vscode.CompletionItem('WIN_TITLE');
                sapWinExistsWIN_TITLECompletion.kind = vscode.CompletionItemKind.Field;
                sapWinExistsWIN_TITLECompletion.insertText = new vscode.SnippetString("WIN_TITLE = \"${1}\"");
                sapWinExistsWIN_TITLECompletion.documentation = new vscode.MarkdownString('Fenstername auf den gepr\u00FCft werden soll.');
                items.push(sapWinExistsWIN_TITLECompletion);
                const sapWinExistsDO_SWITCH_WINDOWCompletion = new vscode.CompletionItem('DO_SWITCH_WINDOW');
                sapWinExistsDO_SWITCH_WINDOWCompletion.kind = vscode.CompletionItemKind.Field;
                sapWinExistsDO_SWITCH_WINDOWCompletion.insertText = new vscode.SnippetString("DO_SWITCH_WINDOW = \"${1}\"");
                sapWinExistsDO_SWITCH_WINDOWCompletion.documentation = new vscode.MarkdownString('Wechselt in das zu suchende Fenster.');
                items.push(sapWinExistsDO_SWITCH_WINDOWCompletion);
            }
            if (/.*\s*sapWinNumberSet\s*\(.*/.test(linePrefix)) {
                const sapWinNumberSetWINDOW_NRCompletion = new vscode.CompletionItem('WINDOW_NR');
                sapWinNumberSetWINDOW_NRCompletion.kind = vscode.CompletionItemKind.Field;
                sapWinNumberSetWINDOW_NRCompletion.insertText = new vscode.SnippetString("WINDOW_NR = \"${1}\"");
                sapWinNumberSetWINDOW_NRCompletion.documentation = new vscode.MarkdownString('Fensternummer des Zielfensters.');
                items.push(sapWinNumberSetWINDOW_NRCompletion);
            }
            if (/.*\s*savePictureWeb\s*\(.*/.test(linePrefix)) {
                const savePictureWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                savePictureWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                savePictureWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                savePictureWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(savePictureWebBY_CRITERIACompletion);
                const savePictureWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                savePictureWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                savePictureWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                savePictureWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(savePictureWebELEMENT_NAMECompletion);
                const savePictureWebTARGET_PATHCompletion = new vscode.CompletionItem('TARGET_PATH');
                savePictureWebTARGET_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                savePictureWebTARGET_PATHCompletion.insertText = new vscode.SnippetString("TARGET_PATH = \"${1}\"");
                savePictureWebTARGET_PATHCompletion.documentation = new vscode.MarkdownString('Pfad und Name, unter dem das Bild gespceichert werden soll.');
                items.push(savePictureWebTARGET_PATHCompletion);
            }
            if (/.*\s*scrollDownMobile\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*scrollMobile\s*\(.*/.test(linePrefix)) {
                const scrollMobileFROM_XCompletion = new vscode.CompletionItem('FROM_X');
                scrollMobileFROM_XCompletion.kind = vscode.CompletionItemKind.Field;
                scrollMobileFROM_XCompletion.insertText = new vscode.SnippetString("FROM_X = \"${1}\"");
                scrollMobileFROM_XCompletion.documentation = new vscode.MarkdownString('X Koordinate des Startpunkts von dem die Scroll Bewegung ausgeht.');
                items.push(scrollMobileFROM_XCompletion);
                const scrollMobileFROM_YCompletion = new vscode.CompletionItem('FROM_Y');
                scrollMobileFROM_YCompletion.kind = vscode.CompletionItemKind.Field;
                scrollMobileFROM_YCompletion.insertText = new vscode.SnippetString("FROM_Y = \"${1}\"");
                scrollMobileFROM_YCompletion.documentation = new vscode.MarkdownString('Y Koordinate des Startpunkts von dem die Scroll Bewegung ausgeht.');
                items.push(scrollMobileFROM_YCompletion);
                const scrollMobileTO_XCompletion = new vscode.CompletionItem('TO_X');
                scrollMobileTO_XCompletion.kind = vscode.CompletionItemKind.Field;
                scrollMobileTO_XCompletion.insertText = new vscode.SnippetString("TO_X = \"${1}\"");
                scrollMobileTO_XCompletion.documentation = new vscode.MarkdownString('X Koordinate des Endpunkts, bei dem die Scroll Bewegung endet.');
                items.push(scrollMobileTO_XCompletion);
                const scrollMobileTO_YCompletion = new vscode.CompletionItem('TO_Y');
                scrollMobileTO_YCompletion.kind = vscode.CompletionItemKind.Field;
                scrollMobileTO_YCompletion.insertText = new vscode.SnippetString("TO_Y = \"${1}\"");
                scrollMobileTO_YCompletion.documentation = new vscode.MarkdownString('Y Koordinate des Endpunkts, bei dem die Scroll Bewegung endet.');
                items.push(scrollMobileTO_YCompletion);
            }
            if (/.*\s*scrollMouseWheel\s*\(.*/.test(linePrefix)) {
                const scrollMouseWheelWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                scrollMouseWheelWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                scrollMouseWheelWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                scrollMouseWheelWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des aktiven Fensters, in dem gescrollt werden soll.');
                items.push(scrollMouseWheelWINDOW_NAMECompletion);
                const scrollMouseWheelWHEEL_DIRECTIONCompletion = new vscode.CompletionItem('WHEEL_DIRECTION');
                scrollMouseWheelWHEEL_DIRECTIONCompletion.kind = vscode.CompletionItemKind.Field;
                scrollMouseWheelWHEEL_DIRECTIONCompletion.insertText = new vscode.SnippetString("WHEEL_DIRECTION = \"${1}\"");
                scrollMouseWheelWHEEL_DIRECTIONCompletion.documentation = new vscode.MarkdownString('Richtung, in die gescrollt werden soll. Erlaubt sind \'UP\' und \'DOWN\'.');
                items.push(scrollMouseWheelWHEEL_DIRECTIONCompletion);
                const scrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion = new vscode.CompletionItem('NUMBER_OF_WHEEL_TURNS');
                scrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion.kind = vscode.CompletionItemKind.Field;
                scrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion.insertText = new vscode.SnippetString("NUMBER_OF_WHEEL_TURNS = \"${1}\"");
                scrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion.documentation = new vscode.MarkdownString('Anzahl der Bewegungen des Mausrads in die gew\u00FCnschte Richtung (Ganzzahl)');
                items.push(scrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion);
                const scrollMouseWheelMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                scrollMouseWheelMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                scrollMouseWheelMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                scrollMouseWheelMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(scrollMouseWheelMATCH_MODECompletion);
            }
            if (/.*\s*scrollToElementInGridWeb\s*\(.*/.test(linePrefix)) {
                const scrollToElementInGridWebBY_CRITERIA_GRIDCompletion = new vscode.CompletionItem('BY_CRITERIA_GRID');
                scrollToElementInGridWebBY_CRITERIA_GRIDCompletion.kind = vscode.CompletionItemKind.Field;
                scrollToElementInGridWebBY_CRITERIA_GRIDCompletion.insertText = new vscode.SnippetString("BY_CRITERIA_GRID = \"${1}\"");
                scrollToElementInGridWebBY_CRITERIA_GRIDCompletion.documentation = new vscode.MarkdownString('Kriterium, um das Grid zu finden. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden.');
                items.push(scrollToElementInGridWebBY_CRITERIA_GRIDCompletion);
                const scrollToElementInGridWebELEMENT_NAME_GRIDCompletion = new vscode.CompletionItem('ELEMENT_NAME_GRID');
                scrollToElementInGridWebELEMENT_NAME_GRIDCompletion.kind = vscode.CompletionItemKind.Field;
                scrollToElementInGridWebELEMENT_NAME_GRIDCompletion.insertText = new vscode.SnippetString("ELEMENT_NAME_GRID = \"${1}\"");
                scrollToElementInGridWebELEMENT_NAME_GRIDCompletion.documentation = new vscode.MarkdownString('Inhalt des Kriteriums f\u00FCr das Grid.');
                items.push(scrollToElementInGridWebELEMENT_NAME_GRIDCompletion);
                const scrollToElementInGridWebBY_CRITERIA_ELEMENTCompletion = new vscode.CompletionItem('BY_CRITERIA_ELEMENT');
                scrollToElementInGridWebBY_CRITERIA_ELEMENTCompletion.kind = vscode.CompletionItemKind.Field;
                scrollToElementInGridWebBY_CRITERIA_ELEMENTCompletion.insertText = new vscode.SnippetString("BY_CRITERIA_ELEMENT = \"${1}\"");
                scrollToElementInGridWebBY_CRITERIA_ELEMENTCompletion.documentation = new vscode.MarkdownString('Kriterium, um das Element innerhalb des Grid zu finden.');
                items.push(scrollToElementInGridWebBY_CRITERIA_ELEMENTCompletion);
                const scrollToElementInGridWebELEMENT_NAME_ELEMENTCompletion = new vscode.CompletionItem('ELEMENT_NAME_ELEMENT');
                scrollToElementInGridWebELEMENT_NAME_ELEMENTCompletion.kind = vscode.CompletionItemKind.Field;
                scrollToElementInGridWebELEMENT_NAME_ELEMENTCompletion.insertText = new vscode.SnippetString("ELEMENT_NAME_ELEMENT = \"${1}\"");
                scrollToElementInGridWebELEMENT_NAME_ELEMENTCompletion.documentation = new vscode.MarkdownString('Inhalt des Kriteriums f\u00FCr das Element.');
                items.push(scrollToElementInGridWebELEMENT_NAME_ELEMENTCompletion);
            }
            if (/.*\s*scrollToElementWeb\s*\(.*/.test(linePrefix)) {
                const scrollToElementWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                scrollToElementWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                scrollToElementWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                scrollToElementWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(scrollToElementWebBY_CRITERIACompletion);
                const scrollToElementWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                scrollToElementWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                scrollToElementWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                scrollToElementWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Inhalt des Kriteriums.');
                items.push(scrollToElementWebELEMENT_NAMECompletion);
            }
            if (/.*\s*scrollToWeb\s*\(.*/.test(linePrefix)) {
                const scrollToWebXCompletion = new vscode.CompletionItem('X');
                scrollToWebXCompletion.kind = vscode.CompletionItemKind.Field;
                scrollToWebXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                scrollToWebXCompletion.documentation = new vscode.MarkdownString('Absoluter Pixel-Wert auf horizontaler Achse.');
                items.push(scrollToWebXCompletion);
                const scrollToWebYCompletion = new vscode.CompletionItem('Y');
                scrollToWebYCompletion.kind = vscode.CompletionItemKind.Field;
                scrollToWebYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                scrollToWebYCompletion.documentation = new vscode.MarkdownString('Absoluter Pixel-Wert auf vertikaler Achse.');
                items.push(scrollToWebYCompletion);
            }
            if (/.*\s*scrollUpMobile\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*scrollWeb\s*\(.*/.test(linePrefix)) {
                const scrollWebSCROLL_AMOUNT_XCompletion = new vscode.CompletionItem('SCROLL_AMOUNT_X');
                scrollWebSCROLL_AMOUNT_XCompletion.kind = vscode.CompletionItemKind.Field;
                scrollWebSCROLL_AMOUNT_XCompletion.insertText = new vscode.SnippetString("SCROLL_AMOUNT_X = \"${1}\"");
                scrollWebSCROLL_AMOUNT_XCompletion.documentation = new vscode.MarkdownString('Positiver Wert: Nach rechts. Negativer Wert: Nach links.');
                items.push(scrollWebSCROLL_AMOUNT_XCompletion);
                const scrollWebSCROLL_AMOUNT_YCompletion = new vscode.CompletionItem('SCROLL_AMOUNT_Y');
                scrollWebSCROLL_AMOUNT_YCompletion.kind = vscode.CompletionItemKind.Field;
                scrollWebSCROLL_AMOUNT_YCompletion.insertText = new vscode.SnippetString("SCROLL_AMOUNT_Y = \"${1}\"");
                scrollWebSCROLL_AMOUNT_YCompletion.documentation = new vscode.MarkdownString('Positiver Wert: Nach unten. Negativer Wert: Nach oben.');
                items.push(scrollWebSCROLL_AMOUNT_YCompletion);
            }
            if (/.*\s*selectElementDropDownWinEle\s*\(.*/.test(linePrefix)) {
                const selectElementDropDownWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                selectElementDropDownWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                selectElementDropDownWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                selectElementDropDownWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(selectElementDropDownWinEleWINDOW_NAMECompletion);
                const selectElementDropDownWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                selectElementDropDownWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                selectElementDropDownWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                selectElementDropDownWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(selectElementDropDownWinElePROCESS_NAMECompletion);
                const selectElementDropDownWinEleDROPDOWN_NAMECompletion = new vscode.CompletionItem('DROPDOWN_NAME');
                selectElementDropDownWinEleDROPDOWN_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                selectElementDropDownWinEleDROPDOWN_NAMECompletion.insertText = new vscode.SnippetString("DROPDOWN_NAME = \"${1}\"");
                selectElementDropDownWinEleDROPDOWN_NAMECompletion.documentation = new vscode.MarkdownString('Name des Dropdown Men\u00FCs, das gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(selectElementDropDownWinEleDROPDOWN_NAMECompletion);
                const selectElementDropDownWinEleELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                selectElementDropDownWinEleELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                selectElementDropDownWinEleELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                selectElementDropDownWinEleELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Name des Elementes aus dem Men\u00FC, das ausgew\u00E4hlt werden soll.');
                items.push(selectElementDropDownWinEleELEMENT_NAMECompletion);
                const selectElementDropDownWinEleDROPDOWN_INDEXCompletion = new vscode.CompletionItem('DROPDOWN_INDEX');
                selectElementDropDownWinEleDROPDOWN_INDEXCompletion.kind = vscode.CompletionItemKind.Field;
                selectElementDropDownWinEleDROPDOWN_INDEXCompletion.insertText = new vscode.SnippetString("DROPDOWN_INDEX = \"${1}\"");
                selectElementDropDownWinEleDROPDOWN_INDEXCompletion.documentation = new vscode.MarkdownString('Alternativ zum Namen kann ein Index angegeben werden, der sich auf alle Dropdown-menues des Fensers bezieht.');
                items.push(selectElementDropDownWinEleDROPDOWN_INDEXCompletion);
            }
            if (/.*\s*selectItemByTextJava\s*\(.*/.test(linePrefix)) {
                const selectItemByTextJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                selectItemByTextJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                selectItemByTextJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                selectItemByTextJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(selectItemByTextJavaTARGETCompletion);
                const selectItemByTextJavaTEXTCompletion = new vscode.CompletionItem('TEXT');
                selectItemByTextJavaTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                selectItemByTextJavaTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                selectItemByTextJavaTEXTCompletion.documentation = new vscode.MarkdownString('Text, welcher in dem Element geklickt werden soll');
                items.push(selectItemByTextJavaTEXTCompletion);
                const selectItemByTextJavaOFFSETCompletion = new vscode.CompletionItem('OFFSET');
                selectItemByTextJavaOFFSETCompletion.kind = vscode.CompletionItemKind.Field;
                selectItemByTextJavaOFFSETCompletion.insertText = new vscode.SnippetString("OFFSET = \"${1}\"");
                selectItemByTextJavaOFFSETCompletion.documentation = new vscode.MarkdownString('Offset falls mehrere Elemente existieren');
                items.push(selectItemByTextJavaOFFSETCompletion);
                const selectItemByTextJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                selectItemByTextJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                selectItemByTextJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                selectItemByTextJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(selectItemByTextJavaWAIT_MILLISCompletion);
                const selectItemByTextJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                selectItemByTextJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                selectItemByTextJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                selectItemByTextJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(selectItemByTextJavaBY_NAMECompletion);
                const selectItemByTextJavaCONTAINSCompletion = new vscode.CompletionItem('CONTAINS');
                selectItemByTextJavaCONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                selectItemByTextJavaCONTAINSCompletion.insertText = new vscode.SnippetString("CONTAINS = \"${1}\"");
                selectItemByTextJavaCONTAINSCompletion.documentation = new vscode.MarkdownString('True, falls eine Zeichenreihenfolge eine Teilzeichenfolge enth\u00E4lt');
                items.push(selectItemByTextJavaCONTAINSCompletion);
            }
            if (/.*\s*selectJava\s*\(.*/.test(linePrefix)) {
                const selectJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                selectJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                selectJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                selectJavaTARGETCompletion.documentation = new vscode.MarkdownString('Bezeichner oder Name der Component die angesprochen werden soll.');
                items.push(selectJavaTARGETCompletion);
                const selectJavaINDEXCompletion = new vscode.CompletionItem('INDEX');
                selectJavaINDEXCompletion.kind = vscode.CompletionItemKind.Field;
                selectJavaINDEXCompletion.insertText = new vscode.SnippetString("INDEX = \"${1}\"");
                selectJavaINDEXCompletion.documentation = new vscode.MarkdownString('Index des auszuw\u00E4hlenden Tree oder List Eintrages.');
                items.push(selectJavaINDEXCompletion);
                const selectJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                selectJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                selectJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                selectJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Wartezeit, bis Component gefunden wurde.');
                items.push(selectJavaWAIT_MILLISCompletion);
                const selectJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                selectJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                selectJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                selectJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Soll auf das Element \u00FCber den Namen zugegriffen werden? Default: Nein.');
                items.push(selectJavaBY_NAMECompletion);
            }
            if (/.*\s*selectMobile\s*\(.*/.test(linePrefix)) {
                const selectMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                selectMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                selectMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                selectMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(selectMobileBY_CRITERIACompletion);
                const selectMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                selectMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                selectMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                selectMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(selectMobileEXPRESSION_TEXTCompletion);
                const selectMobileSELECT_LABELCompletion = new vscode.CompletionItem('SELECT_LABEL');
                selectMobileSELECT_LABELCompletion.kind = vscode.CompletionItemKind.Field;
                selectMobileSELECT_LABELCompletion.insertText = new vscode.SnippetString("SELECT_LABEL = \"${1}\"");
                selectMobileSELECT_LABELCompletion.documentation = new vscode.MarkdownString('Der Parameter muss mit dem Inhalt des Eintrages in der Liste belegt werden, die sich \u00F6ffnet.');
                items.push(selectMobileSELECT_LABELCompletion);
                const selectMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                selectMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                selectMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                selectMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt an, wie lange vor dem Select gewartet werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(selectMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*selectWeb\s*\(.*/.test(linePrefix)) {
                const selectWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                selectWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                selectWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                selectWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(selectWebBY_CRITERIACompletion);
                const selectWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                selectWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                selectWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                selectWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(selectWebELEMENT_NAMECompletion);
                const selectWebSELECT_LABELCompletion = new vscode.CompletionItem('SELECT_LABEL');
                selectWebSELECT_LABELCompletion.kind = vscode.CompletionItemKind.Field;
                selectWebSELECT_LABELCompletion.insertText = new vscode.SnippetString("SELECT_LABEL = \"${1}\"");
                selectWebSELECT_LABELCompletion.documentation = new vscode.MarkdownString('Der Text der Select-Option, also des auszuw\u00E4hlenden Elements. Kann keine Option mit diesem Text gefunden oder ausgew\u00E4hlt werden, schlie\u00DFt das Kommando mit einem Fehler ab.');
                items.push(selectWebSELECT_LABELCompletion);
                const selectWebMAX_CHECK_ATTEMPTSCompletion = new vscode.CompletionItem('MAX_CHECK_ATTEMPTS');
                selectWebMAX_CHECK_ATTEMPTSCompletion.kind = vscode.CompletionItemKind.Field;
                selectWebMAX_CHECK_ATTEMPTSCompletion.insertText = new vscode.SnippetString("MAX_CHECK_ATTEMPTS = \"${1}\"");
                selectWebMAX_CHECK_ATTEMPTSCompletion.documentation = new vscode.MarkdownString('Kann der ausgew\u00E4hlte Text aufgrund eines Fehlers nicht ausgelesen werden, so wird dies so oft erneut versucht wie hier angegeben. (Default: 3 Versuche)');
                items.push(selectWebMAX_CHECK_ATTEMPTSCompletion);
                const selectWebWAIT_BETWEEN_CHECK_ATTEMPTS_SECONDSCompletion = new vscode.CompletionItem('WAIT_BETWEEN_CHECK_ATTEMPTS_SECONDS');
                selectWebWAIT_BETWEEN_CHECK_ATTEMPTS_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                selectWebWAIT_BETWEEN_CHECK_ATTEMPTS_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_BETWEEN_CHECK_ATTEMPTS_SECONDS = \"${1}\"");
                selectWebWAIT_BETWEEN_CHECK_ATTEMPTS_SECONDSCompletion.documentation = new vscode.MarkdownString('Wartezeit zwischen den in MAX_CHECK_ATTEMPTS spezifizierten Versuchen in Sekunden (Default: 3 Sekunden)');
                items.push(selectWebWAIT_BETWEEN_CHECK_ATTEMPTS_SECONDSCompletion);
                const selectWebNO_CHECKCompletion = new vscode.CompletionItem('NO_CHECK');
                selectWebNO_CHECKCompletion.kind = vscode.CompletionItemKind.Field;
                selectWebNO_CHECKCompletion.insertText = new vscode.SnippetString("NO_CHECK = \"${1}\"");
                selectWebNO_CHECKCompletion.documentation = new vscode.MarkdownString('Wenn true, wird nach der Auswahl nicht gepr\u00FCft, ob die nun bestehende Auswahl tats\u00E4chlich dem erwarteten Wert entspricht (Default: false)');
                items.push(selectWebNO_CHECKCompletion);
            }
            if (/.*\s*sendMail\s*\(.*/.test(linePrefix)) {
                const sendMailSERVERCompletion = new vscode.CompletionItem('SERVER');
                sendMailSERVERCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailSERVERCompletion.insertText = new vscode.SnippetString("SERVER = \"${1}\"");
                sendMailSERVERCompletion.documentation = new vscode.MarkdownString('Servername des Mailanbieters.');
                items.push(sendMailSERVERCompletion);
                const sendMailUSERCompletion = new vscode.CompletionItem('USER');
                sendMailUSERCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailUSERCompletion.insertText = new vscode.SnippetString("USER = \"${1}\"");
                sendMailUSERCompletion.documentation = new vscode.MarkdownString('Benutzername f\u00FCr das Mailkonto');
                items.push(sendMailUSERCompletion);
                const sendMailPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                sendMailPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                sendMailPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr das Mailkonto');
                items.push(sendMailPASSWORDCompletion);
                const sendMailSUBJECTCompletion = new vscode.CompletionItem('SUBJECT');
                sendMailSUBJECTCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailSUBJECTCompletion.insertText = new vscode.SnippetString("SUBJECT = \"${1}\"");
                sendMailSUBJECTCompletion.documentation = new vscode.MarkdownString('Betreff der Mail.');
                items.push(sendMailSUBJECTCompletion);
                const sendMailCONTENTCompletion = new vscode.CompletionItem('CONTENT');
                sendMailCONTENTCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailCONTENTCompletion.insertText = new vscode.SnippetString("CONTENT = \"${1}\"");
                sendMailCONTENTCompletion.documentation = new vscode.MarkdownString('Inhalt der Mail.');
                items.push(sendMailCONTENTCompletion);
                const sendMailSENDERCompletion = new vscode.CompletionItem('SENDER');
                sendMailSENDERCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailSENDERCompletion.insertText = new vscode.SnippetString("SENDER = \"${1}\"");
                sendMailSENDERCompletion.documentation = new vscode.MarkdownString('Mail-Adresse des Sendenden');
                items.push(sendMailSENDERCompletion);
                const sendMailRECEIVERCompletion = new vscode.CompletionItem('RECEIVER');
                sendMailRECEIVERCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailRECEIVERCompletion.insertText = new vscode.SnippetString("RECEIVER = \"${1}\"");
                sendMailRECEIVERCompletion.documentation = new vscode.MarkdownString('Mail-Adresse des Empfangenden. K\u00F6nnen Kommasepariert mehrere sein');
                items.push(sendMailRECEIVERCompletion);
                const sendMailPORTCompletion = new vscode.CompletionItem('PORT');
                sendMailPORTCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailPORTCompletion.insertText = new vscode.SnippetString("PORT = \"${1}\"");
                sendMailPORTCompletion.documentation = new vscode.MarkdownString('Port des MailServers');
                items.push(sendMailPORTCompletion);
                const sendMailATTACHMENT_LOCATIONCompletion = new vscode.CompletionItem('ATTACHMENT_LOCATION');
                sendMailATTACHMENT_LOCATIONCompletion.kind = vscode.CompletionItemKind.Field;
                sendMailATTACHMENT_LOCATIONCompletion.insertText = new vscode.SnippetString("ATTACHMENT_LOCATION = \"${1}\"");
                sendMailATTACHMENT_LOCATIONCompletion.documentation = new vscode.MarkdownString('Pfade an denen Dateien liegen, die der E-Mail als Anh\u00E4nge beigef\u00FCgt werden sollen. Diese werden dabei separiert mit Kommata angegeben. Bsp.: \'C:\\Temp\\Datei_1.txt, C:\\Dokumente\\Datei Zwei.csv\'. Entsprechend muss sichergestellt werden, dass Dateipfade und Namen keine weiteren Kommata enthalten, da sonst an diesen Stellen \'geschnitten\' w\u00FCrde.');
                items.push(sendMailATTACHMENT_LOCATIONCompletion);
            }
            if (/.*\s*sendTextAutomIdWinEle\s*\(.*/.test(linePrefix)) {
                const sendTextAutomIdWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                sendTextAutomIdWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextAutomIdWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                sendTextAutomIdWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(sendTextAutomIdWinEleWINDOW_NAMECompletion);
                const sendTextAutomIdWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                sendTextAutomIdWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextAutomIdWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                sendTextAutomIdWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(sendTextAutomIdWinElePROCESS_NAMECompletion);
                const sendTextAutomIdWinEleTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextAutomIdWinEleTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextAutomIdWinEleTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextAutomIdWinEleTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Zu sendender Text.');
                items.push(sendTextAutomIdWinEleTEXT_TO_SENDCompletion);
                const sendTextAutomIdWinEleTEXT_BOX_AUTOMATION_IDCompletion = new vscode.CompletionItem('TEXT_BOX_AUTOMATION_ID');
                sendTextAutomIdWinEleTEXT_BOX_AUTOMATION_IDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextAutomIdWinEleTEXT_BOX_AUTOMATION_IDCompletion.insertText = new vscode.SnippetString("TEXT_BOX_AUTOMATION_ID = \"${1}\"");
                sendTextAutomIdWinEleTEXT_BOX_AUTOMATION_IDCompletion.documentation = new vscode.MarkdownString('Automation-ID des Eingabeelements, dem ein Text gesendet werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diese zu ermitteln.');
                items.push(sendTextAutomIdWinEleTEXT_BOX_AUTOMATION_IDCompletion);
            }
            if (/.*\s*sendTextByPaste\s*\(.*/.test(linePrefix)) {
                const sendTextByPasteWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                sendTextByPasteWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextByPasteWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                sendTextByPasteWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(sendTextByPasteWINDOW_NAMECompletion);
                const sendTextByPasteTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextByPasteTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextByPasteTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextByPasteTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('zu sendender (schreibender) Text');
                items.push(sendTextByPasteTEXT_TO_SENDCompletion);
                const sendTextByPasteMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                sendTextByPasteMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextByPasteMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                sendTextByPasteMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(sendTextByPasteMATCH_MODECompletion);
            }
            if (/.*\s*sendTextCP\s*\(.*/.test(linePrefix)) {
                const sendTextCPTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextCPTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextCPTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextCPTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Der zu sendende Text');
                items.push(sendTextCPTEXT_TO_SENDCompletion);
            }
            if (/.*\s*sendTextClassnameWinEle\s*\(.*/.test(linePrefix)) {
                const sendTextClassnameWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                sendTextClassnameWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextClassnameWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                sendTextClassnameWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(sendTextClassnameWinEleWINDOW_NAMECompletion);
                const sendTextClassnameWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                sendTextClassnameWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextClassnameWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                sendTextClassnameWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(sendTextClassnameWinElePROCESS_NAMECompletion);
                const sendTextClassnameWinEleTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextClassnameWinEleTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextClassnameWinEleTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextClassnameWinEleTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Zu sendender Text. Wenn kein Text angegeben, wird das Textfeld fokussiert.');
                items.push(sendTextClassnameWinEleTEXT_TO_SENDCompletion);
                const sendTextClassnameWinEleCLASS_NAMECompletion = new vscode.CompletionItem('CLASS_NAME');
                sendTextClassnameWinEleCLASS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextClassnameWinEleCLASS_NAMECompletion.insertText = new vscode.SnippetString("CLASS_NAME = \"${1}\"");
                sendTextClassnameWinEleCLASS_NAMECompletion.documentation = new vscode.MarkdownString('Klasse des Elements. Der genaue name kann z.B. mit \'UISpy\' ermittelt werden.');
                items.push(sendTextClassnameWinEleCLASS_NAMECompletion);
                const sendTextClassnameWinEleINDEXCompletion = new vscode.CompletionItem('INDEX');
                sendTextClassnameWinEleINDEXCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextClassnameWinEleINDEXCompletion.insertText = new vscode.SnippetString("INDEX = \"${1}\"");
                sendTextClassnameWinEleINDEXCompletion.documentation = new vscode.MarkdownString('Index, wenn mehrere Elemente mit gleicher Kennung existieren.');
                items.push(sendTextClassnameWinEleINDEXCompletion);
            }
            if (/.*\s*sendTextJava\s*\(.*/.test(linePrefix)) {
                const sendTextJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                sendTextJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                sendTextJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(sendTextJavaTARGETCompletion);
                const sendTextJavaTEXTCompletion = new vscode.CompletionItem('TEXT');
                sendTextJavaTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextJavaTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                sendTextJavaTEXTCompletion.documentation = new vscode.MarkdownString('Zu setzender Text');
                items.push(sendTextJavaTEXTCompletion);
                const sendTextJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                sendTextJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                sendTextJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(sendTextJavaWAIT_MILLISCompletion);
                const sendTextJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                sendTextJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                sendTextJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(sendTextJavaBY_NAMECompletion);
                const sendTextJavaTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sendTextJavaTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextJavaTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sendTextJavaTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Optionaler Key im Storage um den R\u00FCckgabewert zu speichern');
                items.push(sendTextJavaTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sendTextMobile\s*\(.*/.test(linePrefix)) {
                const sendTextMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                sendTextMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                sendTextMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                sendTextMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(sendTextMobileBY_CRITERIACompletion);
                const sendTextMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                sendTextMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                sendTextMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(sendTextMobileEXPRESSION_TEXTCompletion);
                const sendTextMobileTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextMobileTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextMobileTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextMobileTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt den Text an, der an das Element gesendet werden soll.');
                items.push(sendTextMobileTEXT_TO_SENDCompletion);
                const sendTextMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                sendTextMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                sendTextMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange werden soll bis der Text gesendet wird. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(sendTextMobileWAIT_SECONDSCompletion);
                const sendTextMobileCLEAR_BEFORE_SENDCompletion = new vscode.CompletionItem('CLEAR_BEFORE_SEND');
                sendTextMobileCLEAR_BEFORE_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextMobileCLEAR_BEFORE_SENDCompletion.insertText = new vscode.SnippetString("CLEAR_BEFORE_SEND = \"${1}\"");
                sendTextMobileCLEAR_BEFORE_SENDCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit \'true\' oder \'false\' belegt werden kann und gibt an, ob der alte Text des Elements gel\u00F6scht werden soll.');
                items.push(sendTextMobileCLEAR_BEFORE_SENDCompletion);
            }
            if (/.*\s*sendTextRaw\s*\(.*/.test(linePrefix)) {
                const sendTextRawTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextRawTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextRawTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextRawTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('zu sendender (schreibender) Text');
                items.push(sendTextRawTEXT_TO_SENDCompletion);
            }
            if (/.*\s*sendTextWeb\s*\(.*/.test(linePrefix)) {
                const sendTextWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                sendTextWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                sendTextWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(sendTextWebBY_CRITERIACompletion);
                const sendTextWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                sendTextWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                sendTextWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(sendTextWebELEMENT_NAMECompletion);
                const sendTextWebTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextWebTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextWebTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('In das Element zu schreibender Text. Wenn der TEXT_TO_SEND den Druck einer bestimmten Taste (anstelle eines ganzen Texts) ausl\u00F6sen soll, muss der Name dieser Taste dem jew. Wert des ENUM org.openqa.selenium.Keys entsprechen und ist in geschweifte Klammern zu setzten.       Um z. B. KEYS.BACK_SPACE auszul\u00F6sen, ist hier {BACK_SPACE} einzugeben. Hinweis, die Taste wird gedr\u00FCckt gehalten, bis {NULL} \u00FCbergeben wird');
                items.push(sendTextWebTEXT_TO_SENDCompletion);
                const sendTextWebDELETE_BEFORE_SENDCompletion = new vscode.CompletionItem('DELETE_BEFORE_SEND');
                sendTextWebDELETE_BEFORE_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebDELETE_BEFORE_SENDCompletion.insertText = new vscode.SnippetString("DELETE_BEFORE_SEND = \"${1}\"");
                sendTextWebDELETE_BEFORE_SENDCompletion.documentation = new vscode.MarkdownString('{true, false} \u00DCber diesen Parameter wird der Inhalt des Elements gel\u00F6scht. Default: false.');
                items.push(sendTextWebDELETE_BEFORE_SENDCompletion);
                const sendTextWebBACKSPACE_COUNTCompletion = new vscode.CompletionItem('BACKSPACE_COUNT');
                sendTextWebBACKSPACE_COUNTCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebBACKSPACE_COUNTCompletion.insertText = new vscode.SnippetString("BACKSPACE_COUNT = \"${1}\"");
                sendTextWebBACKSPACE_COUNTCompletion.documentation = new vscode.MarkdownString('Manche Elemente k\u00F6nnen nicht \u00FCber den Parameter \'DELETE_BEFORE_SEND\' gel\u00F6scht werden. \u00DCber die hiermit \u00FCbergebene Anzahl \'Backspace\' wird der Inhalt \u00FCber Tastendr\u00FCcke gel\u00F6scht.');
                items.push(sendTextWebBACKSPACE_COUNTCompletion);
                const sendTextWebNEXT_ELEMENT_BY_CRITERIACompletion = new vscode.CompletionItem('NEXT_ELEMENT_BY_CRITERIA');
                sendTextWebNEXT_ELEMENT_BY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebNEXT_ELEMENT_BY_CRITERIACompletion.insertText = new vscode.SnippetString("NEXT_ELEMENT_BY_CRITERIA = \"${1}\"");
                sendTextWebNEXT_ELEMENT_BY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriteriium, \u00FCber das das n\u00E4chste Element ermittelt werden soll.');
                items.push(sendTextWebNEXT_ELEMENT_BY_CRITERIACompletion);
                const sendTextWebNEXT_ELEMENT_NAMECompletion = new vscode.CompletionItem('NEXT_ELEMENT_NAME');
                sendTextWebNEXT_ELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebNEXT_ELEMENT_NAMECompletion.insertText = new vscode.SnippetString("NEXT_ELEMENT_NAME = \"${1}\"");
                sendTextWebNEXT_ELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Name des n\u00E4chsten Elements, das nach dem Klicken auf das eigentliche Element verf\u00FCgbar sein soll.');
                items.push(sendTextWebNEXT_ELEMENT_NAMECompletion);
                const sendTextWebWAIT_AFTER_NEXT_ELEMENTCompletion = new vscode.CompletionItem('WAIT_AFTER_NEXT_ELEMENT');
                sendTextWebWAIT_AFTER_NEXT_ELEMENTCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebWAIT_AFTER_NEXT_ELEMENTCompletion.insertText = new vscode.SnippetString("WAIT_AFTER_NEXT_ELEMENT = \"${1}\"");
                sendTextWebWAIT_AFTER_NEXT_ELEMENTCompletion.documentation = new vscode.MarkdownString('Wartet auf ein Element.');
                items.push(sendTextWebWAIT_AFTER_NEXT_ELEMENTCompletion);
                const sendTextWebTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                sendTextWebTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                sendTextWebTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Der Schl\u00FCssel \u00FCber den der zu sendende Text ermittelt wird.');
                items.push(sendTextWebTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*sendTextWebByPaste\s*\(.*/.test(linePrefix)) {
                const sendTextWebByPasteBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                sendTextWebByPasteBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebByPasteBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                sendTextWebByPasteBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(sendTextWebByPasteBY_CRITERIACompletion);
                const sendTextWebByPasteELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                sendTextWebByPasteELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebByPasteELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                sendTextWebByPasteELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(sendTextWebByPasteELEMENT_NAMECompletion);
                const sendTextWebByPasteTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextWebByPasteTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebByPasteTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextWebByPasteTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('In das Element zu schreibender Text.');
                items.push(sendTextWebByPasteTEXT_TO_SENDCompletion);
                const sendTextWebByPasteDELETE_BEFORE_SENDCompletion = new vscode.CompletionItem('DELETE_BEFORE_SEND');
                sendTextWebByPasteDELETE_BEFORE_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebByPasteDELETE_BEFORE_SENDCompletion.insertText = new vscode.SnippetString("DELETE_BEFORE_SEND = \"${1}\"");
                sendTextWebByPasteDELETE_BEFORE_SENDCompletion.documentation = new vscode.MarkdownString('{true, false} Wenn true, wird der Inhalt des Web-Elements gel\u00F6scht, bevor der Text an das Element gesendet wird. Default: false.');
                items.push(sendTextWebByPasteDELETE_BEFORE_SENDCompletion);
                const sendTextWebByPasteBACKSPACE_COUNTCompletion = new vscode.CompletionItem('BACKSPACE_COUNT');
                sendTextWebByPasteBACKSPACE_COUNTCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebByPasteBACKSPACE_COUNTCompletion.insertText = new vscode.SnippetString("BACKSPACE_COUNT = \"${1}\"");
                sendTextWebByPasteBACKSPACE_COUNTCompletion.documentation = new vscode.MarkdownString('In manchen F\u00E4llen, k\u00F6nnen Elemente k\u00F6nnen nicht \u00FCber den Parameter \'DELETE_BEFORE_SEND\' geleert werden.       Wird hier eine Zahl \u00FCbergeben, wird die \'Backspace\'-Taste vor dem Senden des Texts entsprechend h\u00E4ufig gedr\u00FCckt.      Somit gibt BACKSPACE_COUNT die Anzahl der zu l\u00F6schenden Zeichen des alten Textes vor Einf\u00FCgen des neuen Textes an.');
                items.push(sendTextWebByPasteBACKSPACE_COUNTCompletion);
            }
            if (/.*\s*sendTextWebFast\s*\(.*/.test(linePrefix)) {
                const sendTextWebFastBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                sendTextWebFastBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebFastBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                sendTextWebFastBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(sendTextWebFastBY_CRITERIACompletion);
                const sendTextWebFastELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                sendTextWebFastELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebFastELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                sendTextWebFastELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(sendTextWebFastELEMENT_NAMECompletion);
                const sendTextWebFastTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextWebFastTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebFastTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextWebFastTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('In das Element zu schreibender Text. Wenn der TEXT_TO_SEND den Druck einer bestimmten Taste (anstelle eines ganzen Texts) ausl\u00F6sen soll, muss der Name dieser Taste dem jew. Wert des ENUM org.openqa.selenium.Keys entsprechen und ist in geschweifte Klammern zu setzten.       Um z. B. KEYS.BACK_SPACE auszul\u00F6sen, ist hier {BACK_SPACE} einzugeben. Hinweis, die Taste wird gedr\u00FCckt gehalten, bis {NULL} \u00FCbergeben wird');
                items.push(sendTextWebFastTEXT_TO_SENDCompletion);
                const sendTextWebFastDELETE_BEFORE_SENDCompletion = new vscode.CompletionItem('DELETE_BEFORE_SEND');
                sendTextWebFastDELETE_BEFORE_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebFastDELETE_BEFORE_SENDCompletion.insertText = new vscode.SnippetString("DELETE_BEFORE_SEND = \"${1}\"");
                sendTextWebFastDELETE_BEFORE_SENDCompletion.documentation = new vscode.MarkdownString('{true, false} Wenn true, wird der Inhalt des Web-Elements gel\u00F6scht, bevor der Text an das Element gesendet wird. Default: false.');
                items.push(sendTextWebFastDELETE_BEFORE_SENDCompletion);
                const sendTextWebFastBACKSPACE_COUNTCompletion = new vscode.CompletionItem('BACKSPACE_COUNT');
                sendTextWebFastBACKSPACE_COUNTCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWebFastBACKSPACE_COUNTCompletion.insertText = new vscode.SnippetString("BACKSPACE_COUNT = \"${1}\"");
                sendTextWebFastBACKSPACE_COUNTCompletion.documentation = new vscode.MarkdownString('In manchen F\u00E4llen, k\u00F6nnen Elemente k\u00F6nnen nicht \u00FCber den Parameter \'DELETE_BEFORE_SEND\' geleert werden.       Wird hier eine Zahl \u00FCbergeben, wird die \'Backspace\'-Taste vor dem Senden des Texts entsprechend h\u00E4ufig gedr\u00FCckt.      Somit gibt BACKSPACE_COUNT die Anzahl der zu l\u00F6schenden Zeichen des alten Textes vor Einf\u00FCgen des neuen Textes an.');
                items.push(sendTextWebFastBACKSPACE_COUNTCompletion);
            }
            if (/.*\s*sendTextWin\s*\(.*/.test(linePrefix)) {
                const sendTextWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                sendTextWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                sendTextWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, an das der Text zu senden ist.');
                items.push(sendTextWinWINDOW_NAMECompletion);
                const sendTextWinTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextWinTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWinTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextWinTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Zu sendender Text');
                items.push(sendTextWinTEXT_TO_SENDCompletion);
                const sendTextWinDELAYCompletion = new vscode.CompletionItem('DELAY');
                sendTextWinDELAYCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWinDELAYCompletion.insertText = new vscode.SnippetString("DELAY = \"${1}\"");
                sendTextWinDELAYCompletion.documentation = new vscode.MarkdownString('Verz\u00F6gerung vor dem Senden (in Millisekunden)');
                items.push(sendTextWinDELAYCompletion);
                const sendTextWinMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                sendTextWinMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWinMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                sendTextWinMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(sendTextWinMATCH_MODECompletion);
            }
            if (/.*\s*sendTextWinEle\s*\(.*/.test(linePrefix)) {
                const sendTextWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                sendTextWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                sendTextWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(sendTextWinEleWINDOW_NAMECompletion);
                const sendTextWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                sendTextWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                sendTextWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(sendTextWinElePROCESS_NAMECompletion);
                const sendTextWinEleTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextWinEleTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWinEleTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextWinEleTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Zu sendender Text.');
                items.push(sendTextWinEleTEXT_TO_SENDCompletion);
                const sendTextWinEleTEXT_BOX_NAMECompletion = new vscode.CompletionItem('TEXT_BOX_NAME');
                sendTextWinEleTEXT_BOX_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWinEleTEXT_BOX_NAMECompletion.insertText = new vscode.SnippetString("TEXT_BOX_NAME = \"${1}\"");
                sendTextWinEleTEXT_BOX_NAMECompletion.documentation = new vscode.MarkdownString('Name der Textbox, die gesteuert werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diesen zu ermitteln.');
                items.push(sendTextWinEleTEXT_BOX_NAMECompletion);
            }
            if (/.*\s*sendTextWindowWin\s*\(.*/.test(linePrefix)) {
                const sendTextWindowWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                sendTextWindowWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWindowWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                sendTextWindowWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(sendTextWindowWinWINDOW_NAMECompletion);
                const sendTextWindowWinTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                sendTextWindowWinTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                sendTextWindowWinTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                sendTextWindowWinTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Zu sendender (schreibender) Text');
                items.push(sendTextWindowWinTEXT_TO_SENDCompletion);
            }
            if (/.*\s*setActiveWindowJava\s*\(.*/.test(linePrefix)) {
                const setActiveWindowJavaTITLECompletion = new vscode.CompletionItem('TITLE');
                setActiveWindowJavaTITLECompletion.kind = vscode.CompletionItemKind.Field;
                setActiveWindowJavaTITLECompletion.insertText = new vscode.SnippetString("TITLE = \"${1}\"");
                setActiveWindowJavaTITLECompletion.documentation = new vscode.MarkdownString('Titel des Fensters auf das gewechselt werden soll.');
                items.push(setActiveWindowJavaTITLECompletion);
                const setActiveWindowJavaCHECK_TITLE_CONTAINSCompletion = new vscode.CompletionItem('CHECK_TITLE_CONTAINS');
                setActiveWindowJavaCHECK_TITLE_CONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                setActiveWindowJavaCHECK_TITLE_CONTAINSCompletion.insertText = new vscode.SnippetString("CHECK_TITLE_CONTAINS = \"${1}\"");
                setActiveWindowJavaCHECK_TITLE_CONTAINSCompletion.documentation = new vscode.MarkdownString('Verwendet einen \'contains\' Vergleich bei der \u00DCberpr\u00FCfung des Titels anstatt \'ist gleich\'');
                items.push(setActiveWindowJavaCHECK_TITLE_CONTAINSCompletion);
                const setActiveWindowJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                setActiveWindowJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                setActiveWindowJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                setActiveWindowJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Wartezeit, die maximal gewartet werden soll.');
                items.push(setActiveWindowJavaWAIT_MILLISCompletion);
            }
            if (/.*\s*setAllStorageFromInput\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*setClipboardValue\s*\(.*/.test(linePrefix)) {
                const setClipboardValueVALUECompletion = new vscode.CompletionItem('VALUE');
                setClipboardValueVALUECompletion.kind = vscode.CompletionItemKind.Field;
                setClipboardValueVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                setClipboardValueVALUECompletion.documentation = new vscode.MarkdownString('Zu setzender Wert');
                items.push(setClipboardValueVALUECompletion);
            }
            if (/.*\s*setCookieWeb\s*\(.*/.test(linePrefix)) {
                const setCookieWebCOOKIE_NAMECompletion = new vscode.CompletionItem('COOKIE_NAME');
                setCookieWebCOOKIE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                setCookieWebCOOKIE_NAMECompletion.insertText = new vscode.SnippetString("COOKIE_NAME = \"${1}\"");
                setCookieWebCOOKIE_NAMECompletion.documentation = new vscode.MarkdownString('Name des zu setzenden Cookies');
                items.push(setCookieWebCOOKIE_NAMECompletion);
                const setCookieWebCOOKIE_VALUECompletion = new vscode.CompletionItem('COOKIE_VALUE');
                setCookieWebCOOKIE_VALUECompletion.kind = vscode.CompletionItemKind.Field;
                setCookieWebCOOKIE_VALUECompletion.insertText = new vscode.SnippetString("COOKIE_VALUE = \"${1}\"");
                setCookieWebCOOKIE_VALUECompletion.documentation = new vscode.MarkdownString('Wert des zu setzenden Cookies');
                items.push(setCookieWebCOOKIE_VALUECompletion);
                const setCookieWebSAME_SITE_STRICTCompletion = new vscode.CompletionItem('SAME_SITE_STRICT');
                setCookieWebSAME_SITE_STRICTCompletion.kind = vscode.CompletionItemKind.Field;
                setCookieWebSAME_SITE_STRICTCompletion.insertText = new vscode.SnippetString("SAME_SITE_STRICT = \"${1}\"");
                setCookieWebSAME_SITE_STRICTCompletion.documentation = new vscode.MarkdownString('Wenn true, wird das das Same-Site-Attribut auf den Modus \'Strict\' gesetzt. Dies bedeutet, dass das gesetzte Cookies nicht an Third-Party-Sites gesendet wird, sondern nur an die Website, f\u00FCr die das Cookie gesetzt wurde. (Default: false)');
                items.push(setCookieWebSAME_SITE_STRICTCompletion);
            }
            if (/.*\s*setProperty\s*\(.*/.test(linePrefix)) {
                const setPropertyKEYCompletion = new vscode.CompletionItem('KEY');
                setPropertyKEYCompletion.kind = vscode.CompletionItemKind.Field;
                setPropertyKEYCompletion.insertText = new vscode.SnippetString("KEY = \"${1}\"");
                setPropertyKEYCompletion.documentation = new vscode.MarkdownString('Der Schl\u00FCssel der Property');
                items.push(setPropertyKEYCompletion);
                const setPropertyVALUECompletion = new vscode.CompletionItem('VALUE');
                setPropertyVALUECompletion.kind = vscode.CompletionItemKind.Field;
                setPropertyVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                setPropertyVALUECompletion.documentation = new vscode.MarkdownString('Der Wert der Property');
                items.push(setPropertyVALUECompletion);
            }
            if (/.*\s*setStorageFromInput\s*\(.*/.test(linePrefix)) {
                const setStorageFromInputKEYCompletion = new vscode.CompletionItem('KEY');
                setStorageFromInputKEYCompletion.kind = vscode.CompletionItemKind.Field;
                setStorageFromInputKEYCompletion.insertText = new vscode.SnippetString("KEY = \"${1}\"");
                setStorageFromInputKEYCompletion.documentation = new vscode.MarkdownString('Key des Wertes welcher in den Storage geschrieben werden soll');
                items.push(setStorageFromInputKEYCompletion);
                const setStorageFromInputDEFAULTCompletion = new vscode.CompletionItem('DEFAULT');
                setStorageFromInputDEFAULTCompletion.kind = vscode.CompletionItemKind.Field;
                setStorageFromInputDEFAULTCompletion.insertText = new vscode.SnippetString("DEFAULT = \"${1}\"");
                setStorageFromInputDEFAULTCompletion.documentation = new vscode.MarkdownString('Default Wert, falls der angegebene Key nicht \u00FCbergeben wurde');
                items.push(setStorageFromInputDEFAULTCompletion);
            }
            if (/.*\s*setStorageValue\s*\(.*/.test(linePrefix)) {
                const setStorageValueVALUECompletion = new vscode.CompletionItem('VALUE');
                setStorageValueVALUECompletion.kind = vscode.CompletionItemKind.Field;
                setStorageValueVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                setStorageValueVALUECompletion.documentation = new vscode.MarkdownString('Wert der gesetzt werden soll. Bleibt der Parameter leer, wird ein Leerstring gesetzt.');
                items.push(setStorageValueVALUECompletion);
                const setStorageValueTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                setStorageValueTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                setStorageValueTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                setStorageValueTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier muss ein neuer Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(setStorageValueTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*showCommandOverlay\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*soapRequest\s*\(.*/.test(linePrefix)) {
                const soapRequestURLCompletion = new vscode.CompletionItem('URL');
                soapRequestURLCompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                soapRequestURLCompletion.documentation = new vscode.MarkdownString('URL des Webservices');
                items.push(soapRequestURLCompletion);
                const soapRequestUSERNAMECompletion = new vscode.CompletionItem('USERNAME');
                soapRequestUSERNAMECompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestUSERNAMECompletion.insertText = new vscode.SnippetString("USERNAME = \"${1}\"");
                soapRequestUSERNAMECompletion.documentation = new vscode.MarkdownString('Username f\u00FCr Webservice Call (BasicAuth)');
                items.push(soapRequestUSERNAMECompletion);
                const soapRequestPASSWORDCompletion = new vscode.CompletionItem('PASSWORD');
                soapRequestPASSWORDCompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestPASSWORDCompletion.insertText = new vscode.SnippetString("PASSWORD = \"${1}\"");
                soapRequestPASSWORDCompletion.documentation = new vscode.MarkdownString('Passwort f\u00FCr Webservice Call (BasicAuth)');
                items.push(soapRequestPASSWORDCompletion);
                const soapRequestSOAP_ACTIONCompletion = new vscode.CompletionItem('SOAP_ACTION');
                soapRequestSOAP_ACTIONCompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestSOAP_ACTIONCompletion.insertText = new vscode.SnippetString("SOAP_ACTION = \"${1}\"");
                soapRequestSOAP_ACTIONCompletion.documentation = new vscode.MarkdownString('SOAP Action');
                items.push(soapRequestSOAP_ACTIONCompletion);
                const soapRequestSOAP_BODYCompletion = new vscode.CompletionItem('SOAP_BODY');
                soapRequestSOAP_BODYCompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestSOAP_BODYCompletion.insertText = new vscode.SnippetString("SOAP_BODY = \"${1}\"");
                soapRequestSOAP_BODYCompletion.documentation = new vscode.MarkdownString('SOAP Body');
                items.push(soapRequestSOAP_BODYCompletion);
                const soapRequestSHORT_OUTPUTCompletion = new vscode.CompletionItem('SHORT_OUTPUT');
                soapRequestSHORT_OUTPUTCompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestSHORT_OUTPUTCompletion.insertText = new vscode.SnippetString("SHORT_OUTPUT = \"${1}\"");
                soapRequestSHORT_OUTPUTCompletion.documentation = new vscode.MarkdownString('kurze Ausgabe');
                items.push(soapRequestSHORT_OUTPUTCompletion);
                const soapRequestTIMEOUTCompletion = new vscode.CompletionItem('TIMEOUT');
                soapRequestTIMEOUTCompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestTIMEOUTCompletion.insertText = new vscode.SnippetString("TIMEOUT = \"${1}\"");
                soapRequestTIMEOUTCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(soapRequestTIMEOUTCompletion);
                const soapRequestTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                soapRequestTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                soapRequestTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis des Aufrufs gespeichert wird.');
                items.push(soapRequestTARGET_STORAGE_KEYCompletion);
                const soapRequestWRITE_TO_FILECompletion = new vscode.CompletionItem('WRITE_TO_FILE');
                soapRequestWRITE_TO_FILECompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestWRITE_TO_FILECompletion.insertText = new vscode.SnippetString("WRITE_TO_FILE = \"${1}\"");
                soapRequestWRITE_TO_FILECompletion.documentation = new vscode.MarkdownString('Ins Verzeichnis schreiben');
                items.push(soapRequestWRITE_TO_FILECompletion);
                const soapRequestHTTPSTATUS_STORAGE_KEYCompletion = new vscode.CompletionItem('HTTPSTATUS_STORAGE_KEY');
                soapRequestHTTPSTATUS_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                soapRequestHTTPSTATUS_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("HTTPSTATUS_STORAGE_KEY = \"${1}\"");
                soapRequestHTTPSTATUS_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann optional ein Schl\u00FCssel gesetzt werden, unter dem der Status des Aufrufsergebnisses gespeichert wird.');
                items.push(soapRequestHTTPSTATUS_STORAGE_KEYCompletion);
            }
            if (/.*\s*startActivityAndroid\s*\(.*/.test(linePrefix)) {
                const startActivityAndroidPACKAGE_CONTAINING_APPCompletion = new vscode.CompletionItem('PACKAGE_CONTAINING_APP');
                startActivityAndroidPACKAGE_CONTAINING_APPCompletion.kind = vscode.CompletionItemKind.Field;
                startActivityAndroidPACKAGE_CONTAINING_APPCompletion.insertText = new vscode.SnippetString("PACKAGE_CONTAINING_APP = \"${1}\"");
                startActivityAndroidPACKAGE_CONTAINING_APPCompletion.documentation = new vscode.MarkdownString('Name der Package Containing App. Klickt man auf den Android-Icon in Appium, \u00F6ffnen sich die Konfigurationseinstellungen und man kann diesen Parameter unter dem Reiter \'Application Path\' nachlesen.');
                items.push(startActivityAndroidPACKAGE_CONTAINING_APPCompletion);
                const startActivityAndroidACTIVITY_TO_STARTCompletion = new vscode.CompletionItem('ACTIVITY_TO_START');
                startActivityAndroidACTIVITY_TO_STARTCompletion.kind = vscode.CompletionItemKind.Field;
                startActivityAndroidACTIVITY_TO_STARTCompletion.insertText = new vscode.SnippetString("ACTIVITY_TO_START = \"${1}\"");
                startActivityAndroidACTIVITY_TO_STARTCompletion.documentation = new vscode.MarkdownString('Der Parameter muss mit dem Namen der Activity, die gestartet werden soll, belegt werden. Klickt man auf den Android-Icon in Appium, \u00F6ffnen sich die Konfigurationseinstellungen und man kann diesen Parameter unter dem Reiter \'Application Path\' nachlesen.');
                items.push(startActivityAndroidACTIVITY_TO_STARTCompletion);
                const startActivityAndroidWAIT_UNTIL_PACKAGE_STARTCompletion = new vscode.CompletionItem('WAIT_UNTIL_PACKAGE_START');
                startActivityAndroidWAIT_UNTIL_PACKAGE_STARTCompletion.kind = vscode.CompletionItemKind.Field;
                startActivityAndroidWAIT_UNTIL_PACKAGE_STARTCompletion.insertText = new vscode.SnippetString("WAIT_UNTIL_PACKAGE_START = \"${1}\"");
                startActivityAndroidWAIT_UNTIL_PACKAGE_STARTCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit dem Namen des Packages belegt werden. Klickt man auf den Android-Icon in Appium, \u00F6ffnen sich die Konfigurationseinstellungen und man kann diesen Parameter unter dem Reiter \'Application Path\' nachlesen.');
                items.push(startActivityAndroidWAIT_UNTIL_PACKAGE_STARTCompletion);
                const startActivityAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion = new vscode.CompletionItem('WAIT_UNTIL_ACTIVITY_START');
                startActivityAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion.kind = vscode.CompletionItemKind.Field;
                startActivityAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion.insertText = new vscode.SnippetString("WAIT_UNTIL_ACTIVITY_START = \"${1}\"");
                startActivityAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit dem Namen einer Activity belegt werden, auf dessen Start nach dem Start der \'ACTIVITY_TO_START\' gewartet werden soll. Klickt man auf den Android-Icon in Appium, \u00F6ffnen sich die Konfigurationseinstellungen und man kann diesen Parameter unter dem Reiter \'Application Path\' nachlesen.');
                items.push(startActivityAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion);
            }
            if (/.*\s*startAndroid\s*\(.*/.test(linePrefix)) {
                const startAndroidURLCompletion = new vscode.CompletionItem('URL');
                startAndroidURLCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                startAndroidURLCompletion.documentation = new vscode.MarkdownString('Der Parameter muss mit der URL zum App Binary oder einer HTTP Webadresse belegt werden.');
                items.push(startAndroidURLCompletion);
                const startAndroidCAPABILITIES_FILECompletion = new vscode.CompletionItem('CAPABILITIES_FILE');
                startAndroidCAPABILITIES_FILECompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidCAPABILITIES_FILECompletion.insertText = new vscode.SnippetString("CAPABILITIES_FILE = \"${1}\"");
                startAndroidCAPABILITIES_FILECompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(startAndroidCAPABILITIES_FILECompletion);
                const startAndroidDEVICE_UDIDCompletion = new vscode.CompletionItem('DEVICE_UDID');
                startAndroidDEVICE_UDIDCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidDEVICE_UDIDCompletion.insertText = new vscode.SnippetString("DEVICE_UDID = \"${1}\"");
                startAndroidDEVICE_UDIDCompletion.documentation = new vscode.MarkdownString('ID des Ger\u00E4ts');
                items.push(startAndroidDEVICE_UDIDCompletion);
                const startAndroidAVD_NAMECompletion = new vscode.CompletionItem('AVD_NAME');
                startAndroidAVD_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidAVD_NAMECompletion.insertText = new vscode.SnippetString("AVD_NAME = \"${1}\"");
                startAndroidAVD_NAMECompletion.documentation = new vscode.MarkdownString('Name des AVD Managers.');
                items.push(startAndroidAVD_NAMECompletion);
                const startAndroidPLATFORM_VERSIONCompletion = new vscode.CompletionItem('PLATFORM_VERSION');
                startAndroidPLATFORM_VERSIONCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidPLATFORM_VERSIONCompletion.insertText = new vscode.SnippetString("PLATFORM_VERSION = \"${1}\"");
                startAndroidPLATFORM_VERSIONCompletion.documentation = new vscode.MarkdownString('Version des Andoid.');
                items.push(startAndroidPLATFORM_VERSIONCompletion);
                const startAndroidPACKAGE_CONTAINING_APPCompletion = new vscode.CompletionItem('PACKAGE_CONTAINING_APP');
                startAndroidPACKAGE_CONTAINING_APPCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidPACKAGE_CONTAINING_APPCompletion.insertText = new vscode.SnippetString("PACKAGE_CONTAINING_APP = \"${1}\"");
                startAndroidPACKAGE_CONTAINING_APPCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit dem App Identifier des App Package belegt werden.');
                items.push(startAndroidPACKAGE_CONTAINING_APPCompletion);
                const startAndroidWAIT_UNTIL_PACKAGE_STARTCompletion = new vscode.CompletionItem('WAIT_UNTIL_PACKAGE_START');
                startAndroidWAIT_UNTIL_PACKAGE_STARTCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidWAIT_UNTIL_PACKAGE_STARTCompletion.insertText = new vscode.SnippetString("WAIT_UNTIL_PACKAGE_START = \"${1}\"");
                startAndroidWAIT_UNTIL_PACKAGE_STARTCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit dem Namen des Package der zu ladenen Activity belegt werden, auf das gewartet werden soll.');
                items.push(startAndroidWAIT_UNTIL_PACKAGE_STARTCompletion);
                const startAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion = new vscode.CompletionItem('WAIT_UNTIL_ACTIVITY_START');
                startAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion.insertText = new vscode.SnippetString("WAIT_UNTIL_ACTIVITY_START = \"${1}\"");
                startAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit dem Namen der zu ladenen Activity belegt werden, auf die gewartet werden soll.');
                items.push(startAndroidWAIT_UNTIL_ACTIVITY_STARTCompletion);
            }
            if (/.*\s*startAndroidWeb\s*\(.*/.test(linePrefix)) {
                const startAndroidWebURLCompletion = new vscode.CompletionItem('URL');
                startAndroidWebURLCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidWebURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                startAndroidWebURLCompletion.documentation = new vscode.MarkdownString('Der Parameter muss mit der URL der Website belegt werden, die aufgerufen werden soll.');
                items.push(startAndroidWebURLCompletion);
                const startAndroidWebCAPABILITIES_FILECompletion = new vscode.CompletionItem('CAPABILITIES_FILE');
                startAndroidWebCAPABILITIES_FILECompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidWebCAPABILITIES_FILECompletion.insertText = new vscode.SnippetString("CAPABILITIES_FILE = \"${1}\"");
                startAndroidWebCAPABILITIES_FILECompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(startAndroidWebCAPABILITIES_FILECompletion);
                const startAndroidWebDEVICE_UDIDCompletion = new vscode.CompletionItem('DEVICE_UDID');
                startAndroidWebDEVICE_UDIDCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidWebDEVICE_UDIDCompletion.insertText = new vscode.SnippetString("DEVICE_UDID = \"${1}\"");
                startAndroidWebDEVICE_UDIDCompletion.documentation = new vscode.MarkdownString('ID des Ger\u00E4ts');
                items.push(startAndroidWebDEVICE_UDIDCompletion);
                const startAndroidWebAVD_NAMECompletion = new vscode.CompletionItem('AVD_NAME');
                startAndroidWebAVD_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidWebAVD_NAMECompletion.insertText = new vscode.SnippetString("AVD_NAME = \"${1}\"");
                startAndroidWebAVD_NAMECompletion.documentation = new vscode.MarkdownString('Name des AVD Managers');
                items.push(startAndroidWebAVD_NAMECompletion);
                const startAndroidWebPLATFORM_VERSIONCompletion = new vscode.CompletionItem('PLATFORM_VERSION');
                startAndroidWebPLATFORM_VERSIONCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidWebPLATFORM_VERSIONCompletion.insertText = new vscode.SnippetString("PLATFORM_VERSION = \"${1}\"");
                startAndroidWebPLATFORM_VERSIONCompletion.documentation = new vscode.MarkdownString('Version des Andoid');
                items.push(startAndroidWebPLATFORM_VERSIONCompletion);
                const startAndroidWebALERT_ASSERT_TEXTCompletion = new vscode.CompletionItem('ALERT_ASSERT_TEXT');
                startAndroidWebALERT_ASSERT_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                startAndroidWebALERT_ASSERT_TEXTCompletion.insertText = new vscode.SnippetString("ALERT_ASSERT_TEXT = \"${1}\"");
                startAndroidWebALERT_ASSERT_TEXTCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit einem Text z.B. eine Fehlermeldung belegt werden. Nachdem der Browser ge\u00F6ffnet wurde, wird \u00FCberpr\u00FCft, ob der Text in einem Betriebssystemfenster angezeigt wird.');
                items.push(startAndroidWebALERT_ASSERT_TEXTCompletion);
            }
            if (/.*\s*startApplication\s*\(.*/.test(linePrefix)) {
                const startApplicationEXECUTABLECompletion = new vscode.CompletionItem('EXECUTABLE');
                startApplicationEXECUTABLECompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationEXECUTABLECompletion.insertText = new vscode.SnippetString("EXECUTABLE = \"${1}\"");
                startApplicationEXECUTABLECompletion.documentation = new vscode.MarkdownString('Ausf\u00FChrbare Datei');
                items.push(startApplicationEXECUTABLECompletion);
                const startApplicationWAIT_TIME_IN_SECONDSCompletion = new vscode.CompletionItem('WAIT_TIME_IN_SECONDS');
                startApplicationWAIT_TIME_IN_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWAIT_TIME_IN_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_TIME_IN_SECONDS = \"${1}\"");
                startApplicationWAIT_TIME_IN_SECONDSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(startApplicationWAIT_TIME_IN_SECONDSCompletion);
                const startApplicationWAIT_FOR_CLASSCompletion = new vscode.CompletionItem('WAIT_FOR_CLASS');
                startApplicationWAIT_FOR_CLASSCompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWAIT_FOR_CLASSCompletion.insertText = new vscode.SnippetString("WAIT_FOR_CLASS = \"${1}\"");
                startApplicationWAIT_FOR_CLASSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(startApplicationWAIT_FOR_CLASSCompletion);
                const startApplicationFORCE_RESULTCompletion = new vscode.CompletionItem('FORCE_RESULT');
                startApplicationFORCE_RESULTCompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationFORCE_RESULTCompletion.insertText = new vscode.SnippetString("FORCE_RESULT = \"${1}\"");
                startApplicationFORCE_RESULTCompletion.documentation = new vscode.MarkdownString('Versucht die Anwendung unabh\u00E4ngig vom aktuellen Systemzustand zu starten.');
                items.push(startApplicationFORCE_RESULTCompletion);
            }
            if (/.*\s*startApplicationCP\s*\(.*/.test(linePrefix)) {
                const startApplicationCPWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                startApplicationCPWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationCPWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                startApplicationCPWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des nach der Ausfuehrung geoeffneten Fensters.');
                items.push(startApplicationCPWINDOW_NAMECompletion);
                const startApplicationCPSHELL_SCRIPT_PATHCompletion = new vscode.CompletionItem('SHELL_SCRIPT_PATH');
                startApplicationCPSHELL_SCRIPT_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationCPSHELL_SCRIPT_PATHCompletion.insertText = new vscode.SnippetString("SHELL_SCRIPT_PATH = \"${1}\"");
                startApplicationCPSHELL_SCRIPT_PATHCompletion.documentation = new vscode.MarkdownString('Angabe der ausfuerbaren Datei inclusive des vollstaendigen Pfades.');
                items.push(startApplicationCPSHELL_SCRIPT_PATHCompletion);
            }
            if (/.*\s*startApplicationWin\s*\(.*/.test(linePrefix)) {
                const startApplicationWinEXPECTED_WINDOW_NAMECompletion = new vscode.CompletionItem('EXPECTED_WINDOW_NAME');
                startApplicationWinEXPECTED_WINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWinEXPECTED_WINDOW_NAMECompletion.insertText = new vscode.SnippetString("EXPECTED_WINDOW_NAME = \"${1}\"");
                startApplicationWinEXPECTED_WINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das erwartet wird');
                items.push(startApplicationWinEXPECTED_WINDOW_NAMECompletion);
                const startApplicationWinEXECUTABLE_PATHCompletion = new vscode.CompletionItem('EXECUTABLE_PATH');
                startApplicationWinEXECUTABLE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWinEXECUTABLE_PATHCompletion.insertText = new vscode.SnippetString("EXECUTABLE_PATH = \"${1}\"");
                startApplicationWinEXECUTABLE_PATHCompletion.documentation = new vscode.MarkdownString('Pfad zur ausf\u00FChrbaren Datei zum Start der Applikation');
                items.push(startApplicationWinEXECUTABLE_PATHCompletion);
                const startApplicationWinPATH_IS_RELATIVECompletion = new vscode.CompletionItem('PATH_IS_RELATIVE');
                startApplicationWinPATH_IS_RELATIVECompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWinPATH_IS_RELATIVECompletion.insertText = new vscode.SnippetString("PATH_IS_RELATIVE = \"${1}\"");
                startApplicationWinPATH_IS_RELATIVECompletion.documentation = new vscode.MarkdownString('Wenn true, muss unter EXECUTABLE_PATH nur der relative Pfad vom die Testset-XLSM beinhaltenden Ordner ausgehend angegeben werden');
                items.push(startApplicationWinPATH_IS_RELATIVECompletion);
                const startApplicationWinWAIT_MILLISECONDSCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS');
                startApplicationWinWAIT_MILLISECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWinWAIT_MILLISECONDSCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS = \"${1}\"");
                startApplicationWinWAIT_MILLISECONDSCompletion.documentation = new vscode.MarkdownString('Zeit (in Millisekunden) die gewartet werden, soll, bis das Fenster offen ist. Falls das Fenster nicht in der Zeit ge\u00C3\u00B6ffnet wird, wird das Kommando einen Fehler melden.');
                items.push(startApplicationWinWAIT_MILLISECONDSCompletion);
                const startApplicationWinMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                startApplicationWinMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWinMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                startApplicationWinMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(startApplicationWinMATCH_MODECompletion);
            }
            if (/.*\s*startApplicationWinEle\s*\(.*/.test(linePrefix)) {
                const startApplicationWinEleEXPECTED_WINDOW_NAMECompletion = new vscode.CompletionItem('EXPECTED_WINDOW_NAME');
                startApplicationWinEleEXPECTED_WINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWinEleEXPECTED_WINDOW_NAMECompletion.insertText = new vscode.SnippetString("EXPECTED_WINDOW_NAME = \"${1}\"");
                startApplicationWinEleEXPECTED_WINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Erwarteter Name des durch die Anwendung ge\u00F6ffneten Fensters.');
                items.push(startApplicationWinEleEXPECTED_WINDOW_NAMECompletion);
                const startApplicationWinEleAPPLICATION_PATHCompletion = new vscode.CompletionItem('APPLICATION_PATH');
                startApplicationWinEleAPPLICATION_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                startApplicationWinEleAPPLICATION_PATHCompletion.insertText = new vscode.SnippetString("APPLICATION_PATH = \"${1}\"");
                startApplicationWinEleAPPLICATION_PATHCompletion.documentation = new vscode.MarkdownString('Vollst\u00E4ndiger Dateipfad der zu startenden Anwendung.');
                items.push(startApplicationWinEleAPPLICATION_PATHCompletion);
            }
            if (/.*\s*startIOS\s*\(.*/.test(linePrefix)) {
                const startIOSCAPABILITIES_FILECompletion = new vscode.CompletionItem('CAPABILITIES_FILE');
                startIOSCAPABILITIES_FILECompletion.kind = vscode.CompletionItemKind.Field;
                startIOSCAPABILITIES_FILECompletion.insertText = new vscode.SnippetString("CAPABILITIES_FILE = \"${1}\"");
                startIOSCAPABILITIES_FILECompletion.documentation = new vscode.MarkdownString('Pfad zu einer JSON Datei mit Capabilities zur Konfiguration der zu startenden Appium Session. Um eine App zu starten m\u00FCssen die Capabilities \'app\' bzw. \'bundleId\' gesetzt werden. Weitere Informationen hierzu siehe Dokumentation im Abschnitt Mobile Anwendungen.');
                items.push(startIOSCAPABILITIES_FILECompletion);
            }
            if (/.*\s*startIOSWeb\s*\(.*/.test(linePrefix)) {
                const startIOSWebURLCompletion = new vscode.CompletionItem('URL');
                startIOSWebURLCompletion.kind = vscode.CompletionItemKind.Field;
                startIOSWebURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                startIOSWebURLCompletion.documentation = new vscode.MarkdownString('Der Parameter muss mit der URL der Website belegt werden, die aufgerufen werden soll.');
                items.push(startIOSWebURLCompletion);
                const startIOSWebCAPABILITIES_FILECompletion = new vscode.CompletionItem('CAPABILITIES_FILE');
                startIOSWebCAPABILITIES_FILECompletion.kind = vscode.CompletionItemKind.Field;
                startIOSWebCAPABILITIES_FILECompletion.insertText = new vscode.SnippetString("CAPABILITIES_FILE = \"${1}\"");
                startIOSWebCAPABILITIES_FILECompletion.documentation = new vscode.MarkdownString('Pfad zu einer JSON Datei mit Capabilities zur manuellen Konfiguration der zu startenden Appium Session.');
                items.push(startIOSWebCAPABILITIES_FILECompletion);
                const startIOSWebPLATFORM_VERSIONCompletion = new vscode.CompletionItem('PLATFORM_VERSION');
                startIOSWebPLATFORM_VERSIONCompletion.kind = vscode.CompletionItemKind.Field;
                startIOSWebPLATFORM_VERSIONCompletion.insertText = new vscode.SnippetString("PLATFORM_VERSION = \"${1}\"");
                startIOSWebPLATFORM_VERSIONCompletion.documentation = new vscode.MarkdownString('Version von iOS');
                items.push(startIOSWebPLATFORM_VERSIONCompletion);
                const startIOSWebDEVICE_UDIDCompletion = new vscode.CompletionItem('DEVICE_UDID');
                startIOSWebDEVICE_UDIDCompletion.kind = vscode.CompletionItemKind.Field;
                startIOSWebDEVICE_UDIDCompletion.insertText = new vscode.SnippetString("DEVICE_UDID = \"${1}\"");
                startIOSWebDEVICE_UDIDCompletion.documentation = new vscode.MarkdownString('ID des Ger\u00E4ts - Erforderlich bei Automatisierung eines real-devices. Wenn nur ein einziges Ger\u00E4t an den Mac angeschlossen ist, kann hier auch \'auto\' zur automatischen Erkennung eingetragen werden.');
                items.push(startIOSWebDEVICE_UDIDCompletion);
                const startIOSWebDEVICE_NAMECompletion = new vscode.CompletionItem('DEVICE_NAME');
                startIOSWebDEVICE_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                startIOSWebDEVICE_NAMECompletion.insertText = new vscode.SnippetString("DEVICE_NAME = \"${1}\"");
                startIOSWebDEVICE_NAMECompletion.documentation = new vscode.MarkdownString('Name des iOS-Ger\u00E4te-Simulators');
                items.push(startIOSWebDEVICE_NAMECompletion);
                const startIOSWebALERT_ASSERT_TEXTCompletion = new vscode.CompletionItem('ALERT_ASSERT_TEXT');
                startIOSWebALERT_ASSERT_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                startIOSWebALERT_ASSERT_TEXTCompletion.insertText = new vscode.SnippetString("ALERT_ASSERT_TEXT = \"${1}\"");
                startIOSWebALERT_ASSERT_TEXTCompletion.documentation = new vscode.MarkdownString('Der Parameter kann mit einem Text, z.B. einer Fehlermeldung belegt werden. Nachdem der Browser ge\u00F6ffnet wurde, wird \u00FCberpr\u00FCft, ob der Text in einem Betriebssystemfenster angezeigt wird.');
                items.push(startIOSWebALERT_ASSERT_TEXTCompletion);
            }
            if (/.*\s*startSapDriver\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*startScreenRecording\s*\(.*/.test(linePrefix)) {
                const startScreenRecordingTARGET_FILECompletion = new vscode.CompletionItem('TARGET_FILE');
                startScreenRecordingTARGET_FILECompletion.kind = vscode.CompletionItemKind.Field;
                startScreenRecordingTARGET_FILECompletion.insertText = new vscode.SnippetString("TARGET_FILE = \"${1}\"");
                startScreenRecordingTARGET_FILECompletion.documentation = new vscode.MarkdownString('Einfacher Name oder absoluter Pfad der Datei, in der das Video gespeichert wird. Falls bereits eine gleichnamige Datei im Zielpfad existiert, bricht das Kommando mit einem Fehler ab (siehe dazu auch Parameter \'OVERWRITE_EXISTING_TARGET_FILE\'). Der Name kann mit der Dateiendung \'.avi\' enden. Tut er dies nicht, wird \'.avi\' automatisch erg\u00E4nzt. Wird nur ein einfacher Name und kein absoluter Pfad angegeben, so wird das Video in dem Ordner gespeichert, der in den \'environment.properties\' als \'screenRecorderDirectory\' gesetzt wurde. Per Default ist dies \'${installationDirectory}\/ScreenRecordings\'. Falls kein Name angegeben wurde, wird ein Name auf Basis des Script-Namens und des Zeitstempelts generiert und die Datei ebenfalls im Default-Ordner gespeichert.');
                items.push(startScreenRecordingTARGET_FILECompletion);
                const startScreenRecordingFORCE_STARTCompletion = new vscode.CompletionItem('FORCE_START');
                startScreenRecordingFORCE_STARTCompletion.kind = vscode.CompletionItemKind.Field;
                startScreenRecordingFORCE_STARTCompletion.insertText = new vscode.SnippetString("FORCE_START = \"${1}\"");
                startScreenRecordingFORCE_STARTCompletion.documentation = new vscode.MarkdownString('Falls bereits eine Aufnahme aktiv ist, und FORCE_START=false (Default-Wert), wird keine neue Aufnahme gestartet und das Kommando gibt den Status \'Warnung\' zur\u00FCck. Wird jedoch explizit FORCE_START=true gesetzt, so wird eine m\u00F6glicherweise bereits aktive Aufnahme beendet, das bislang aufgenommene Video gespeichert, und eine neue Aufnahme gestartet.');
                items.push(startScreenRecordingFORCE_STARTCompletion);
                const startScreenRecordingOVERWRITE_EXISTING_TARGET_FILECompletion = new vscode.CompletionItem('OVERWRITE_EXISTING_TARGET_FILE');
                startScreenRecordingOVERWRITE_EXISTING_TARGET_FILECompletion.kind = vscode.CompletionItemKind.Field;
                startScreenRecordingOVERWRITE_EXISTING_TARGET_FILECompletion.insertText = new vscode.SnippetString("OVERWRITE_EXISTING_TARGET_FILE = \"${1}\"");
                startScreenRecordingOVERWRITE_EXISTING_TARGET_FILECompletion.documentation = new vscode.MarkdownString('Falls bereits eine Datei mit dem in TARGET_FILE \u00FCbergebenen Namen im Zielpfad existiert, bricht das Kommando mit einem Fehler ab. Soll dies verhindert werden, muss dieser Parameter auf \'true\' gesetzt werden. Default: false');
                items.push(startScreenRecordingOVERWRITE_EXISTING_TARGET_FILECompletion);
                const startScreenRecordingTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                startScreenRecordingTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                startScreenRecordingTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                startScreenRecordingTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Storage-Key, unter dem der absolute Pfad des zu erstellenden Videos abgelegt werden kann. ');
                items.push(startScreenRecordingTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*startWeb\s*\(.*/.test(linePrefix)) {
                const startWebEXPECTED_WEBSITE_TITLECompletion = new vscode.CompletionItem('EXPECTED_WEBSITE_TITLE');
                startWebEXPECTED_WEBSITE_TITLECompletion.kind = vscode.CompletionItemKind.Field;
                startWebEXPECTED_WEBSITE_TITLECompletion.insertText = new vscode.SnippetString("EXPECTED_WEBSITE_TITLE = \"${1}\"");
                startWebEXPECTED_WEBSITE_TITLECompletion.documentation = new vscode.MarkdownString('Erwarteter Seiten-Titel.');
                items.push(startWebEXPECTED_WEBSITE_TITLECompletion);
                const startWebURLCompletion = new vscode.CompletionItem('URL');
                startWebURLCompletion.kind = vscode.CompletionItemKind.Field;
                startWebURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                startWebURLCompletion.documentation = new vscode.MarkdownString('Zu \u00F6ffnende URL (http:\/\/www...).');
                items.push(startWebURLCompletion);
                const startWebPROXYCompletion = new vscode.CompletionItem('PROXY');
                startWebPROXYCompletion.kind = vscode.CompletionItemKind.Field;
                startWebPROXYCompletion.insertText = new vscode.SnippetString("PROXY = \"${1}\"");
                startWebPROXYCompletion.documentation = new vscode.MarkdownString('Zu verwendender Proxy-Server. Im Default wird kein Proxy verwendet.');
                items.push(startWebPROXYCompletion);
                const startWebBROWSER_NAMECompletion = new vscode.CompletionItem('BROWSER_NAME');
                startWebBROWSER_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                startWebBROWSER_NAMECompletion.insertText = new vscode.SnippetString("BROWSER_NAME = \"${1}\"");
                startWebBROWSER_NAMECompletion.documentation = new vscode.MarkdownString('Browsername. M\u00F6glich sind Firefox bzw. FF, Internet Explorer bzw. IE, Chrome  bzw. CH, Safari  bzw. SA (nur auf MacOS), Edge bzw. ED.');
                items.push(startWebBROWSER_NAMECompletion);
                const startWebWINDOW_WIDTHCompletion = new vscode.CompletionItem('WINDOW_WIDTH');
                startWebWINDOW_WIDTHCompletion.kind = vscode.CompletionItemKind.Field;
                startWebWINDOW_WIDTHCompletion.insertText = new vscode.SnippetString("WINDOW_WIDTH = \"${1}\"");
                startWebWINDOW_WIDTHCompletion.documentation = new vscode.MarkdownString('Gew\u00FCnschte Fensterbreite. Per Default wird das Fenster maximiert.');
                items.push(startWebWINDOW_WIDTHCompletion);
                const startWebWINDOW_HEIGHTCompletion = new vscode.CompletionItem('WINDOW_HEIGHT');
                startWebWINDOW_HEIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                startWebWINDOW_HEIGHTCompletion.insertText = new vscode.SnippetString("WINDOW_HEIGHT = \"${1}\"");
                startWebWINDOW_HEIGHTCompletion.documentation = new vscode.MarkdownString('Gew\u00FCnschte Fensterh\u00F6he. Per Default wird das Fenster maximiert.');
                items.push(startWebWINDOW_HEIGHTCompletion);
                const startWebKILL_DRIVERSCompletion = new vscode.CompletionItem('KILL_DRIVERS');
                startWebKILL_DRIVERSCompletion.kind = vscode.CompletionItemKind.Field;
                startWebKILL_DRIVERSCompletion.insertText = new vscode.SnippetString("KILL_DRIVERS = \"${1}\"");
                startWebKILL_DRIVERSCompletion.documentation = new vscode.MarkdownString('{true,false} Laufende Selenium-Webtreiber-Prozesse vor dem \u00D6ffnen des neuen Browser-Fensters beenden. Default: false');
                items.push(startWebKILL_DRIVERSCompletion);
                const startWebCHROME_PLUGINS_NAMESCompletion = new vscode.CompletionItem('CHROME_PLUGINS_NAMES');
                startWebCHROME_PLUGINS_NAMESCompletion.kind = vscode.CompletionItemKind.Field;
                startWebCHROME_PLUGINS_NAMESCompletion.insertText = new vscode.SnippetString("CHROME_PLUGINS_NAMES = \"${1}\"");
                startWebCHROME_PLUGINS_NAMESCompletion.documentation = new vscode.MarkdownString('Liste der Namen der .crx-Dateien einzubindender Chrome-Extensions (Trennzeichen \';\'). Die .crx-Dateien sind abzulegen im Ordner, der als \'pluginsPathChrome\' in den environment.properties gesetzt ist.Im Standard ist dies das Verzeichnis \'mateo\/Server\/resources\/browsers\/chrome\/plugins\'');
                items.push(startWebCHROME_PLUGINS_NAMESCompletion);
                const startWebALERT_ASSERT_TEXTCompletion = new vscode.CompletionItem('ALERT_ASSERT_TEXT');
                startWebALERT_ASSERT_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                startWebALERT_ASSERT_TEXTCompletion.insertText = new vscode.SnippetString("ALERT_ASSERT_TEXT = \"${1}\"");
                startWebALERT_ASSERT_TEXTCompletion.documentation = new vscode.MarkdownString('\u00D6ffnet sich beim Start des Browsers auf der Webseite ein Alert-Fensters, soll der hier angegebene Text \u00FCberpr\u00FCft werden.');
                items.push(startWebALERT_ASSERT_TEXTCompletion);
                const startWebSAFARI_USE_TECHNOLOGY_PREVIEWCompletion = new vscode.CompletionItem('SAFARI_USE_TECHNOLOGY_PREVIEW');
                startWebSAFARI_USE_TECHNOLOGY_PREVIEWCompletion.kind = vscode.CompletionItemKind.Field;
                startWebSAFARI_USE_TECHNOLOGY_PREVIEWCompletion.insertText = new vscode.SnippetString("SAFARI_USE_TECHNOLOGY_PREVIEW = \"${1}\"");
                startWebSAFARI_USE_TECHNOLOGY_PREVIEWCompletion.documentation = new vscode.MarkdownString('{true,false} Gibt an, ob die Technology-Preview-Version von Safari verwendet werden soll. Default: false');
                items.push(startWebSAFARI_USE_TECHNOLOGY_PREVIEWCompletion);
                const startWebBROWSER_ALIASCompletion = new vscode.CompletionItem('BROWSER_ALIAS');
                startWebBROWSER_ALIASCompletion.kind = vscode.CompletionItemKind.Field;
                startWebBROWSER_ALIASCompletion.insertText = new vscode.SnippetString("BROWSER_ALIAS = \"${1}\"");
                startWebBROWSER_ALIASCompletion.documentation = new vscode.MarkdownString('Falls mehrere Browser mit dem gleichen Browsernamen zu \u00F6ffnen sind (zum Beispiel ein neuer Chrome Browser, obwohl bereits ein Chrome gestartet wurde): Alias f\u00FCr jeden Browser der ge\u00F6ffnet wird, um diesen in Kommanndos eindeutig ansprechen zu k\u00F6nnen.');
                items.push(startWebBROWSER_ALIASCompletion);
                const startWebCHROME_AUTOMATION_EXTENSIONCompletion = new vscode.CompletionItem('CHROME_AUTOMATION_EXTENSION');
                startWebCHROME_AUTOMATION_EXTENSIONCompletion.kind = vscode.CompletionItemKind.Field;
                startWebCHROME_AUTOMATION_EXTENSIONCompletion.insertText = new vscode.SnippetString("CHROME_AUTOMATION_EXTENSION = \"${1}\"");
                startWebCHROME_AUTOMATION_EXTENSIONCompletion.documentation = new vscode.MarkdownString('(Parameter ist deprecated und wird in einer zuk\u00FCnftigen Version entfernt)');
                items.push(startWebCHROME_AUTOMATION_EXTENSIONCompletion);
            }
            if (/.*\s*startWebRemote\s*\(.*/.test(linePrefix)) {
                const startWebRemoteEXPECTED_WEBSITE_TITLECompletion = new vscode.CompletionItem('EXPECTED_WEBSITE_TITLE');
                startWebRemoteEXPECTED_WEBSITE_TITLECompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteEXPECTED_WEBSITE_TITLECompletion.insertText = new vscode.SnippetString("EXPECTED_WEBSITE_TITLE = \"${1}\"");
                startWebRemoteEXPECTED_WEBSITE_TITLECompletion.documentation = new vscode.MarkdownString('Erwarteter Seiten-Titel.');
                items.push(startWebRemoteEXPECTED_WEBSITE_TITLECompletion);
                const startWebRemoteURLCompletion = new vscode.CompletionItem('URL');
                startWebRemoteURLCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteURLCompletion.insertText = new vscode.SnippetString("URL = \"${1}\"");
                startWebRemoteURLCompletion.documentation = new vscode.MarkdownString('Zu \u00F6ffnende URL (http:\/\/www...).');
                items.push(startWebRemoteURLCompletion);
                const startWebRemotePROXYCompletion = new vscode.CompletionItem('PROXY');
                startWebRemotePROXYCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemotePROXYCompletion.insertText = new vscode.SnippetString("PROXY = \"${1}\"");
                startWebRemotePROXYCompletion.documentation = new vscode.MarkdownString('Zu verwendender Proxy-Server. Im Default wird kein Proxy verwendet.');
                items.push(startWebRemotePROXYCompletion);
                const startWebRemoteBROWSER_NAMECompletion = new vscode.CompletionItem('BROWSER_NAME');
                startWebRemoteBROWSER_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteBROWSER_NAMECompletion.insertText = new vscode.SnippetString("BROWSER_NAME = \"${1}\"");
                startWebRemoteBROWSER_NAMECompletion.documentation = new vscode.MarkdownString('Browsername. M\u00F6glich sind Firefox bzw. FF, Internet Explorer bzw. IE, Chrome  bzw. CH, Safari  bzw. SA (nur auf MacOS), Edge bzw. ED.');
                items.push(startWebRemoteBROWSER_NAMECompletion);
                const startWebRemoteWINDOW_WIDTHCompletion = new vscode.CompletionItem('WINDOW_WIDTH');
                startWebRemoteWINDOW_WIDTHCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteWINDOW_WIDTHCompletion.insertText = new vscode.SnippetString("WINDOW_WIDTH = \"${1}\"");
                startWebRemoteWINDOW_WIDTHCompletion.documentation = new vscode.MarkdownString('Gew\u00FCnschte Fensterbreite. Per Default wird das Fenster maximiert.');
                items.push(startWebRemoteWINDOW_WIDTHCompletion);
                const startWebRemoteWINDOW_HEIGHTCompletion = new vscode.CompletionItem('WINDOW_HEIGHT');
                startWebRemoteWINDOW_HEIGHTCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteWINDOW_HEIGHTCompletion.insertText = new vscode.SnippetString("WINDOW_HEIGHT = \"${1}\"");
                startWebRemoteWINDOW_HEIGHTCompletion.documentation = new vscode.MarkdownString('Gew\u00FCnschte Fensterh\u00F6he. Per Default wird das Fenster maximiert.');
                items.push(startWebRemoteWINDOW_HEIGHTCompletion);
                const startWebRemoteKILL_DRIVERSCompletion = new vscode.CompletionItem('KILL_DRIVERS');
                startWebRemoteKILL_DRIVERSCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteKILL_DRIVERSCompletion.insertText = new vscode.SnippetString("KILL_DRIVERS = \"${1}\"");
                startWebRemoteKILL_DRIVERSCompletion.documentation = new vscode.MarkdownString('{true,false} Laufende Selenium-Webtreiber-Prozesse vor dem \u00D6ffnen des neuen Browser-Fensters beenden. Default: false');
                items.push(startWebRemoteKILL_DRIVERSCompletion);
                const startWebRemoteCHROME_PLUGINS_NAMESCompletion = new vscode.CompletionItem('CHROME_PLUGINS_NAMES');
                startWebRemoteCHROME_PLUGINS_NAMESCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteCHROME_PLUGINS_NAMESCompletion.insertText = new vscode.SnippetString("CHROME_PLUGINS_NAMES = \"${1}\"");
                startWebRemoteCHROME_PLUGINS_NAMESCompletion.documentation = new vscode.MarkdownString('Liste der Namen der .crx-Dateien einzubindender Chrome-Extensions (Trennzeichen \';\'). Die .crx-Dateien sind abzulegen im Ordner, der als \'pluginsPathChrome\' in den environment.properties gesetzt ist.Im Standard ist dies das Verzeichnis \'mateo\/Server\/resources\/browsers\/chrome\/plugins\'');
                items.push(startWebRemoteCHROME_PLUGINS_NAMESCompletion);
                const startWebRemoteALERT_ASSERT_TEXTCompletion = new vscode.CompletionItem('ALERT_ASSERT_TEXT');
                startWebRemoteALERT_ASSERT_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteALERT_ASSERT_TEXTCompletion.insertText = new vscode.SnippetString("ALERT_ASSERT_TEXT = \"${1}\"");
                startWebRemoteALERT_ASSERT_TEXTCompletion.documentation = new vscode.MarkdownString('\u00D6ffnet sich beim Start des Browsers auf der Webseite ein Alert-Fensters, soll der hier angegebene Text \u00FCberpr\u00FCft werden.');
                items.push(startWebRemoteALERT_ASSERT_TEXTCompletion);
                const startWebRemoteSAFARI_USE_TECHNOLOGY_PREVIEWCompletion = new vscode.CompletionItem('SAFARI_USE_TECHNOLOGY_PREVIEW');
                startWebRemoteSAFARI_USE_TECHNOLOGY_PREVIEWCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteSAFARI_USE_TECHNOLOGY_PREVIEWCompletion.insertText = new vscode.SnippetString("SAFARI_USE_TECHNOLOGY_PREVIEW = \"${1}\"");
                startWebRemoteSAFARI_USE_TECHNOLOGY_PREVIEWCompletion.documentation = new vscode.MarkdownString('{true,false} Gibt an, ob die Technology-Preview-Version von Safari verwendet werden soll. Default: false');
                items.push(startWebRemoteSAFARI_USE_TECHNOLOGY_PREVIEWCompletion);
                const startWebRemoteBROWSER_ALIASCompletion = new vscode.CompletionItem('BROWSER_ALIAS');
                startWebRemoteBROWSER_ALIASCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteBROWSER_ALIASCompletion.insertText = new vscode.SnippetString("BROWSER_ALIAS = \"${1}\"");
                startWebRemoteBROWSER_ALIASCompletion.documentation = new vscode.MarkdownString('Falls mehrere Browser mit dem gleichen Browsernamen zu \u00F6ffnen sind (zum Beispiel ein neuer Chrome Browser, obwohl bereits ein Chrome gestartet wurde): Alias f\u00FCr jeden Browser der ge\u00F6ffnet wird, um diesen in Kommanndos eindeutig ansprechen zu k\u00F6nnen.');
                items.push(startWebRemoteBROWSER_ALIASCompletion);
                const startWebRemoteCHROME_AUTOMATION_EXTENSIONCompletion = new vscode.CompletionItem('CHROME_AUTOMATION_EXTENSION');
                startWebRemoteCHROME_AUTOMATION_EXTENSIONCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteCHROME_AUTOMATION_EXTENSIONCompletion.insertText = new vscode.SnippetString("CHROME_AUTOMATION_EXTENSION = \"${1}\"");
                startWebRemoteCHROME_AUTOMATION_EXTENSIONCompletion.documentation = new vscode.MarkdownString('{true,false} Bestimmt, ob in Chrome die Selenium-Automation-Extension geladen werden soll (setzt useAutomationExtension=true). Default: true');
                items.push(startWebRemoteCHROME_AUTOMATION_EXTENSIONCompletion);
                const startWebRemoteREMOTE_WEB_DRIVER_SERVER_URLCompletion = new vscode.CompletionItem('REMOTE_WEB_DRIVER_SERVER_URL');
                startWebRemoteREMOTE_WEB_DRIVER_SERVER_URLCompletion.kind = vscode.CompletionItemKind.Field;
                startWebRemoteREMOTE_WEB_DRIVER_SERVER_URLCompletion.insertText = new vscode.SnippetString("REMOTE_WEB_DRIVER_SERVER_URL = \"${1}\"");
                startWebRemoteREMOTE_WEB_DRIVER_SERVER_URLCompletion.documentation = new vscode.MarkdownString('(Parameter ist deprecated und wird in einer zuk\u00FCnftigen Version entfernt)');
                items.push(startWebRemoteREMOTE_WEB_DRIVER_SERVER_URLCompletion);
            }
            if (/.*\s*startsWithAlpha\s*\(.*/.test(linePrefix)) {
                const startsWithAlphaTEXTCompletion = new vscode.CompletionItem('TEXT');
                startsWithAlphaTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                startsWithAlphaTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                startsWithAlphaTEXTCompletion.documentation = new vscode.MarkdownString('Zu \u00FCberpr\u00FCfender Text.');
                items.push(startsWithAlphaTEXTCompletion);
                const startsWithAlphaPREFIXCompletion = new vscode.CompletionItem('PREFIX');
                startsWithAlphaPREFIXCompletion.kind = vscode.CompletionItemKind.Field;
                startsWithAlphaPREFIXCompletion.insertText = new vscode.SnippetString("PREFIX = \"${1}\"");
                startsWithAlphaPREFIXCompletion.documentation = new vscode.MarkdownString('M\u00F6glicher Teil-Text, mit dem TEXT beginnt.');
                items.push(startsWithAlphaPREFIXCompletion);
                const startsWithAlphaTRIM_TEXTCompletion = new vscode.CompletionItem('TRIM_TEXT');
                startsWithAlphaTRIM_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                startsWithAlphaTRIM_TEXTCompletion.insertText = new vscode.SnippetString("TRIM_TEXT = \"${1}\"");
                startsWithAlphaTRIM_TEXTCompletion.documentation = new vscode.MarkdownString('Sollen vor- und nachgestellte Leerzeichen in TEXT ignoriert werden? {true, false} Default: true');
                items.push(startsWithAlphaTRIM_TEXTCompletion);
                const startsWithAlphaTRIM_PREFIXCompletion = new vscode.CompletionItem('TRIM_PREFIX');
                startsWithAlphaTRIM_PREFIXCompletion.kind = vscode.CompletionItemKind.Field;
                startsWithAlphaTRIM_PREFIXCompletion.insertText = new vscode.SnippetString("TRIM_PREFIX = \"${1}\"");
                startsWithAlphaTRIM_PREFIXCompletion.documentation = new vscode.MarkdownString('Sollen vor- und nachgestellte Leerzeichen in PREFIX ignoriert werden? {true, false} Default: true');
                items.push(startsWithAlphaTRIM_PREFIXCompletion);
            }
            if (/.*\s*stopMobile\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*stopSapDriver\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*stopScreenRecording\s*\(.*/.test(linePrefix)) {
                const stopScreenRecordingSILENT_FAILCompletion = new vscode.CompletionItem('SILENT_FAIL');
                stopScreenRecordingSILENT_FAILCompletion.kind = vscode.CompletionItemKind.Field;
                stopScreenRecordingSILENT_FAILCompletion.insertText = new vscode.SnippetString("SILENT_FAIL = \"${1}\"");
                stopScreenRecordingSILENT_FAILCompletion.documentation = new vscode.MarkdownString('Falls keine Aufnahme aktiv ist, und SILENT_FAIL=false (Default-Wert), erfolgt keine Aktion und das Kommando gibt den Status \'Warnung\' zur\u00FCck. Wird jedoch explizit SILENT_FAIL=true gesetzt, so erfolgt ebenso keine Aktion, aber es wird der Status \'Erfolg\' zur\u00FCckgegeben. ');
                items.push(stopScreenRecordingSILENT_FAILCompletion);
                const stopScreenRecordingTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                stopScreenRecordingTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                stopScreenRecordingTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                stopScreenRecordingTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Storage-Key, unter dem der absolute Pfad des gespeicherten Videos abgelegt werden kann. ');
                items.push(stopScreenRecordingTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*stopWeb\s*\(.*/.test(linePrefix)) {
                const stopWebSTOP_CURRENT_DRIVER_ONLYCompletion = new vscode.CompletionItem('STOP_CURRENT_DRIVER_ONLY');
                stopWebSTOP_CURRENT_DRIVER_ONLYCompletion.kind = vscode.CompletionItemKind.Field;
                stopWebSTOP_CURRENT_DRIVER_ONLYCompletion.insertText = new vscode.SnippetString("STOP_CURRENT_DRIVER_ONLY = \"${1}\"");
                stopWebSTOP_CURRENT_DRIVER_ONLYCompletion.documentation = new vscode.MarkdownString('Beendet nur den Treiber, \u00FCber den das Fenster gesteuert wird, nicht aber das Web-Fenster, wenn auf \'True\' gesetzt.');
                items.push(stopWebSTOP_CURRENT_DRIVER_ONLYCompletion);
            }
            if (/.*\s*success\s*\(.*/.test(linePrefix)) {
                const successMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                successMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                successMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                successMESSAGECompletion.documentation = new vscode.MarkdownString('Nachricht, die im Bericht angezeigt werden soll.');
                items.push(successMESSAGECompletion);
            }
            if (/.*\s*swipeElementMobile\s*\(.*/.test(linePrefix)) {
                const swipeElementMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                swipeElementMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                swipeElementMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                swipeElementMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(swipeElementMobileBY_CRITERIACompletion);
                const swipeElementMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                swipeElementMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                swipeElementMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                swipeElementMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(swipeElementMobileEXPRESSION_TEXTCompletion);
                const swipeElementMobileGESTURE_DIRECTIONCompletion = new vscode.CompletionItem('GESTURE_DIRECTION');
                swipeElementMobileGESTURE_DIRECTIONCompletion.kind = vscode.CompletionItemKind.Field;
                swipeElementMobileGESTURE_DIRECTIONCompletion.insertText = new vscode.SnippetString("GESTURE_DIRECTION = \"${1}\"");
                swipeElementMobileGESTURE_DIRECTIONCompletion.documentation = new vscode.MarkdownString('Dieser Parameter gibt die Richtung der Swipe-Geste an. M\u00F6glich sind: LEFT_TO_RIGHT, RIGHT_TO_LEFT, BOTTOM_TO_TOP und TOP_TO_BOTTOM.');
                items.push(swipeElementMobileGESTURE_DIRECTIONCompletion);
                const swipeElementMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                swipeElementMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                swipeElementMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                swipeElementMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange vor dem Durchf\u00FChren der Swip-Geste gewartet werden soll bis das Kommando durchgef\u00FChrt wird. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(swipeElementMobileWAIT_SECONDSCompletion);
                const swipeElementMobileSWIPE_DURATIONCompletion = new vscode.CompletionItem('SWIPE_DURATION');
                swipeElementMobileSWIPE_DURATIONCompletion.kind = vscode.CompletionItemKind.Field;
                swipeElementMobileSWIPE_DURATIONCompletion.insertText = new vscode.SnippetString("SWIPE_DURATION = \"${1}\"");
                swipeElementMobileSWIPE_DURATIONCompletion.documentation = new vscode.MarkdownString('Dauer der Swipe-Geste in Millisekunden. Der Default-Wert betr\u00E4gt \'1000\'.');
                items.push(swipeElementMobileSWIPE_DURATIONCompletion);
            }
            if (/.*\s*swipeMobile\s*\(.*/.test(linePrefix)) {
                const swipeMobileX_START_SWIPECompletion = new vscode.CompletionItem('X_START_SWIPE');
                swipeMobileX_START_SWIPECompletion.kind = vscode.CompletionItemKind.Field;
                swipeMobileX_START_SWIPECompletion.insertText = new vscode.SnippetString("X_START_SWIPE = \"${1}\"");
                swipeMobileX_START_SWIPECompletion.documentation = new vscode.MarkdownString('Der Pflichtparameter gibt die X-Koordinate des Punktes in Pixeln an, an dem die Swipe-Geste startet. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(swipeMobileX_START_SWIPECompletion);
                const swipeMobileY_START_SWIPECompletion = new vscode.CompletionItem('Y_START_SWIPE');
                swipeMobileY_START_SWIPECompletion.kind = vscode.CompletionItemKind.Field;
                swipeMobileY_START_SWIPECompletion.insertText = new vscode.SnippetString("Y_START_SWIPE = \"${1}\"");
                swipeMobileY_START_SWIPECompletion.documentation = new vscode.MarkdownString('Der Pflichtparameter gibt die Y-Koordinate des Punktes in Pixeln an, an dem die Swipe-Geste startet. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(swipeMobileY_START_SWIPECompletion);
                const swipeMobileX_END_SWIPECompletion = new vscode.CompletionItem('X_END_SWIPE');
                swipeMobileX_END_SWIPECompletion.kind = vscode.CompletionItemKind.Field;
                swipeMobileX_END_SWIPECompletion.insertText = new vscode.SnippetString("X_END_SWIPE = \"${1}\"");
                swipeMobileX_END_SWIPECompletion.documentation = new vscode.MarkdownString('Der Pflichtparameter gibt die X-Koordinate des Punktes in Pixeln an, an dem die Swipe-Geste endet. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(swipeMobileX_END_SWIPECompletion);
                const swipeMobileY_END_SWIPECompletion = new vscode.CompletionItem('Y_END_SWIPE');
                swipeMobileY_END_SWIPECompletion.kind = vscode.CompletionItemKind.Field;
                swipeMobileY_END_SWIPECompletion.insertText = new vscode.SnippetString("Y_END_SWIPE = \"${1}\"");
                swipeMobileY_END_SWIPECompletion.documentation = new vscode.MarkdownString('Der Pflichtparameter gibt die Y-Koordinate des Punktes in Pixeln an, an dem die Swipe-Geste endet. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(swipeMobileY_END_SWIPECompletion);
                const swipeMobileSWIPE_DURATIONCompletion = new vscode.CompletionItem('SWIPE_DURATION');
                swipeMobileSWIPE_DURATIONCompletion.kind = vscode.CompletionItemKind.Field;
                swipeMobileSWIPE_DURATIONCompletion.insertText = new vscode.SnippetString("SWIPE_DURATION = \"${1}\"");
                swipeMobileSWIPE_DURATIONCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt die Dauer der Swipe-Geste in Millisekunden an.');
                items.push(swipeMobileSWIPE_DURATIONCompletion);
            }
            if (/.*\s*swipeScreenMobile\s*\(.*/.test(linePrefix)) {
                const swipeScreenMobileGESTURE_DIRECTIONCompletion = new vscode.CompletionItem('GESTURE_DIRECTION');
                swipeScreenMobileGESTURE_DIRECTIONCompletion.kind = vscode.CompletionItemKind.Field;
                swipeScreenMobileGESTURE_DIRECTIONCompletion.insertText = new vscode.SnippetString("GESTURE_DIRECTION = \"${1}\"");
                swipeScreenMobileGESTURE_DIRECTIONCompletion.documentation = new vscode.MarkdownString('Dieser Parameter gibt die Richtung der Swipe-Geste an. M\u00F6glich sind: LEFT_TO_RIGHT, RIGHT_TO_LEFT, BOTTOM_TO_TOP und TOP_TO_BOTTOM.');
                items.push(swipeScreenMobileGESTURE_DIRECTIONCompletion);
                const swipeScreenMobileSWIPE_DURATIONCompletion = new vscode.CompletionItem('SWIPE_DURATION');
                swipeScreenMobileSWIPE_DURATIONCompletion.kind = vscode.CompletionItemKind.Field;
                swipeScreenMobileSWIPE_DURATIONCompletion.insertText = new vscode.SnippetString("SWIPE_DURATION = \"${1}\"");
                swipeScreenMobileSWIPE_DURATIONCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt die Dauer der Swipe-Geste in Millisekunden an. Der Default-Wert betr\u00E4gt \'1000\'.');
                items.push(swipeScreenMobileSWIPE_DURATIONCompletion);
            }
            if (/.*\s*switchContextMobile\s*\(.*/.test(linePrefix)) {
                const switchContextMobileCONTEXT_PREFIXCompletion = new vscode.CompletionItem('CONTEXT_PREFIX');
                switchContextMobileCONTEXT_PREFIXCompletion.kind = vscode.CompletionItemKind.Field;
                switchContextMobileCONTEXT_PREFIXCompletion.insertText = new vscode.SnippetString("CONTEXT_PREFIX = \"${1}\"");
                switchContextMobileCONTEXT_PREFIXCompletion.documentation = new vscode.MarkdownString('Name oder Prefix des Zielcontexts. M\u00F6glich sind: NATIVEAPP, WEBVIEW_1, WEBVIEW usw.');
                items.push(switchContextMobileCONTEXT_PREFIXCompletion);
            }
            if (/.*\s*switchDriver\s*\(.*/.test(linePrefix)) {
                const switchDriverBROWSER_ABBREVIATIONCompletion = new vscode.CompletionItem('BROWSER_ABBREVIATION');
                switchDriverBROWSER_ABBREVIATIONCompletion.kind = vscode.CompletionItemKind.Field;
                switchDriverBROWSER_ABBREVIATIONCompletion.insertText = new vscode.SnippetString("BROWSER_ABBREVIATION = \"${1}\"");
                switchDriverBROWSER_ABBREVIATIONCompletion.documentation = new vscode.MarkdownString('Abk\u00FCrzung f\u00FCr den Browser, in den gewechselt werden soll (FF=Firefox, IE=Internet Explorer, CH=Chrome, SA=Safari)');
                items.push(switchDriverBROWSER_ABBREVIATIONCompletion);
                const switchDriverBROWSER_ALIASCompletion = new vscode.CompletionItem('BROWSER_ALIAS');
                switchDriverBROWSER_ALIASCompletion.kind = vscode.CompletionItemKind.Field;
                switchDriverBROWSER_ALIASCompletion.insertText = new vscode.SnippetString("BROWSER_ALIAS = \"${1}\"");
                switchDriverBROWSER_ALIASCompletion.documentation = new vscode.MarkdownString('(Wird in startWeb festgelegt). Falls mehrere gleichartige Browser ge\u00F6ffnet sind, eindeutiger Alias des anzusprechenden Browsers.');
                items.push(switchDriverBROWSER_ALIASCompletion);
            }
            if (/.*\s*switchFrameMobile\s*\(.*/.test(linePrefix)) {
                const switchFrameMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                switchFrameMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                switchFrameMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                switchFrameMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(switchFrameMobileBY_CRITERIACompletion);
                const switchFrameMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                switchFrameMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                switchFrameMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                switchFrameMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(switchFrameMobileEXPRESSION_TEXTCompletion);
                const switchFrameMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                switchFrameMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                switchFrameMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                switchFrameMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange gewartet werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(switchFrameMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*switchFrameWeb\s*\(.*/.test(linePrefix)) {
                const switchFrameWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                switchFrameWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                switchFrameWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                switchFrameWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Strategie, wie das Element mit Selenium gefunden werden soll (default ist name). Hier kann auch INDEX verwendet werden, um den Frame in ELEMENT_NAME \u00FCber den Index innerhalb der Seite anzusprechen.');
                items.push(switchFrameWebBY_CRITERIACompletion);
                const switchFrameWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                switchFrameWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                switchFrameWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                switchFrameWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Elementname, auf dem die Operation ausgef\u00FChrt werden soll');
                items.push(switchFrameWebELEMENT_NAMECompletion);
                const switchFrameWebWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                switchFrameWebWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                switchFrameWebWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                switchFrameWebWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Wie viele Sekunden soll vor dem Suchen des Frames gewartet werden. Bei zu kurzer Zeit kann es vorkommen, dass der Frame nicht gefunden wird');
                items.push(switchFrameWebWAIT_SECONDSCompletion);
            }
            if (/.*\s*switchWindowWeb\s*\(.*/.test(linePrefix)) {
                const switchWindowWebCLOSE_CURRENT_WINDOWCompletion = new vscode.CompletionItem('CLOSE_CURRENT_WINDOW');
                switchWindowWebCLOSE_CURRENT_WINDOWCompletion.kind = vscode.CompletionItemKind.Field;
                switchWindowWebCLOSE_CURRENT_WINDOWCompletion.insertText = new vscode.SnippetString("CLOSE_CURRENT_WINDOW = \"${1}\"");
                switchWindowWebCLOSE_CURRENT_WINDOWCompletion.documentation = new vscode.MarkdownString('{true,false} Legt fest, ob das aktuell ge\u00F6ffnete Fenster\/Tab zu schlie\u00DFen ist. Default: false');
                items.push(switchWindowWebCLOSE_CURRENT_WINDOWCompletion);
                const switchWindowWebWINDOW_TITLECompletion = new vscode.CompletionItem('WINDOW_TITLE');
                switchWindowWebWINDOW_TITLECompletion.kind = vscode.CompletionItemKind.Field;
                switchWindowWebWINDOW_TITLECompletion.insertText = new vscode.SnippetString("WINDOW_TITLE = \"${1}\"");
                switchWindowWebWINDOW_TITLECompletion.documentation = new vscode.MarkdownString('Name des spezifischen Ziel-Fensters\/Tabs, in das gewechselt werden soll.       Stimmt mit dem Namen des Fensters\/Tabs \u00FCberein, z.B. \'Google\' oder \'M\u00FCnster - Wikipedia\'.       Bei Nicht-Angabe wird in das n\u00E4chste gefundene Fenster\/Tab gewechselt.');
                items.push(switchWindowWebWINDOW_TITLECompletion);
            }
            if (/.*\s*takeScreenshot\s*\(.*/.test(linePrefix)) {
                const takeScreenshotOPTIONAL_PATHCompletion = new vscode.CompletionItem('OPTIONAL_PATH');
                takeScreenshotOPTIONAL_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotOPTIONAL_PATHCompletion.insertText = new vscode.SnippetString("OPTIONAL_PATH = \"${1}\"");
                takeScreenshotOPTIONAL_PATHCompletion.documentation = new vscode.MarkdownString('Optionaler Pfad, an dem ein Screenshot gespeichert werden soll. Mehrere Pfade k\u00F6nnen getrennt durch Semikolon angegeben werden.');
                items.push(takeScreenshotOPTIONAL_PATHCompletion);
                const takeScreenshotWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                takeScreenshotWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                takeScreenshotWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name eines bestimmten Fensters, von dem ein Screenshot erzeugt werden soll. Das Fenster muss auf dem Bildschirm ge\u00F6ffnet sein.             Falls kein solches Fenster mit diesem exakten Namen gefunden wird, wird nach dem ersten Fenster gesucht, das WINDOW_NAME im Titel enth\u00C3\u00A4lt.              Falls auch so ein Fenster nicht gefunden wird, wird der gesamte Bildeschirm fotografiert.');
                items.push(takeScreenshotWINDOW_NAMECompletion);
            }
            if (/.*\s*takeScreenshotElementWeb\s*\(.*/.test(linePrefix)) {
                const takeScreenshotElementWebOPTIONAL_PATHCompletion = new vscode.CompletionItem('OPTIONAL_PATH');
                takeScreenshotElementWebOPTIONAL_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotElementWebOPTIONAL_PATHCompletion.insertText = new vscode.SnippetString("OPTIONAL_PATH = \"${1}\"");
                takeScreenshotElementWebOPTIONAL_PATHCompletion.documentation = new vscode.MarkdownString('Optionaler Pfad zu dem Verzeichnis, in dem ein Screenshot gespeichert werden soll. Mehrere Pfade k\u00F6nnen getrennt durch Semikolon angegeben werden.');
                items.push(takeScreenshotElementWebOPTIONAL_PATHCompletion);
                const takeScreenshotElementWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                takeScreenshotElementWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotElementWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                takeScreenshotElementWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (css, js, xpath, linktext, partiallinktext, tagname, id, name, firstLinkName, class).');
                items.push(takeScreenshotElementWebBY_CRITERIACompletion);
                const takeScreenshotElementWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                takeScreenshotElementWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotElementWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                takeScreenshotElementWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bei SHOT_MODE \'element\': Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(takeScreenshotElementWebELEMENT_NAMECompletion);
            }
            if (/.*\s*takeScreenshotFullWeb\s*\(.*/.test(linePrefix)) {
                const takeScreenshotFullWebOPTIONAL_PATHCompletion = new vscode.CompletionItem('OPTIONAL_PATH');
                takeScreenshotFullWebOPTIONAL_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotFullWebOPTIONAL_PATHCompletion.insertText = new vscode.SnippetString("OPTIONAL_PATH = \"${1}\"");
                takeScreenshotFullWebOPTIONAL_PATHCompletion.documentation = new vscode.MarkdownString('Optionaler Pfad zu dem Verzeichnis, in dem ein Screenshot gespeichert werden soll. Mehrere Pfade k\u00F6nnen getrennt durch Semikolon angegeben werden.');
                items.push(takeScreenshotFullWebOPTIONAL_PATHCompletion);
                const takeScreenshotFullWebAFTER_FIRST_SCROLL_HIDE_ELEMENTSCompletion = new vscode.CompletionItem('AFTER_FIRST_SCROLL_HIDE_ELEMENTS');
                takeScreenshotFullWebAFTER_FIRST_SCROLL_HIDE_ELEMENTSCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotFullWebAFTER_FIRST_SCROLL_HIDE_ELEMENTSCompletion.insertText = new vscode.SnippetString("AFTER_FIRST_SCROLL_HIDE_ELEMENTS = \"${1}\"");
                takeScreenshotFullWebAFTER_FIRST_SCROLL_HIDE_ELEMENTSCompletion.documentation = new vscode.MarkdownString('Elemente, die nach dem ersten Scrollen nicht mehr mitfotografiert werden sollen (z.B. Header-Elemente wie eine Nav-Bar).       Angabe als Komma-separierte Liste von Schl\u00FCssel-Wert-Paaren im Format BY_CRITERIA=ELEMENT_NAME. M\u00F6gliche Werte f\u00FCr BY_CRITERIA: css, js, xpath, linktext, partiallinktext, tagname, id, name, firstLinkName, class.      Beispiel (1 Element): xpath=\/\/*[@id=\'main-header-sticky\']\/div       Beispiel (2 Elemente): css=body > nav, xpath=\/\/*[@id=\'panel\']\/div[3]\/div');
                items.push(takeScreenshotFullWebAFTER_FIRST_SCROLL_HIDE_ELEMENTSCompletion);
                const takeScreenshotFullWebUNTIL_LAST_SCROLL_HIDE_ELEMENTSCompletion = new vscode.CompletionItem('UNTIL_LAST_SCROLL_HIDE_ELEMENTS');
                takeScreenshotFullWebUNTIL_LAST_SCROLL_HIDE_ELEMENTSCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotFullWebUNTIL_LAST_SCROLL_HIDE_ELEMENTSCompletion.insertText = new vscode.SnippetString("UNTIL_LAST_SCROLL_HIDE_ELEMENTS = \"${1}\"");
                takeScreenshotFullWebUNTIL_LAST_SCROLL_HIDE_ELEMENTSCompletion.documentation = new vscode.MarkdownString('Elemente, die erst nach dem letzten Scrollen mitfotografiert werden sollen (z.B. Footer-Elemente wie eine Cookie-Abfrage).       Angabe als Komma-separierte Liste von Schl\u00FCssel-Wert-Paaren im Format BY_CRITERIA=ELEMENT_NAME. M\u00F6gliche Werte f\u00FCr BY_CRITERIA: css, js, xpath, linktext, partiallinktext, tagname, id, name, firstLinkName, class.      Beispiel (1 Element): xpath=\/\/*[@id=\'main-header-sticky\']\/div       Beispiel (2 Elemente): css=body > nav, xpath=\/\/*[@id=\'panel\']\/div[3]\/div');
                items.push(takeScreenshotFullWebUNTIL_LAST_SCROLL_HIDE_ELEMENTSCompletion);
                const takeScreenshotFullWebSCROLL_TIMEOUT_BEFORE_SCROLLCompletion = new vscode.CompletionItem('SCROLL_TIMEOUT_BEFORE_SCROLL');
                takeScreenshotFullWebSCROLL_TIMEOUT_BEFORE_SCROLLCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotFullWebSCROLL_TIMEOUT_BEFORE_SCROLLCompletion.insertText = new vscode.SnippetString("SCROLL_TIMEOUT_BEFORE_SCROLL = \"${1}\"");
                takeScreenshotFullWebSCROLL_TIMEOUT_BEFORE_SCROLLCompletion.documentation = new vscode.MarkdownString('Wartezeit in Millisekunden, die vor jedem Scroll gewartet werden soll. (Default: 0)');
                items.push(takeScreenshotFullWebSCROLL_TIMEOUT_BEFORE_SCROLLCompletion);
                const takeScreenshotFullWebSCROLL_TIMEOUT_AFTER_SCROLLCompletion = new vscode.CompletionItem('SCROLL_TIMEOUT_AFTER_SCROLL');
                takeScreenshotFullWebSCROLL_TIMEOUT_AFTER_SCROLLCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotFullWebSCROLL_TIMEOUT_AFTER_SCROLLCompletion.insertText = new vscode.SnippetString("SCROLL_TIMEOUT_AFTER_SCROLL = \"${1}\"");
                takeScreenshotFullWebSCROLL_TIMEOUT_AFTER_SCROLLCompletion.documentation = new vscode.MarkdownString('Wartezeit in Millisekunden, die nach jedem Scroll gewartet werden soll. (Default: 100)');
                items.push(takeScreenshotFullWebSCROLL_TIMEOUT_AFTER_SCROLLCompletion);
                const takeScreenshotFullWebDEVICE_PIXEL_RATIOCompletion = new vscode.CompletionItem('DEVICE_PIXEL_RATIO');
                takeScreenshotFullWebDEVICE_PIXEL_RATIOCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotFullWebDEVICE_PIXEL_RATIOCompletion.insertText = new vscode.SnippetString("DEVICE_PIXEL_RATIO = \"${1}\"");
                takeScreenshotFullWebDEVICE_PIXEL_RATIOCompletion.documentation = new vscode.MarkdownString('Manuelle Angabe der Device-Pixel-Ratio. L\u00E4sst sich mit JavaScript-Befehl \'Window.devicePixelRatio\' ermitteln (Default: automatische Ermittlung im Browser. Falls nicht m\u00F6glich: 1).');
                items.push(takeScreenshotFullWebDEVICE_PIXEL_RATIOCompletion);
                const takeScreenshotFullWebSCROLL_BACKCompletion = new vscode.CompletionItem('SCROLL_BACK');
                takeScreenshotFullWebSCROLL_BACKCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotFullWebSCROLL_BACKCompletion.insertText = new vscode.SnippetString("SCROLL_BACK = \"${1}\"");
                takeScreenshotFullWebSCROLL_BACKCompletion.documentation = new vscode.MarkdownString('Soll nach dem Scrollen von oben nach unten wieder zur\u00FCck an den Ausgangspunkt gescrollt werden? (Default: true)');
                items.push(takeScreenshotFullWebSCROLL_BACKCompletion);
            }
            if (/.*\s*takeScreenshotWeb\s*\(.*/.test(linePrefix)) {
                const takeScreenshotWebOPTIONAL_PATHCompletion = new vscode.CompletionItem('OPTIONAL_PATH');
                takeScreenshotWebOPTIONAL_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotWebOPTIONAL_PATHCompletion.insertText = new vscode.SnippetString("OPTIONAL_PATH = \"${1}\"");
                takeScreenshotWebOPTIONAL_PATHCompletion.documentation = new vscode.MarkdownString('Optionaler Pfad zu dem Verzeichnis, in dem ein Screenshot gespeichert werden soll. Mehrere Pfade k\u00F6nnen getrennt durch Semikolon angegeben werden.');
                items.push(takeScreenshotWebOPTIONAL_PATHCompletion);
                const takeScreenshotWebSHOT_MODECompletion = new vscode.CompletionItem('SHOT_MODE');
                takeScreenshotWebSHOT_MODECompletion.kind = vscode.CompletionItemKind.Field;
                takeScreenshotWebSHOT_MODECompletion.insertText = new vscode.SnippetString("SHOT_MODE = \"${1}\"");
                takeScreenshotWebSHOT_MODECompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, in welchem Modus der Screenshot aufgenommen werden soll.       M\u00F6glich sind:      os (default. Kompletter Bildschirm, inklusive Browserfenster. Nutzt das Betriebssystem. Funktioniert nicht, wenn der Brwoser im Headless-Modus ist!),      browser (aktueller Webseitenausschnitt. Nutzt den WebDriver.)');
                items.push(takeScreenshotWebSHOT_MODECompletion);
            }
            if (/.*\s*tapMobile\s*\(.*/.test(linePrefix)) {
                const tapMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                tapMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                tapMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                tapMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(tapMobileBY_CRITERIACompletion);
                const tapMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                tapMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                tapMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                tapMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(tapMobileEXPRESSION_TEXTCompletion);
                const tapMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                tapMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                tapMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                tapMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt an, wie lange vor dem Klick auf das Element gewartet werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(tapMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*tapPositionMobile\s*\(.*/.test(linePrefix)) {
                const tapPositionMobileXCompletion = new vscode.CompletionItem('X');
                tapPositionMobileXCompletion.kind = vscode.CompletionItemKind.Field;
                tapPositionMobileXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                tapPositionMobileXCompletion.documentation = new vscode.MarkdownString('Der Parameter ist ein Pflichtparameter, der die X-Koordinate des Punktes in Pixeln angibt, auf den geklickt werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(tapPositionMobileXCompletion);
                const tapPositionMobileYCompletion = new vscode.CompletionItem('Y');
                tapPositionMobileYCompletion.kind = vscode.CompletionItemKind.Field;
                tapPositionMobileYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                tapPositionMobileYCompletion.documentation = new vscode.MarkdownString('Der Parameter ist ein Pflichtparameter, der die Y-Koordinate des Punktes in Pixeln angibt, auf den geklickt werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(tapPositionMobileYCompletion);
            }
            if (/.*\s*then\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*timeout\s*\(.*/.test(linePrefix)) {
                const timeoutMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                timeoutMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                timeoutMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                timeoutMESSAGECompletion.documentation = new vscode.MarkdownString('Nachricht, die im Bericht angezeigt werden soll.');
                items.push(timeoutMESSAGECompletion);
            }
            if (/.*\s*touchMobile\s*\(.*/.test(linePrefix)) {
                const touchMobileNUMBER_OF_FINGERSCompletion = new vscode.CompletionItem('NUMBER_OF_FINGERS');
                touchMobileNUMBER_OF_FINGERSCompletion.kind = vscode.CompletionItemKind.Field;
                touchMobileNUMBER_OF_FINGERSCompletion.insertText = new vscode.SnippetString("NUMBER_OF_FINGERS = \"${1}\"");
                touchMobileNUMBER_OF_FINGERSCompletion.documentation = new vscode.MarkdownString('Anzahl der Finger die den Bildschirm ber\u00FChren d\u00FCrfen. Default 1');
                items.push(touchMobileNUMBER_OF_FINGERSCompletion);
                const touchMobileX_POSITIONCompletion = new vscode.CompletionItem('X_POSITION');
                touchMobileX_POSITIONCompletion.kind = vscode.CompletionItemKind.Field;
                touchMobileX_POSITIONCompletion.insertText = new vscode.SnippetString("X_POSITION = \"${1}\"");
                touchMobileX_POSITIONCompletion.documentation = new vscode.MarkdownString('Der Parameter ist ein Pflichtparameter, der die X-Koordinate des Punktes in Pixeln angibt, der ber\u00FChrt wird. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(touchMobileX_POSITIONCompletion);
                const touchMobileY_POSITIONCompletion = new vscode.CompletionItem('Y_POSITION');
                touchMobileY_POSITIONCompletion.kind = vscode.CompletionItemKind.Field;
                touchMobileY_POSITIONCompletion.insertText = new vscode.SnippetString("Y_POSITION = \"${1}\"");
                touchMobileY_POSITIONCompletion.documentation = new vscode.MarkdownString('Der Parameter ist ein Pflichtparameter, der die X-Koordinate des Punktes in Pixeln angibt, der ber\u00FChrt wird. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(touchMobileY_POSITIONCompletion);
                const touchMobileTOUCH_DURATIONCompletion = new vscode.CompletionItem('TOUCH_DURATION');
                touchMobileTOUCH_DURATIONCompletion.kind = vscode.CompletionItemKind.Field;
                touchMobileTOUCH_DURATIONCompletion.insertText = new vscode.SnippetString("TOUCH_DURATION = \"${1}\"");
                touchMobileTOUCH_DURATIONCompletion.documentation = new vscode.MarkdownString('Gibt an, wie lange der Punkt auf dem Bildschirm gedr\u00FCckt werden soll');
                items.push(touchMobileTOUCH_DURATIONCompletion);
            }
            if (/.*\s*uiAction\s*\(.*/.test(linePrefix)) {
                const uiActionWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiActionWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiActionWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiActionWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiActionWINDOW_NAMECompletion);
                const uiActionUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiActionUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiActionUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiActionUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiActionUIA_SELECTORCompletion);
                const uiActionACTIONCompletion = new vscode.CompletionItem('ACTION');
                uiActionACTIONCompletion.kind = vscode.CompletionItemKind.Field;
                uiActionACTIONCompletion.insertText = new vscode.SnippetString("ACTION = \"${1}\"");
                uiActionACTIONCompletion.documentation = new vscode.MarkdownString('Auszuf\u00FChrende Aktion, vgl. Beschreibung des Treibers');
                items.push(uiActionACTIONCompletion);
                const uiActionPARAM1Completion = new vscode.CompletionItem('PARAM1');
                uiActionPARAM1Completion.kind = vscode.CompletionItemKind.Field;
                uiActionPARAM1Completion.insertText = new vscode.SnippetString("PARAM1 = \"${1}\"");
                uiActionPARAM1Completion.documentation = new vscode.MarkdownString('Parameter f\u00FCr die auszuf\u00FChrende Aktion');
                items.push(uiActionPARAM1Completion);
                const uiActionPARAM2Completion = new vscode.CompletionItem('PARAM2');
                uiActionPARAM2Completion.kind = vscode.CompletionItemKind.Field;
                uiActionPARAM2Completion.insertText = new vscode.SnippetString("PARAM2 = \"${1}\"");
                uiActionPARAM2Completion.documentation = new vscode.MarkdownString('Parameter f\u00FCr die auszuf\u00FChrende Aktion');
                items.push(uiActionPARAM2Completion);
                const uiActionPARAM3Completion = new vscode.CompletionItem('PARAM3');
                uiActionPARAM3Completion.kind = vscode.CompletionItemKind.Field;
                uiActionPARAM3Completion.insertText = new vscode.SnippetString("PARAM3 = \"${1}\"");
                uiActionPARAM3Completion.documentation = new vscode.MarkdownString('Parameter f\u00FCr die auszuf\u00FChrende Aktion');
                items.push(uiActionPARAM3Completion);
                const uiActionPARAM4Completion = new vscode.CompletionItem('PARAM4');
                uiActionPARAM4Completion.kind = vscode.CompletionItemKind.Field;
                uiActionPARAM4Completion.insertText = new vscode.SnippetString("PARAM4 = \"${1}\"");
                uiActionPARAM4Completion.documentation = new vscode.MarkdownString('Parameter f\u00FCr die auszuf\u00FChrende Aktion');
                items.push(uiActionPARAM4Completion);
                const uiActionTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                uiActionTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                uiActionTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                uiActionTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(uiActionTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*uiClick\s*\(.*/.test(linePrefix)) {
                const uiClickWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiClickWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiClickWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiClickWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiClickWINDOW_NAMECompletion);
                const uiClickUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiClickUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiClickUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiClickUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiClickUIA_SELECTORCompletion);
                const uiClickXCompletion = new vscode.CompletionItem('X');
                uiClickXCompletion.kind = vscode.CompletionItemKind.Field;
                uiClickXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                uiClickXCompletion.documentation = new vscode.MarkdownString('X-Koordinate');
                items.push(uiClickXCompletion);
                const uiClickYCompletion = new vscode.CompletionItem('Y');
                uiClickYCompletion.kind = vscode.CompletionItemKind.Field;
                uiClickYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                uiClickYCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(uiClickYCompletion);
            }
            if (/.*\s*uiDoubleclick\s*\(.*/.test(linePrefix)) {
                const uiDoubleclickWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiDoubleclickWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiDoubleclickWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiDoubleclickWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiDoubleclickWINDOW_NAMECompletion);
                const uiDoubleclickUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiDoubleclickUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiDoubleclickUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiDoubleclickUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiDoubleclickUIA_SELECTORCompletion);
                const uiDoubleclickXCompletion = new vscode.CompletionItem('X');
                uiDoubleclickXCompletion.kind = vscode.CompletionItemKind.Field;
                uiDoubleclickXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                uiDoubleclickXCompletion.documentation = new vscode.MarkdownString('X-Koordinate');
                items.push(uiDoubleclickXCompletion);
                const uiDoubleclickYCompletion = new vscode.CompletionItem('Y');
                uiDoubleclickYCompletion.kind = vscode.CompletionItemKind.Field;
                uiDoubleclickYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                uiDoubleclickYCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(uiDoubleclickYCompletion);
            }
            if (/.*\s*uiGetProperty\s*\(.*/.test(linePrefix)) {
                const uiGetPropertyWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiGetPropertyWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiGetPropertyWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiGetPropertyWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiGetPropertyWINDOW_NAMECompletion);
                const uiGetPropertyUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiGetPropertyUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiGetPropertyUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiGetPropertyUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiGetPropertyUIA_SELECTORCompletion);
                const uiGetPropertyPROPERTYNAMECompletion = new vscode.CompletionItem('PROPERTYNAME');
                uiGetPropertyPROPERTYNAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiGetPropertyPROPERTYNAMECompletion.insertText = new vscode.SnippetString("PROPERTYNAME = \"${1}\"");
                uiGetPropertyPROPERTYNAMECompletion.documentation = new vscode.MarkdownString('Name der Property.');
                items.push(uiGetPropertyPROPERTYNAMECompletion);
                const uiGetPropertyTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                uiGetPropertyTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                uiGetPropertyTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                uiGetPropertyTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(uiGetPropertyTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*uiGetValue\s*\(.*/.test(linePrefix)) {
                const uiGetValueWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiGetValueWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiGetValueWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiGetValueWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiGetValueWINDOW_NAMECompletion);
                const uiGetValueUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiGetValueUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiGetValueUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiGetValueUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiGetValueUIA_SELECTORCompletion);
                const uiGetValueTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                uiGetValueTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                uiGetValueTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                uiGetValueTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(uiGetValueTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*uiMove\s*\(.*/.test(linePrefix)) {
                const uiMoveWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiMoveWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiMoveWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiMoveWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiMoveWINDOW_NAMECompletion);
                const uiMoveUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiMoveUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiMoveUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiMoveUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiMoveUIA_SELECTORCompletion);
                const uiMoveXCompletion = new vscode.CompletionItem('X');
                uiMoveXCompletion.kind = vscode.CompletionItemKind.Field;
                uiMoveXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                uiMoveXCompletion.documentation = new vscode.MarkdownString('X-Koordinate');
                items.push(uiMoveXCompletion);
                const uiMoveYCompletion = new vscode.CompletionItem('Y');
                uiMoveYCompletion.kind = vscode.CompletionItemKind.Field;
                uiMoveYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                uiMoveYCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(uiMoveYCompletion);
            }
            if (/.*\s*uiMoveMouse\s*\(.*/.test(linePrefix)) {
                const uiMoveMouseWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiMoveMouseWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiMoveMouseWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiMoveMouseWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiMoveMouseWINDOW_NAMECompletion);
                const uiMoveMouseUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiMoveMouseUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiMoveMouseUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiMoveMouseUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiMoveMouseUIA_SELECTORCompletion);
                const uiMoveMouseXCompletion = new vscode.CompletionItem('X');
                uiMoveMouseXCompletion.kind = vscode.CompletionItemKind.Field;
                uiMoveMouseXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                uiMoveMouseXCompletion.documentation = new vscode.MarkdownString('X-Koordinate');
                items.push(uiMoveMouseXCompletion);
                const uiMoveMouseYCompletion = new vscode.CompletionItem('Y');
                uiMoveMouseYCompletion.kind = vscode.CompletionItemKind.Field;
                uiMoveMouseYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                uiMoveMouseYCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(uiMoveMouseYCompletion);
            }
            if (/.*\s*uiRightclick\s*\(.*/.test(linePrefix)) {
                const uiRightclickWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiRightclickWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiRightclickWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiRightclickWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiRightclickWINDOW_NAMECompletion);
                const uiRightclickUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiRightclickUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiRightclickUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiRightclickUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiRightclickUIA_SELECTORCompletion);
                const uiRightclickXCompletion = new vscode.CompletionItem('X');
                uiRightclickXCompletion.kind = vscode.CompletionItemKind.Field;
                uiRightclickXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                uiRightclickXCompletion.documentation = new vscode.MarkdownString('X-Koordinate');
                items.push(uiRightclickXCompletion);
                const uiRightclickYCompletion = new vscode.CompletionItem('Y');
                uiRightclickYCompletion.kind = vscode.CompletionItemKind.Field;
                uiRightclickYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                uiRightclickYCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(uiRightclickYCompletion);
            }
            if (/.*\s*uiSend\s*\(.*/.test(linePrefix)) {
                const uiSendWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiSendWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiSendWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiSendWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiSendWINDOW_NAMECompletion);
                const uiSendUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiSendUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiSendUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiSendUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiSendUIA_SELECTORCompletion);
                const uiSendTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                uiSendTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                uiSendTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                uiSendTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Zu sendender Text');
                items.push(uiSendTEXT_TO_SENDCompletion);
            }
            if (/.*\s*uiSetValue\s*\(.*/.test(linePrefix)) {
                const uiSetValueWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiSetValueWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiSetValueWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiSetValueWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiSetValueWINDOW_NAMECompletion);
                const uiSetValueUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiSetValueUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiSetValueUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiSetValueUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, welches bedient werden soll');
                items.push(uiSetValueUIA_SELECTORCompletion);
                const uiSetValueVALUECompletion = new vscode.CompletionItem('VALUE');
                uiSetValueVALUECompletion.kind = vscode.CompletionItemKind.Field;
                uiSetValueVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                uiSetValueVALUECompletion.documentation = new vscode.MarkdownString('Zu setzender Wert');
                items.push(uiSetValueVALUECompletion);
            }
            if (/.*\s*uiWaitFor\s*\(.*/.test(linePrefix)) {
                const uiWaitForWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                uiWaitForWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                uiWaitForWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                uiWaitForWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters (Kann auch als Selektor beschrieben werden)');
                items.push(uiWaitForWINDOW_NAMECompletion);
                const uiWaitForUIA_SELECTORCompletion = new vscode.CompletionItem('UIA_SELECTOR');
                uiWaitForUIA_SELECTORCompletion.kind = vscode.CompletionItemKind.Field;
                uiWaitForUIA_SELECTORCompletion.insertText = new vscode.SnippetString("UIA_SELECTOR = \"${1}\"");
                uiWaitForUIA_SELECTORCompletion.documentation = new vscode.MarkdownString('Zielelement, auf welches gewartet werden soll');
                items.push(uiWaitForUIA_SELECTORCompletion);
                const uiWaitForTIMEOUT_IN_SECONDSCompletion = new vscode.CompletionItem('TIMEOUT_IN_SECONDS');
                uiWaitForTIMEOUT_IN_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                uiWaitForTIMEOUT_IN_SECONDSCompletion.insertText = new vscode.SnippetString("TIMEOUT_IN_SECONDS = \"${1}\"");
                uiWaitForTIMEOUT_IN_SECONDSCompletion.documentation = new vscode.MarkdownString('Timeout Wartezeit');
                items.push(uiWaitForTIMEOUT_IN_SECONDSCompletion);
            }
            if (/.*\s*verifyNameByAutomationIdWinEle\s*\(.*/.test(linePrefix)) {
                const verifyNameByAutomationIdWinEleWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                verifyNameByAutomationIdWinEleWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                verifyNameByAutomationIdWinEleWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                verifyNameByAutomationIdWinEleWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Name des Fensters, das das zu steuernde Element enth\u00E4lt.');
                items.push(verifyNameByAutomationIdWinEleWINDOW_NAMECompletion);
                const verifyNameByAutomationIdWinElePROCESS_NAMECompletion = new vscode.CompletionItem('PROCESS_NAME');
                verifyNameByAutomationIdWinElePROCESS_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                verifyNameByAutomationIdWinElePROCESS_NAMECompletion.insertText = new vscode.SnippetString("PROCESS_NAME = \"${1}\"");
                verifyNameByAutomationIdWinElePROCESS_NAMECompletion.documentation = new vscode.MarkdownString('Name des Prozesses, zu dem das zu steuernde Fenster geh\u00F6rt. Dieser kann z.B. \u00FCber den Windows-Task-Manager ermittelt werden.');
                items.push(verifyNameByAutomationIdWinElePROCESS_NAMECompletion);
                const verifyNameByAutomationIdWinEleAUTOMATION_IDCompletion = new vscode.CompletionItem('AUTOMATION_ID');
                verifyNameByAutomationIdWinEleAUTOMATION_IDCompletion.kind = vscode.CompletionItemKind.Field;
                verifyNameByAutomationIdWinEleAUTOMATION_IDCompletion.insertText = new vscode.SnippetString("AUTOMATION_ID = \"${1}\"");
                verifyNameByAutomationIdWinEleAUTOMATION_IDCompletion.documentation = new vscode.MarkdownString('Automation-ID des Elementes, dessen Name ermittelt werden soll. Es ist m\u00F6glich mit Werkzeugen wie z.B. \'UISpy\' diese zu ermitteln.');
                items.push(verifyNameByAutomationIdWinEleAUTOMATION_IDCompletion);
                const verifyNameByAutomationIdWinEleELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                verifyNameByAutomationIdWinEleELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                verifyNameByAutomationIdWinEleELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                verifyNameByAutomationIdWinEleELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Name des Elements, das \u00FCber die Automation-ID gefunden wurde.');
                items.push(verifyNameByAutomationIdWinEleELEMENT_NAMECompletion);
            }
            if (/.*\s*wait\s*\(.*/.test(linePrefix)) {
                const waitWAIT_MILLISECONDSCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS');
                waitWAIT_MILLISECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitWAIT_MILLISECONDSCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS = \"${1}\"");
                waitWAIT_MILLISECONDSCompletion.documentation = new vscode.MarkdownString('Wartezeit in Millisekunden');
                items.push(waitWAIT_MILLISECONDSCompletion);
            }
            if (/.*\s*waitForAjax\s*\(.*/.test(linePrefix)) {
                const waitForAjaxWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                waitForAjaxWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForAjaxWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                waitForAjaxWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Anzahl Sekunden, die das Kommando maximal wartet bis keine Ajax-Kommunikation mehr stattfindet.      Default einstellbar \u00FCber Konfigurations-Parameter \'defaultAjaxWaitTimeoutInSeconds\'.');
                items.push(waitForAjaxWAIT_SECONDSCompletion);
            }
            if (/.*\s*waitForElementNotVisibleWeb\s*\(.*/.test(linePrefix)) {
                const waitForElementNotVisibleWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                waitForElementNotVisibleWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementNotVisibleWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                waitForElementNotVisibleWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(waitForElementNotVisibleWebBY_CRITERIACompletion);
                const waitForElementNotVisibleWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                waitForElementNotVisibleWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementNotVisibleWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                waitForElementNotVisibleWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(waitForElementNotVisibleWebELEMENT_NAMECompletion);
                const waitForElementNotVisibleWebWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                waitForElementNotVisibleWebWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementNotVisibleWebWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                waitForElementNotVisibleWebWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Wartezeit in Sekunden.');
                items.push(waitForElementNotVisibleWebWAIT_SECONDSCompletion);
            }
            if (/.*\s*waitForElementVisibleWeb\s*\(.*/.test(linePrefix)) {
                const waitForElementVisibleWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                waitForElementVisibleWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementVisibleWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                waitForElementVisibleWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(waitForElementVisibleWebBY_CRITERIACompletion);
                const waitForElementVisibleWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                waitForElementVisibleWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementVisibleWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                waitForElementVisibleWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(waitForElementVisibleWebELEMENT_NAMECompletion);
                const waitForElementVisibleWebWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                waitForElementVisibleWebWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementVisibleWebWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                waitForElementVisibleWebWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Wartezeit in Sekunden.');
                items.push(waitForElementVisibleWebWAIT_SECONDSCompletion);
            }
            if (/.*\s*waitForElementWeb\s*\(.*/.test(linePrefix)) {
                const waitForElementWebBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                waitForElementWebBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementWebBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                waitForElementWebBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(waitForElementWebBY_CRITERIACompletion);
                const waitForElementWebELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                waitForElementWebELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementWebELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                waitForElementWebELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(waitForElementWebELEMENT_NAMECompletion);
                const waitForElementWebWAIT_MILLISECONDSCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS');
                waitForElementWebWAIT_MILLISECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementWebWAIT_MILLISECONDSCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS = \"${1}\"");
                waitForElementWebWAIT_MILLISECONDSCompletion.documentation = new vscode.MarkdownString('Wartezeit in Millisekunden.');
                items.push(waitForElementWebWAIT_MILLISECONDSCompletion);
            }
            if (/.*\s*waitForElementWebVisible\s*\(.*/.test(linePrefix)) {
                const waitForElementWebVisibleBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                waitForElementWebVisibleBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementWebVisibleBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                waitForElementWebVisibleBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll. Typisch sind xpath oder css. linktext oder id k\u00F6nnen ebenfalls verwendet werden. Default ist name.');
                items.push(waitForElementWebVisibleBY_CRITERIACompletion);
                const waitForElementWebVisibleELEMENT_NAMECompletion = new vscode.CompletionItem('ELEMENT_NAME');
                waitForElementWebVisibleELEMENT_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementWebVisibleELEMENT_NAMECompletion.insertText = new vscode.SnippetString("ELEMENT_NAME = \"${1}\"");
                waitForElementWebVisibleELEMENT_NAMECompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(waitForElementWebVisibleELEMENT_NAMECompletion);
                const waitForElementWebVisibleWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                waitForElementWebVisibleWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForElementWebVisibleWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                waitForElementWebVisibleWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Wartezeit in Sekunden.');
                items.push(waitForElementWebVisibleWAIT_SECONDSCompletion);
            }
            if (/.*\s*waitForFileNotExists\s*\(.*/.test(linePrefix)) {
                const waitForFileNotExistsFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                waitForFileNotExistsFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForFileNotExistsFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                waitForFileNotExistsFILENAMECompletion.documentation = new vscode.MarkdownString('Name der zu suchenden Datei');
                items.push(waitForFileNotExistsFILENAMECompletion);
                const waitForFileNotExistsTRIESCompletion = new vscode.CompletionItem('TRIES');
                waitForFileNotExistsTRIESCompletion.kind = vscode.CompletionItemKind.Field;
                waitForFileNotExistsTRIESCompletion.insertText = new vscode.SnippetString("TRIES = \"${1}\"");
                waitForFileNotExistsTRIESCompletion.documentation = new vscode.MarkdownString('Anzahl Versuche (ganzahlig), die nach der Datei gesucht werden soll.');
                items.push(waitForFileNotExistsTRIESCompletion);
                const waitForFileNotExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS_BETWEEN_TRIES');
                waitForFileNotExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion.kind = vscode.CompletionItemKind.Field;
                waitForFileNotExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS_BETWEEN_TRIES = \"${1}\"");
                waitForFileNotExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion.documentation = new vscode.MarkdownString('Wartezeit, nachdem die Datei nicht gefunden wurde in Millisekunden.');
                items.push(waitForFileNotExistsWAIT_MILLISECONDS_BETWEEN_TRIESCompletion);
            }
            if (/.*\s*waitForImage\s*\(.*/.test(linePrefix)) {
                const waitForImageIMAGE_PATHCompletion = new vscode.CompletionItem('IMAGE_PATH');
                waitForImageIMAGE_PATHCompletion.kind = vscode.CompletionItemKind.Field;
                waitForImageIMAGE_PATHCompletion.insertText = new vscode.SnippetString("IMAGE_PATH = \"${1}\"");
                waitForImageIMAGE_PATHCompletion.documentation = new vscode.MarkdownString('Relativer Pfad zu dem Bild');
                items.push(waitForImageIMAGE_PATHCompletion);
                const waitForImageBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                waitForImageBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                waitForImageBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                waitForImageBASEDIRCompletion.documentation = new vscode.MarkdownString('Base Directory');
                items.push(waitForImageBASEDIRCompletion);
                const waitForImageSECONDSCompletion = new vscode.CompletionItem('SECONDS');
                waitForImageSECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForImageSECONDSCompletion.insertText = new vscode.SnippetString("SECONDS = \"${1}\"");
                waitForImageSECONDSCompletion.documentation = new vscode.MarkdownString('Die Sekunden wie lange gewartet werden soll.');
                items.push(waitForImageSECONDSCompletion);
                const waitForImageTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                waitForImageTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                waitForImageTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                waitForImageTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(waitForImageTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*waitForJava\s*\(.*/.test(linePrefix)) {
                const waitForJavaTARGETCompletion = new vscode.CompletionItem('TARGET');
                waitForJavaTARGETCompletion.kind = vscode.CompletionItemKind.Field;
                waitForJavaTARGETCompletion.insertText = new vscode.SnippetString("TARGET = \"${1}\"");
                waitForJavaTARGETCompletion.documentation = new vscode.MarkdownString('Ziel');
                items.push(waitForJavaTARGETCompletion);
                const waitForJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                waitForJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                waitForJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                waitForJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(waitForJavaWAIT_MILLISCompletion);
                const waitForJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                waitForJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                waitForJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(waitForJavaBY_NAMECompletion);
            }
            if (/.*\s*waitForPictureToDisappearWin\s*\(.*/.test(linePrefix)) {
                const waitForPictureToDisappearWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                waitForPictureToDisappearWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                waitForPictureToDisappearWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(waitForPictureToDisappearWinWINDOW_NAMECompletion);
                const waitForPictureToDisappearWinRELATIVE_PATH_IMAGECompletion = new vscode.CompletionItem('RELATIVE_PATH_IMAGE');
                waitForPictureToDisappearWinRELATIVE_PATH_IMAGECompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinRELATIVE_PATH_IMAGECompletion.insertText = new vscode.SnippetString("RELATIVE_PATH_IMAGE = \"${1}\"");
                waitForPictureToDisappearWinRELATIVE_PATH_IMAGECompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(waitForPictureToDisappearWinRELATIVE_PATH_IMAGECompletion);
                const waitForPictureToDisappearWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                waitForPictureToDisappearWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                waitForPictureToDisappearWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(waitForPictureToDisappearWinBASEDIRCompletion);
                const waitForPictureToDisappearWinWAIT_MILLISECONDSCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS');
                waitForPictureToDisappearWinWAIT_MILLISECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinWAIT_MILLISECONDSCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS = \"${1}\"");
                waitForPictureToDisappearWinWAIT_MILLISECONDSCompletion.documentation = new vscode.MarkdownString('Wartezeit, die akzeptabel ist. Danach wird ein Fehler gemeldet.');
                items.push(waitForPictureToDisappearWinWAIT_MILLISECONDSCompletion);
                const waitForPictureToDisappearWinMAX_RETRIESCompletion = new vscode.CompletionItem('MAX_RETRIES');
                waitForPictureToDisappearWinMAX_RETRIESCompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinMAX_RETRIESCompletion.insertText = new vscode.SnippetString("MAX_RETRIES = \"${1}\"");
                waitForPictureToDisappearWinMAX_RETRIESCompletion.documentation = new vscode.MarkdownString('Maximale Anzahl Versuche');
                items.push(waitForPictureToDisappearWinMAX_RETRIESCompletion);
                const waitForPictureToDisappearWinX1Completion = new vscode.CompletionItem('X1');
                waitForPictureToDisappearWinX1Completion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinX1Completion.insertText = new vscode.SnippetString("X1 = \"${1}\"");
                waitForPictureToDisappearWinX1Completion.documentation = new vscode.MarkdownString('Linke Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(waitForPictureToDisappearWinX1Completion);
                const waitForPictureToDisappearWinY1Completion = new vscode.CompletionItem('Y1');
                waitForPictureToDisappearWinY1Completion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinY1Completion.insertText = new vscode.SnippetString("Y1 = \"${1}\"");
                waitForPictureToDisappearWinY1Completion.documentation = new vscode.MarkdownString('Obere Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(waitForPictureToDisappearWinY1Completion);
                const waitForPictureToDisappearWinX2Completion = new vscode.CompletionItem('X2');
                waitForPictureToDisappearWinX2Completion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinX2Completion.insertText = new vscode.SnippetString("X2 = \"${1}\"");
                waitForPictureToDisappearWinX2Completion.documentation = new vscode.MarkdownString('Rechte Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(waitForPictureToDisappearWinX2Completion);
                const waitForPictureToDisappearWinY2Completion = new vscode.CompletionItem('Y2');
                waitForPictureToDisappearWinY2Completion.kind = vscode.CompletionItemKind.Field;
                waitForPictureToDisappearWinY2Completion.insertText = new vscode.SnippetString("Y2 = \"${1}\"");
                waitForPictureToDisappearWinY2Completion.documentation = new vscode.MarkdownString('Untere Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(waitForPictureToDisappearWinY2Completion);
            }
            if (/.*\s*waitForPictureWin\s*\(.*/.test(linePrefix)) {
                const waitForPictureWinWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                waitForPictureWinWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                waitForPictureWinWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Fenstername');
                items.push(waitForPictureWinWINDOW_NAMECompletion);
                const waitForPictureWinRELATIVE_PATH_IMAGECompletion = new vscode.CompletionItem('RELATIVE_PATH_IMAGE');
                waitForPictureWinRELATIVE_PATH_IMAGECompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinRELATIVE_PATH_IMAGECompletion.insertText = new vscode.SnippetString("RELATIVE_PATH_IMAGE = \"${1}\"");
                waitForPictureWinRELATIVE_PATH_IMAGECompletion.documentation = new vscode.MarkdownString('Pfad zum Bild ');
                items.push(waitForPictureWinRELATIVE_PATH_IMAGECompletion);
                const waitForPictureWinBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                waitForPictureWinBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                waitForPictureWinBASEDIRCompletion.documentation = new vscode.MarkdownString('Angabe des Basisverzeichnisses');
                items.push(waitForPictureWinBASEDIRCompletion);
                const waitForPictureWinWAIT_MILLISECONDSCompletion = new vscode.CompletionItem('WAIT_MILLISECONDS');
                waitForPictureWinWAIT_MILLISECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinWAIT_MILLISECONDSCompletion.insertText = new vscode.SnippetString("WAIT_MILLISECONDS = \"${1}\"");
                waitForPictureWinWAIT_MILLISECONDSCompletion.documentation = new vscode.MarkdownString('Wartezeit, die akzeptabel ist. Danach wird ein Fehler gemeldet.');
                items.push(waitForPictureWinWAIT_MILLISECONDSCompletion);
                const waitForPictureWinMAX_RETRIESCompletion = new vscode.CompletionItem('MAX_RETRIES');
                waitForPictureWinMAX_RETRIESCompletion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinMAX_RETRIESCompletion.insertText = new vscode.SnippetString("MAX_RETRIES = \"${1}\"");
                waitForPictureWinMAX_RETRIESCompletion.documentation = new vscode.MarkdownString('Maximale Anzahl Versuche');
                items.push(waitForPictureWinMAX_RETRIESCompletion);
                const waitForPictureWinX1Completion = new vscode.CompletionItem('X1');
                waitForPictureWinX1Completion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinX1Completion.insertText = new vscode.SnippetString("X1 = \"${1}\"");
                waitForPictureWinX1Completion.documentation = new vscode.MarkdownString('Linke Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(waitForPictureWinX1Completion);
                const waitForPictureWinY1Completion = new vscode.CompletionItem('Y1');
                waitForPictureWinY1Completion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinY1Completion.insertText = new vscode.SnippetString("Y1 = \"${1}\"");
                waitForPictureWinY1Completion.documentation = new vscode.MarkdownString('Obere Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(waitForPictureWinY1Completion);
                const waitForPictureWinX2Completion = new vscode.CompletionItem('X2');
                waitForPictureWinX2Completion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinX2Completion.insertText = new vscode.SnippetString("X2 = \"${1}\"");
                waitForPictureWinX2Completion.documentation = new vscode.MarkdownString('Rechte Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(waitForPictureWinX2Completion);
                const waitForPictureWinY2Completion = new vscode.CompletionItem('Y2');
                waitForPictureWinY2Completion.kind = vscode.CompletionItemKind.Field;
                waitForPictureWinY2Completion.insertText = new vscode.SnippetString("Y2 = \"${1}\"");
                waitForPictureWinY2Completion.documentation = new vscode.MarkdownString('Untere Begrenzung des Suchbereichs. Wert wird absolut zur linken, oberen Ecke des Fensters angegeben');
                items.push(waitForPictureWinY2Completion);
            }
            if (/.*\s*waitForTextJava\s*\(.*/.test(linePrefix)) {
                const waitForTextJavaTEXTCompletion = new vscode.CompletionItem('TEXT');
                waitForTextJavaTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                waitForTextJavaTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                waitForTextJavaTEXTCompletion.documentation = new vscode.MarkdownString('Der angezeigte Text');
                items.push(waitForTextJavaTEXTCompletion);
                const waitForTextJavaCHECK_CONTAINSCompletion = new vscode.CompletionItem('CHECK_CONTAINS');
                waitForTextJavaCHECK_CONTAINSCompletion.kind = vscode.CompletionItemKind.Field;
                waitForTextJavaCHECK_CONTAINSCompletion.insertText = new vscode.SnippetString("CHECK_CONTAINS = \"${1}\"");
                waitForTextJavaCHECK_CONTAINSCompletion.documentation = new vscode.MarkdownString('Legt fest ob der Wert nur beinhaltet sein muss. Default: false');
                items.push(waitForTextJavaCHECK_CONTAINSCompletion);
                const waitForTextJavaWAIT_MILLISCompletion = new vscode.CompletionItem('WAIT_MILLIS');
                waitForTextJavaWAIT_MILLISCompletion.kind = vscode.CompletionItemKind.Field;
                waitForTextJavaWAIT_MILLISCompletion.insertText = new vscode.SnippetString("WAIT_MILLIS = \"${1}\"");
                waitForTextJavaWAIT_MILLISCompletion.documentation = new vscode.MarkdownString('Optionale Anzahl zu wartender Millisekunden bis das Element verf\u00FCgbar ist. Default 10000.');
                items.push(waitForTextJavaWAIT_MILLISCompletion);
                const waitForTextJavaBY_NAMECompletion = new vscode.CompletionItem('BY_NAME');
                waitForTextJavaBY_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                waitForTextJavaBY_NAMECompletion.insertText = new vscode.SnippetString("BY_NAME = \"${1}\"");
                waitForTextJavaBY_NAMECompletion.documentation = new vscode.MarkdownString('Flag, \u00FCber den gekennzeichnet werden kann, dass das Element \u00FCber den Namen und nicht den Identifier (z.B. JButton1) angesprochen wird.');
                items.push(waitForTextJavaBY_NAMECompletion);
            }
            if (/.*\s*waitMobile\s*\(.*/.test(linePrefix)) {
                const waitMobileBY_CRITERIACompletion = new vscode.CompletionItem('BY_CRITERIA');
                waitMobileBY_CRITERIACompletion.kind = vscode.CompletionItemKind.Field;
                waitMobileBY_CRITERIACompletion.insertText = new vscode.SnippetString("BY_CRITERIA = \"${1}\"");
                waitMobileBY_CRITERIACompletion.documentation = new vscode.MarkdownString('Kriterium, \u00FCber das das Element ermittelt werden soll (m\u00F6glich sind: id, name, xpath, class_name, tag_name, link_name, partial_link_name, css, accessability_id, ios_automation). Der Default-Wert ist \'name\'.');
                items.push(waitMobileBY_CRITERIACompletion);
                const waitMobileEXPRESSION_TEXTCompletion = new vscode.CompletionItem('EXPRESSION_TEXT');
                waitMobileEXPRESSION_TEXTCompletion.kind = vscode.CompletionItemKind.Field;
                waitMobileEXPRESSION_TEXTCompletion.insertText = new vscode.SnippetString("EXPRESSION_TEXT = \"${1}\"");
                waitMobileEXPRESSION_TEXTCompletion.documentation = new vscode.MarkdownString('Bezeichner des Elements abh\u00E4ngig vom Kriterium.');
                items.push(waitMobileEXPRESSION_TEXTCompletion);
                const waitMobileWAIT_SECONDSCompletion = new vscode.CompletionItem('WAIT_SECONDS');
                waitMobileWAIT_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                waitMobileWAIT_SECONDSCompletion.insertText = new vscode.SnippetString("WAIT_SECONDS = \"${1}\"");
                waitMobileWAIT_SECONDSCompletion.documentation = new vscode.MarkdownString('Optionaler Parameter, der angibt, wie lange auf die Verf\u00FCgbarkeit des Elements gewartet werden soll bis eine Warnung ausgegeben wird. Der Parameter muss als positive, ganze Zahl angegeben werden. Der Default-Wert ist \'1\'.');
                items.push(waitMobileWAIT_SECONDSCompletion);
            }
            if (/.*\s*warning\s*\(.*/.test(linePrefix)) {
                const warningMESSAGECompletion = new vscode.CompletionItem('MESSAGE');
                warningMESSAGECompletion.kind = vscode.CompletionItemKind.Field;
                warningMESSAGECompletion.insertText = new vscode.SnippetString("MESSAGE = \"${1}\"");
                warningMESSAGECompletion.documentation = new vscode.MarkdownString('Nachricht, die im Bericht angezeigt werden soll.');
                items.push(warningMESSAGECompletion);
            }
            if (/.*\s*when\s*\(.*/.test(linePrefix)) {
                const whenACCEPTABLE_RESULT_LEVELSCompletion = new vscode.CompletionItem('ACCEPTABLE_RESULT_LEVELS');
                whenACCEPTABLE_RESULT_LEVELSCompletion.kind = vscode.CompletionItemKind.Field;
                whenACCEPTABLE_RESULT_LEVELSCompletion.insertText = new vscode.SnippetString("ACCEPTABLE_RESULT_LEVELS = \"${1}\"");
                whenACCEPTABLE_RESULT_LEVELSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(whenACCEPTABLE_RESULT_LEVELSCompletion);
            }
            if (/.*\s*while\s*\(.*/.test(linePrefix)) {
                const whileMAX_ITERATIONSCompletion = new vscode.CompletionItem('MAX_ITERATIONS');
                whileMAX_ITERATIONSCompletion.kind = vscode.CompletionItemKind.Field;
                whileMAX_ITERATIONSCompletion.insertText = new vscode.SnippetString("MAX_ITERATIONS = \"${1}\"");
                whileMAX_ITERATIONSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(whileMAX_ITERATIONSCompletion);
                const whileACCEPTABLE_RESULT_LEVELSCompletion = new vscode.CompletionItem('ACCEPTABLE_RESULT_LEVELS');
                whileACCEPTABLE_RESULT_LEVELSCompletion.kind = vscode.CompletionItemKind.Field;
                whileACCEPTABLE_RESULT_LEVELSCompletion.insertText = new vscode.SnippetString("ACCEPTABLE_RESULT_LEVELS = \"${1}\"");
                whileACCEPTABLE_RESULT_LEVELSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(whileACCEPTABLE_RESULT_LEVELSCompletion);
                const whileINDEX_NAMECompletion = new vscode.CompletionItem('INDEX_NAME');
                whileINDEX_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                whileINDEX_NAMECompletion.insertText = new vscode.SnippetString("INDEX_NAME = \"${1}\"");
                whileINDEX_NAMECompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(whileINDEX_NAMECompletion);
            }
            if (/.*\s*whileNot\s*\(.*/.test(linePrefix)) {
                const whileNotMAX_ITERATIONSCompletion = new vscode.CompletionItem('MAX_ITERATIONS');
                whileNotMAX_ITERATIONSCompletion.kind = vscode.CompletionItemKind.Field;
                whileNotMAX_ITERATIONSCompletion.insertText = new vscode.SnippetString("MAX_ITERATIONS = \"${1}\"");
                whileNotMAX_ITERATIONSCompletion.documentation = new vscode.MarkdownString('Beschreibung ausstehend');
                items.push(whileNotMAX_ITERATIONSCompletion);
            }
            if (/.*\s*winActivate\s*\(.*/.test(linePrefix)) {
                const winActivateTITLECompletion = new vscode.CompletionItem('TITLE');
                winActivateTITLECompletion.kind = vscode.CompletionItemKind.Field;
                winActivateTITLECompletion.insertText = new vscode.SnippetString("TITLE = \"${1}\"");
                winActivateTITLECompletion.documentation = new vscode.MarkdownString('Titel des zu aktivierenden Fensters');
                items.push(winActivateTITLECompletion);
            }
            if (/.*\s*winCheckIfFileExists\s*\(.*/.test(linePrefix)) {
                const winCheckIfFileExistsFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                winCheckIfFileExistsFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                winCheckIfFileExistsFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                winCheckIfFileExistsFILENAMECompletion.documentation = new vscode.MarkdownString('Filepath der zu pr\u00FCfenden Datei');
                items.push(winCheckIfFileExistsFILENAMECompletion);
                const winCheckIfFileExistsMIN_SIZE_BYTESCompletion = new vscode.CompletionItem('MIN_SIZE_BYTES');
                winCheckIfFileExistsMIN_SIZE_BYTESCompletion.kind = vscode.CompletionItemKind.Field;
                winCheckIfFileExistsMIN_SIZE_BYTESCompletion.insertText = new vscode.SnippetString("MIN_SIZE_BYTES = \"${1}\"");
                winCheckIfFileExistsMIN_SIZE_BYTESCompletion.documentation = new vscode.MarkdownString('Mindestgr\u00F6\u00DFe in Bytes');
                items.push(winCheckIfFileExistsMIN_SIZE_BYTESCompletion);
            }
            if (/.*\s*winExists\s*\(.*/.test(linePrefix)) {
                const winExistsTITLECompletion = new vscode.CompletionItem('TITLE');
                winExistsTITLECompletion.kind = vscode.CompletionItemKind.Field;
                winExistsTITLECompletion.insertText = new vscode.SnippetString("TITLE = \"${1}\"");
                winExistsTITLECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters');
                items.push(winExistsTITLECompletion);
            }
            if (/.*\s*winGetActiveWindowTitle\s*\(.*/.test(linePrefix)) {
                const winGetActiveWindowTitleTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                winGetActiveWindowTitleTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                winGetActiveWindowTitleTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                winGetActiveWindowTitleTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(winGetActiveWindowTitleTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*winGetAllWindowsTitles\s*\(.*/.test(linePrefix)) {
                const winGetAllWindowsTitlesTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                winGetAllWindowsTitlesTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                winGetAllWindowsTitlesTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                winGetAllWindowsTitlesTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Hier kann ein Schl\u00FCssel gesetzt werden, unter dem das Ergebnis dieser Operation gespeichert wird.');
                items.push(winGetAllWindowsTitlesTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*winGetControlinfoAtPosition\s*\(.*/.test(linePrefix)) {
                const winGetControlinfoAtPositionWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winGetControlinfoAtPositionWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winGetControlinfoAtPositionWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winGetControlinfoAtPositionWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winGetControlinfoAtPositionWINDOW_NAMECompletion);
                const winGetControlinfoAtPositionCONTROLCompletion = new vscode.CompletionItem('CONTROL');
                winGetControlinfoAtPositionCONTROLCompletion.kind = vscode.CompletionItemKind.Field;
                winGetControlinfoAtPositionCONTROLCompletion.insertText = new vscode.SnippetString("CONTROL = \"${1}\"");
                winGetControlinfoAtPositionCONTROLCompletion.documentation = new vscode.MarkdownString('Control');
                items.push(winGetControlinfoAtPositionCONTROLCompletion);
                const winGetControlinfoAtPositionMOUSE_XCompletion = new vscode.CompletionItem('MOUSE_X');
                winGetControlinfoAtPositionMOUSE_XCompletion.kind = vscode.CompletionItemKind.Field;
                winGetControlinfoAtPositionMOUSE_XCompletion.insertText = new vscode.SnippetString("MOUSE_X = \"${1}\"");
                winGetControlinfoAtPositionMOUSE_XCompletion.documentation = new vscode.MarkdownString('X-Position der Maus');
                items.push(winGetControlinfoAtPositionMOUSE_XCompletion);
                const winGetControlinfoAtPositionMOUSE_YCompletion = new vscode.CompletionItem('MOUSE_Y');
                winGetControlinfoAtPositionMOUSE_YCompletion.kind = vscode.CompletionItemKind.Field;
                winGetControlinfoAtPositionMOUSE_YCompletion.insertText = new vscode.SnippetString("MOUSE_Y = \"${1}\"");
                winGetControlinfoAtPositionMOUSE_YCompletion.documentation = new vscode.MarkdownString('Y-Position der Maus');
                items.push(winGetControlinfoAtPositionMOUSE_YCompletion);
            }
            if (/.*\s*winGetText\s*\(.*/.test(linePrefix)) {
                const winGetTextTITLECompletion = new vscode.CompletionItem('TITLE');
                winGetTextTITLECompletion.kind = vscode.CompletionItemKind.Field;
                winGetTextTITLECompletion.insertText = new vscode.SnippetString("TITLE = \"${1}\"");
                winGetTextTITLECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters');
                items.push(winGetTextTITLECompletion);
                const winGetTextTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                winGetTextTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                winGetTextTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                winGetTextTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(winGetTextTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*winGetWindowText\s*\(.*/.test(linePrefix)) {
                const winGetWindowTextWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winGetWindowTextWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winGetWindowTextWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winGetWindowTextWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winGetWindowTextWINDOW_NAMECompletion);
                const winGetWindowTextMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                winGetWindowTextMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                winGetWindowTextMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                winGetWindowTextMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(winGetWindowTextMATCH_MODECompletion);
                const winGetWindowTextTARGET_STORAGE_KEYCompletion = new vscode.CompletionItem('TARGET_STORAGE_KEY');
                winGetWindowTextTARGET_STORAGE_KEYCompletion.kind = vscode.CompletionItemKind.Field;
                winGetWindowTextTARGET_STORAGE_KEYCompletion.insertText = new vscode.SnippetString("TARGET_STORAGE_KEY = \"${1}\"");
                winGetWindowTextTARGET_STORAGE_KEYCompletion.documentation = new vscode.MarkdownString('Schl\u00FCssel f\u00FCr die Storage-Datei, in den der Fenster-Text geschrieben werden soll.');
                items.push(winGetWindowTextTARGET_STORAGE_KEYCompletion);
            }
            if (/.*\s*winMouseClickCursorFenster\s*\(.*/.test(linePrefix)) {
                const winMouseClickCursorFensterWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winMouseClickCursorFensterWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickCursorFensterWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winMouseClickCursorFensterWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winMouseClickCursorFensterWINDOW_NAMECompletion);
                const winMouseClickCursorFensterMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                winMouseClickCursorFensterMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickCursorFensterMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                winMouseClickCursorFensterMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('Mouse Button');
                items.push(winMouseClickCursorFensterMOUSE_BUTTONCompletion);
            }
            if (/.*\s*winMouseClickXY\s*\(.*/.test(linePrefix)) {
                const winMouseClickXYXCompletion = new vscode.CompletionItem('X');
                winMouseClickXYXCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickXYXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                winMouseClickXYXCompletion.documentation = new vscode.MarkdownString('X-Koordinate');
                items.push(winMouseClickXYXCompletion);
                const winMouseClickXYYCompletion = new vscode.CompletionItem('Y');
                winMouseClickXYYCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickXYYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                winMouseClickXYYCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(winMouseClickXYYCompletion);
                const winMouseClickXYMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                winMouseClickXYMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickXYMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                winMouseClickXYMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('Mouse Button');
                items.push(winMouseClickXYMOUSE_BUTTONCompletion);
            }
            if (/.*\s*winMouseClickXYFenster\s*\(.*/.test(linePrefix)) {
                const winMouseClickXYFensterWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winMouseClickXYFensterWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickXYFensterWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winMouseClickXYFensterWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winMouseClickXYFensterWINDOW_NAMECompletion);
                const winMouseClickXYFensterXCompletion = new vscode.CompletionItem('X');
                winMouseClickXYFensterXCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickXYFensterXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                winMouseClickXYFensterXCompletion.documentation = new vscode.MarkdownString('X-Koordinate');
                items.push(winMouseClickXYFensterXCompletion);
                const winMouseClickXYFensterYCompletion = new vscode.CompletionItem('Y');
                winMouseClickXYFensterYCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickXYFensterYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                winMouseClickXYFensterYCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(winMouseClickXYFensterYCompletion);
                const winMouseClickXYFensterMOUSE_BUTTONCompletion = new vscode.CompletionItem('MOUSE_BUTTON');
                winMouseClickXYFensterMOUSE_BUTTONCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseClickXYFensterMOUSE_BUTTONCompletion.insertText = new vscode.SnippetString("MOUSE_BUTTON = \"${1}\"");
                winMouseClickXYFensterMOUSE_BUTTONCompletion.documentation = new vscode.MarkdownString('Mouse Button');
                items.push(winMouseClickXYFensterMOUSE_BUTTONCompletion);
            }
            if (/.*\s*winMouseDoubleClickXYFenster\s*\(.*/.test(linePrefix)) {
                const winMouseDoubleClickXYFensterWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winMouseDoubleClickXYFensterWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winMouseDoubleClickXYFensterWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winMouseDoubleClickXYFensterWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winMouseDoubleClickXYFensterWINDOW_NAMECompletion);
                const winMouseDoubleClickXYFensterXCompletion = new vscode.CompletionItem('X');
                winMouseDoubleClickXYFensterXCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseDoubleClickXYFensterXCompletion.insertText = new vscode.SnippetString("X = \"${1}\"");
                winMouseDoubleClickXYFensterXCompletion.documentation = new vscode.MarkdownString('X-Koordinate');
                items.push(winMouseDoubleClickXYFensterXCompletion);
                const winMouseDoubleClickXYFensterYCompletion = new vscode.CompletionItem('Y');
                winMouseDoubleClickXYFensterYCompletion.kind = vscode.CompletionItemKind.Field;
                winMouseDoubleClickXYFensterYCompletion.insertText = new vscode.SnippetString("Y = \"${1}\"");
                winMouseDoubleClickXYFensterYCompletion.documentation = new vscode.MarkdownString('Y-Koordinate');
                items.push(winMouseDoubleClickXYFensterYCompletion);
            }
            if (/.*\s*winMouseOn00\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*winOpenFileWithNotepad\s*\(.*/.test(linePrefix)) {
                const winOpenFileWithNotepadFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                winOpenFileWithNotepadFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                winOpenFileWithNotepadFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                winOpenFileWithNotepadFILENAMECompletion.documentation = new vscode.MarkdownString('Name der Datei');
                items.push(winOpenFileWithNotepadFILENAMECompletion);
                const winOpenFileWithNotepadBASEDIRCompletion = new vscode.CompletionItem('BASEDIR');
                winOpenFileWithNotepadBASEDIRCompletion.kind = vscode.CompletionItemKind.Field;
                winOpenFileWithNotepadBASEDIRCompletion.insertText = new vscode.SnippetString("BASEDIR = \"${1}\"");
                winOpenFileWithNotepadBASEDIRCompletion.documentation = new vscode.MarkdownString('Base Directory');
                items.push(winOpenFileWithNotepadBASEDIRCompletion);
            }
            if (/.*\s*winScrollMouseWheel\s*\(.*/.test(linePrefix)) {
                const winScrollMouseWheelWHEEL_DIRECTIONCompletion = new vscode.CompletionItem('WHEEL_DIRECTION');
                winScrollMouseWheelWHEEL_DIRECTIONCompletion.kind = vscode.CompletionItemKind.Field;
                winScrollMouseWheelWHEEL_DIRECTIONCompletion.insertText = new vscode.SnippetString("WHEEL_DIRECTION = \"${1}\"");
                winScrollMouseWheelWHEEL_DIRECTIONCompletion.documentation = new vscode.MarkdownString('Richtung des Mausrads');
                items.push(winScrollMouseWheelWHEEL_DIRECTIONCompletion);
                const winScrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion = new vscode.CompletionItem('NUMBER_OF_WHEEL_TURNS');
                winScrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion.kind = vscode.CompletionItemKind.Field;
                winScrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion.insertText = new vscode.SnippetString("NUMBER_OF_WHEEL_TURNS = \"${1}\"");
                winScrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion.documentation = new vscode.MarkdownString('Anzahl der Drehungen des Mausrads');
                items.push(winScrollMouseWheelNUMBER_OF_WHEEL_TURNSCompletion);
            }
            if (/.*\s*winSend\s*\(.*/.test(linePrefix)) {
                const winSendTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                winSendTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                winSendTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                winSendTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Der zu sendende Text');
                items.push(winSendTEXT_TO_SENDCompletion);
                const winSendDELAYCompletion = new vscode.CompletionItem('DELAY');
                winSendDELAYCompletion.kind = vscode.CompletionItemKind.Field;
                winSendDELAYCompletion.insertText = new vscode.SnippetString("DELAY = \"${1}\"");
                winSendDELAYCompletion.documentation = new vscode.MarkdownString('Delay zwischen Tastenanschl\u00E4gen in Millisekunden (Default: 5)');
                items.push(winSendDELAYCompletion);
            }
            if (/.*\s*winSendTextByPaste\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*winSendWindow\s*\(.*/.test(linePrefix)) {
                const winSendWindowWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winSendWindowWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winSendWindowWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winSendWindowWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winSendWindowWINDOW_NAMECompletion);
                const winSendWindowTEXT_TO_SENDCompletion = new vscode.CompletionItem('TEXT_TO_SEND');
                winSendWindowTEXT_TO_SENDCompletion.kind = vscode.CompletionItemKind.Field;
                winSendWindowTEXT_TO_SENDCompletion.insertText = new vscode.SnippetString("TEXT_TO_SEND = \"${1}\"");
                winSendWindowTEXT_TO_SENDCompletion.documentation = new vscode.MarkdownString('Der zu sendende Text');
                items.push(winSendWindowTEXT_TO_SENDCompletion);
                const winSendWindowDELAYCompletion = new vscode.CompletionItem('DELAY');
                winSendWindowDELAYCompletion.kind = vscode.CompletionItemKind.Field;
                winSendWindowDELAYCompletion.insertText = new vscode.SnippetString("DELAY = \"${1}\"");
                winSendWindowDELAYCompletion.documentation = new vscode.MarkdownString('Delay zwischen Tastenanschl\u00E4gen in Millisekunden (Default: 5)');
                items.push(winSendWindowDELAYCompletion);
            }
            if (/.*\s*winStatusbarText\s*\(.*/.test(linePrefix)) {
                const winStatusbarTextWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winStatusbarTextWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winStatusbarTextWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winStatusbarTextWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winStatusbarTextWINDOW_NAMECompletion);
            }
            if (/.*\s*winWait\s*\(.*/.test(linePrefix)) {
                const winWaitTITLECompletion = new vscode.CompletionItem('TITLE');
                winWaitTITLECompletion.kind = vscode.CompletionItemKind.Field;
                winWaitTITLECompletion.insertText = new vscode.SnippetString("TITLE = \"${1}\"");
                winWaitTITLECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters');
                items.push(winWaitTITLECompletion);
                const winWaitTIMEOUT_IN_SECONDSCompletion = new vscode.CompletionItem('TIMEOUT_IN_SECONDS');
                winWaitTIMEOUT_IN_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                winWaitTIMEOUT_IN_SECONDSCompletion.insertText = new vscode.SnippetString("TIMEOUT_IN_SECONDS = \"${1}\"");
                winWaitTIMEOUT_IN_SECONDSCompletion.documentation = new vscode.MarkdownString('Timeout in Sekunden, wie lange h\u00F6chstens gewartet werden soll.');
                items.push(winWaitTIMEOUT_IN_SECONDSCompletion);
            }
            if (/.*\s*winWaitActive\s*\(.*/.test(linePrefix)) {
                const winWaitActiveTITLECompletion = new vscode.CompletionItem('TITLE');
                winWaitActiveTITLECompletion.kind = vscode.CompletionItemKind.Field;
                winWaitActiveTITLECompletion.insertText = new vscode.SnippetString("TITLE = \"${1}\"");
                winWaitActiveTITLECompletion.documentation = new vscode.MarkdownString('Titel des zu pr\u00FCfenden Fensters');
                items.push(winWaitActiveTITLECompletion);
                const winWaitActiveTIMEOUT_IN_SECONDSCompletion = new vscode.CompletionItem('TIMEOUT_IN_SECONDS');
                winWaitActiveTIMEOUT_IN_SECONDSCompletion.kind = vscode.CompletionItemKind.Field;
                winWaitActiveTIMEOUT_IN_SECONDSCompletion.insertText = new vscode.SnippetString("TIMEOUT_IN_SECONDS = \"${1}\"");
                winWaitActiveTIMEOUT_IN_SECONDSCompletion.documentation = new vscode.MarkdownString('Timeout in Sekunden, wie lange h\u00F6chstens gewartet werden soll.');
                items.push(winWaitActiveTIMEOUT_IN_SECONDSCompletion);
            }
            if (/.*\s*winWaitForWindowExists\s*\(.*/.test(linePrefix)) {
                const winWaitForWindowExistsWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winWaitForWindowExistsWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winWaitForWindowExistsWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winWaitForWindowExistsWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winWaitForWindowExistsWINDOW_NAMECompletion);
                const winWaitForWindowExistsMATCH_MODECompletion = new vscode.CompletionItem('MATCH_MODE');
                winWaitForWindowExistsMATCH_MODECompletion.kind = vscode.CompletionItemKind.Field;
                winWaitForWindowExistsMATCH_MODECompletion.insertText = new vscode.SnippetString("MATCH_MODE = \"${1}\"");
                winWaitForWindowExistsMATCH_MODECompletion.documentation = new vscode.MarkdownString('M\u00F6gliche Werte sind eine der folgenden Ziffern oder das Wort \'RegEx\':\n       1 = Der Titel eines Fensters muss mit dem angegebenen WINDOW_NAME beginnen, um eine \u00DCbereinstimmung zu erzielen.\n       2 = Der Titel eines Fensters kann WINDOW_NAME an beliebiger Stelle enthalten, um eine \u00DCbereinstimmung zu erzielen.\n       3 = Der Titel eines Fensters muss genau mit WINDOW_NAME \u00FCbereinstimmen, um eine \u00DCbereinstimmung zu erzielen.\n       RegEx = WINDOW_NAME wird als regul\u00E4rer Ausdruck behandelt.');
                items.push(winWaitForWindowExistsMATCH_MODECompletion);
            }
            if (/.*\s*winWaitForWindowText\s*\(.*/.test(linePrefix)) {
                const winWaitForWindowTextWINDOW_NAMECompletion = new vscode.CompletionItem('WINDOW_NAME');
                winWaitForWindowTextWINDOW_NAMECompletion.kind = vscode.CompletionItemKind.Field;
                winWaitForWindowTextWINDOW_NAMECompletion.insertText = new vscode.SnippetString("WINDOW_NAME = \"${1}\"");
                winWaitForWindowTextWINDOW_NAMECompletion.documentation = new vscode.MarkdownString('Titel des Fensters');
                items.push(winWaitForWindowTextWINDOW_NAMECompletion);
                const winWaitForWindowTextTEXTCompletion = new vscode.CompletionItem('TEXT');
                winWaitForWindowTextTEXTCompletion.kind = vscode.CompletionItemKind.Field;
                winWaitForWindowTextTEXTCompletion.insertText = new vscode.SnippetString("TEXT = \"${1}\"");
                winWaitForWindowTextTEXTCompletion.documentation = new vscode.MarkdownString('Der zu erwartende Text');
                items.push(winWaitForWindowTextTEXTCompletion);
            }
            if (/.*\s*writePropertiesToStorage\s*\(.*/.test(linePrefix)) {
            }
            if (/.*\s*writeToFile\s*\(.*/.test(linePrefix)) {
                const writeToFileVALUECompletion = new vscode.CompletionItem('VALUE');
                writeToFileVALUECompletion.kind = vscode.CompletionItemKind.Field;
                writeToFileVALUECompletion.insertText = new vscode.SnippetString("VALUE = \"${1}\"");
                writeToFileVALUECompletion.documentation = new vscode.MarkdownString('Leerer Parameter');
                items.push(writeToFileVALUECompletion);
                const writeToFileFILENAMECompletion = new vscode.CompletionItem('FILENAME');
                writeToFileFILENAMECompletion.kind = vscode.CompletionItemKind.Field;
                writeToFileFILENAMECompletion.insertText = new vscode.SnippetString("FILENAME = \"${1}\"");
                writeToFileFILENAMECompletion.documentation = new vscode.MarkdownString('Dateiname der zu schreibenden Datei');
                items.push(writeToFileFILENAMECompletion);
                const writeToFileENCODINGCompletion = new vscode.CompletionItem('ENCODING');
                writeToFileENCODINGCompletion.kind = vscode.CompletionItemKind.Field;
                writeToFileENCODINGCompletion.insertText = new vscode.SnippetString("ENCODING = \"${1}\"");
                writeToFileENCODINGCompletion.documentation = new vscode.MarkdownString('Eindeutige Zuordnung von Schriftzeichen');
                items.push(writeToFileENCODINGCompletion);
            }
            if (/.*\s*xml2Cobol\s*\(.*/.test(linePrefix)) {
                const xml2CobolINPUT_XMLCompletion = new vscode.CompletionItem('INPUT_XML');
                xml2CobolINPUT_XMLCompletion.kind = vscode.CompletionItemKind.Field;
                xml2CobolINPUT_XMLCompletion.insertText = new vscode.SnippetString("INPUT_XML = \"${1}\"");
                xml2CobolINPUT_XMLCompletion.documentation = new vscode.MarkdownString('Zu verwendendes Eingangs-XML');
                items.push(xml2CobolINPUT_XMLCompletion);
                const xml2CobolCOPYBOOKCompletion = new vscode.CompletionItem('COPYBOOK');
                xml2CobolCOPYBOOKCompletion.kind = vscode.CompletionItemKind.Field;
                xml2CobolCOPYBOOKCompletion.insertText = new vscode.SnippetString("COPYBOOK = \"${1}\"");
                xml2CobolCOPYBOOKCompletion.documentation = new vscode.MarkdownString('Host Copybook');
                items.push(xml2CobolCOPYBOOKCompletion);
                const xml2CobolOUTPUT_BINCompletion = new vscode.CompletionItem('OUTPUT_BIN');
                xml2CobolOUTPUT_BINCompletion.kind = vscode.CompletionItemKind.Field;
                xml2CobolOUTPUT_BINCompletion.insertText = new vscode.SnippetString("OUTPUT_BIN = \"${1}\"");
                xml2CobolOUTPUT_BINCompletion.documentation = new vscode.MarkdownString('Zu erstellende Bin\u00E4r Datei');
                items.push(xml2CobolOUTPUT_BINCompletion);
                const xml2CobolFONTCompletion = new vscode.CompletionItem('FONT');
                xml2CobolFONTCompletion.kind = vscode.CompletionItemKind.Field;
                xml2CobolFONTCompletion.insertText = new vscode.SnippetString("FONT = \"${1}\"");
                xml2CobolFONTCompletion.documentation = new vscode.MarkdownString('Zu verwendendes Charset der Cobol Datei');
                items.push(xml2CobolFONTCompletion);
            }
            if (/.*\s*zipFiles\s*\(.*/.test(linePrefix)) {
                const zipFilesPATH_OF_FILESCompletion = new vscode.CompletionItem('PATH_OF_FILES');
                zipFilesPATH_OF_FILESCompletion.kind = vscode.CompletionItemKind.Field;
                zipFilesPATH_OF_FILESCompletion.insertText = new vscode.SnippetString("PATH_OF_FILES = \"${1}\"");
                zipFilesPATH_OF_FILESCompletion.documentation = new vscode.MarkdownString('Pfad der der Datei \/ der Dateien \/ des Ordners, die gezippt werden sollen');
                items.push(zipFilesPATH_OF_FILESCompletion);
                const zipFilesPATH_OF_ARCHIVECompletion = new vscode.CompletionItem('PATH_OF_ARCHIVE');
                zipFilesPATH_OF_ARCHIVECompletion.kind = vscode.CompletionItemKind.Field;
                zipFilesPATH_OF_ARCHIVECompletion.insertText = new vscode.SnippetString("PATH_OF_ARCHIVE = \"${1}\"");
                zipFilesPATH_OF_ARCHIVECompletion.documentation = new vscode.MarkdownString('Pfad, an welchem das Archive erstellt werden soll');
                items.push(zipFilesPATH_OF_ARCHIVECompletion);
            }
            if (/.*\s*zoomMobile\s*\(.*/.test(linePrefix)) {
                const zoomMobileX_POSITIONCompletion = new vscode.CompletionItem('X_POSITION');
                zoomMobileX_POSITIONCompletion.kind = vscode.CompletionItemKind.Field;
                zoomMobileX_POSITIONCompletion.insertText = new vscode.SnippetString("X_POSITION = \"${1}\"");
                zoomMobileX_POSITIONCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt die X-Koordinate des Punktes in Pixeln an, auf den gezoomt werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(zoomMobileX_POSITIONCompletion);
                const zoomMobileY_POSITIONCompletion = new vscode.CompletionItem('Y_POSITION');
                zoomMobileY_POSITIONCompletion.kind = vscode.CompletionItemKind.Field;
                zoomMobileY_POSITIONCompletion.insertText = new vscode.SnippetString("Y_POSITION = \"${1}\"");
                zoomMobileY_POSITIONCompletion.documentation = new vscode.MarkdownString('Der Parameter gibt die Y-Koordinate des Punktes in Pixeln an, auf den gezoomt werden soll. Der Parameter muss als positive, ganze Zahl angegeben werden.');
                items.push(zoomMobileY_POSITIONCompletion);
            }
            console.log("Items size: " + items.length);
            items = paramSortUtils_1.ParamSortUtils.sortParams(items);
            return items;
        });
    }
}, '.' // triggered whenever a '.' is being typed
);


/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParamSortUtils = void 0;
const vscode = __webpack_require__(65);
class ParamSortUtils {
    static sortParams(items) {
        for (let item of items) {
            if (item.kind === vscode.CompletionItemKind.Field) {
                item.sortText = "AAABBB";
            }
        }
        return items;
    }
}
exports.ParamSortUtils = ParamSortUtils;


/***/ }),
/* 68 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const snippetRunner_1 = __webpack_require__(69);
const vscode = __webpack_require__(65);
const axios_1 = __webpack_require__(1);
const https_1 = __webpack_require__(27);
const axiosUtils_1 = __webpack_require__(73);
const RepoParser_1 = __webpack_require__(75);
const StepRecommendationsBuffer_1 = __webpack_require__(76);
const RepositoryProcessor_1 = __webpack_require__(77);
/**
 * Parses and provides access to the repositories.
 * */
class RepoStepRecommender {
    /**
     * Keep this singleton's constructor private.
     */
    constructor() {
        /**
         * The hash code of the global repositories that are currently buffered (and used for making recommendations).
         */
        this.lastReposHash = 0;
        /**
         * The aliases that were defined for the repositories in the current document.
         */
        this.aliasPriorities = [];
        /**
         * The keyword to define an alias for a repo in mateo scripts.
         */
        this.INCLUDE_WITH_ALIAS_FLAG = " as ";
        /**
         * The keyword to indicate that a repository is being used.
         */
        this.INCLUDE_FLAG = "use";
        /**
         * The empty string represents the key for repositories for which no alias was defined.
         */
        this.KEY_OF_GENERAL_REPOS = "";
        /**
         * Extracts recommendations from both the local and the global repositories.
         */
        this.stepRecommendationsBuffer = new StepRecommendationsBuffer_1.StepRecommendationsBuffer();
    }
    provideRecommendation(document, uriFsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.initializeGlobalRepos();
            this.bufferAliases(document);
            this.bufferLocalRepos(document, uriFsPath);
            // Steps from the repositories loaded from the backend.
            let completionItems = this.completionItemsForGlobalRepos(document);
            // Steps from local repositories as defined in the mateo script.
            if (!this.isBlankLine(this.getLastLine(document))) {
                completionItems = completionItems.concat(this.completionItemsForLocalRepos(this.getLastLine(document)));
            }
            // Recommendations for alias names.
            let aliases = this.completionItemsForAlias(document);
            completionItems = completionItems.concat(aliases);
            return completionItems;
        });
    }
    getLastLine(text) {
        let lines = text.split("\n");
        return lines[lines.length - 1];
    }
    completionItemsForAlias(document) {
        let completionItems = [];
        let aliasesContainingText = this.filterMatchingAliases(this.allDefinedAliasNames(), this.getLastLine(document).trim());
        for (let alias of aliasesContainingText) {
            let completionItem = new vscode.CompletionItem(alias);
            completionItem.kind = vscode.CompletionItemKind.Class;
            completionItem.detail = "Alias for repository";
            completionItem.sortText = "AAAAAA";
            completionItems.push(completionItem);
        }
        return completionItems;
    }
    completionItemsForLocalRepos(lastLine) {
        let completionItems = [];
        let keyForDesiredRepo = this.getDesiredRepoKey(lastLine);
        if (keyForDesiredRepo !== undefined) {
            let aliasWithPriorizedRepos = this.matchingAlias(keyForDesiredRepo);
            let priorizedRepos = aliasWithPriorizedRepos == null // if null, no such alias is known
                ? []
                : aliasWithPriorizedRepos.priorizedRepoNames; // the list of repos the alias stands for
            completionItems = completionItems.concat(this.stepRecommendationsBuffer.getCompletionItemsForPriorizedRepos(priorizedRepos));
        }
        return completionItems;
    }
    completionItemsForGlobalRepos(document) {
        let completionItemCandidates = [];
        completionItemCandidates = completionItemCandidates.concat(this.stepRecommendationsBuffer.getCompletionItemsForBackendRepos());
        // The user may have used a local repository without defining an alias for it
        // a.k.a. general repository. 
        // Make sure to include these, too.
        let desiredRepo = this.matchingAlias(this.KEY_OF_GENERAL_REPOS);
        if (desiredRepo != null) {
            completionItemCandidates = completionItemCandidates.concat(this.stepRecommendationsBuffer.getCompletionItemsForPriorizedRepos(desiredRepo.priorizedRepoNames));
        }
        // Filter the completion items, so that only steps that match with 
        // the currently typed prefix are shown.
        return this.filterMatchingCompletions(completionItemCandidates, document);
    }
    filterMatchingCompletions(completions, document) {
        let currentLinePrefix = this.getLastLine(document);
        let completionItems = [];
        for (let item of completions) {
            if (item.label.includes(currentLinePrefix.trim())) {
                completionItems.push(item);
            }
        }
        return completionItems;
    }
    filterMatchingAliases(texts, text) {
        return texts.filter((x) => x.substring(0, text.length) === text);
    }
    allDefinedAliasNames() {
        let aliasSuggestions = [];
        for (let key of this.makeArrayUnique(this.aliasPriorities.map((x) => x.aliasName))) {
            aliasSuggestions.push(key);
        }
        return aliasSuggestions;
    }
    makeArrayUnique(array) {
        return [...new Set(array)];
    }
    getDesiredRepoKey(lastLine) {
        if (!this.hasPrecedingDot(lastLine)) {
            return undefined;
        }
        else {
            return this.getReferencedAlias(lastLine);
        }
    }
    getReferencedAlias(lastLine) {
        let indexOfDot = lastLine.indexOf(".");
        let symbol = lastLine.substring(0, indexOfDot).trim();
        if (symbol === "") {
            return undefined;
        }
        else {
            return symbol;
        }
    }
    isBlankLine(line) {
        return line.trim().length == 0;
    }
    hasPrecedingDot(lastLine) {
        let indexOfDot = lastLine.indexOf(".");
        if (indexOfDot < 0) {
            return false;
        }
        for (let alias of this.aliasPriorities.map((x) => x.aliasName)) {
            if (lastLine.includes(alias)) {
                return true;
            }
        }
        return false;
    }
    bufferLocalRepos(document, uriFsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let repoModels = yield RepoParser_1.default.parseUsedRepositories(document, (0, snippetRunner_1.retrieveWorkspacePath)(uriFsPath));
            this.stepRecommendationsBuffer.clearLocalRecommendations();
            for (let i = 0; i < repoModels.length; i++) {
                let alias = this.getAliasesForRepository(repoModels[i].name);
                if (alias === null) {
                    console.log("No alias found for repository " + repoModels[i].name);
                }
                else {
                    this.bufferSingleRepo(repoModels[i], alias);
                }
            }
        });
    }
    getAliasesForRepository(repoName) {
        return this.aliasPriorities.map((x) => x.aliasName).length > 0
            ? this.aliasPriorities.map((x) => x.aliasName)[0]
            : null;
    }
    bufferAliases(document) {
        let linesContainingUse = (0, snippetRunner_1.getUseLines)(document);
        this.aliasPriorities = [];
        for (let currentLine of linesContainingUse) {
            let aliasAndRepo = this.extractAliasAndRepoName(currentLine);
            let aliasName = aliasAndRepo[0];
            let repoName = aliasAndRepo[1];
            // If the repository has been used (a.k.a. included) in previous lines of the mateo script,
            // then any additional includes are invalid.
            // This in particular implies that two distinct aliases for the same repository are not allowed.
            if (this.repoNameNotUsedBefore(repoName)) {
                let matchingAliases = this.matchingAlias(aliasName);
                if (matchingAliases != null) {
                    matchingAliases.priorizedRepoNames.push(repoName);
                }
                else {
                    this.aliasPriorities.push({
                        aliasName: aliasName,
                        priorizedRepoNames: [repoName],
                    });
                }
            }
        }
    }
    extractAliasAndRepoName(currentLine) {
        let repoName = "";
        let indexOfUse = currentLine.indexOf(this.INCLUDE_FLAG);
        let lastIndexOfAs = currentLine.lastIndexOf(this.INCLUDE_WITH_ALIAS_FLAG);
        // Retrieves the last occurence of " as " which, however, is not
        // necessarily present if the repository is used as a global repo (i.e. has no alias).
        let aliasName = "";
        if (lastIndexOfAs > 0) {
            repoName = currentLine
                .substring(indexOfUse + this.INCLUDE_FLAG.length, lastIndexOfAs)
                .trim();
            aliasName = currentLine.substring(lastIndexOfAs + this.INCLUDE_WITH_ALIAS_FLAG.length);
        }
        else {
            repoName = currentLine
                .substring(indexOfUse + this.INCLUDE_FLAG.length)
                .trim();
        }
        return [aliasName, repoName];
    }
    matchingAlias(alias) {
        let matchingAliases = this.aliasPriorities.filter((x) => x.aliasName === alias);
        if (matchingAliases.length > 0) {
            return matchingAliases[0];
        }
        else {
            return null;
        }
    }
    repoNameNotUsedBefore(name) {
        for (let priorityAlias of this.aliasPriorities) {
            for (let savedName of priorityAlias.priorizedRepoNames) {
                if (savedName === name) {
                    return false;
                }
            }
        }
        return true;
    }
    getReposHash() {
        return __awaiter(this, void 0, void 0, function* () {
            let config = vscode.workspace.getConfiguration("mateo");
            let queryParams = {
                auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
                httpsAgent: new https_1.Agent({
                    rejectUnauthorized: config.rejectUnauthorized,
                }),
                params: {},
            };
            let repoModelsHash = -1;
            yield axios_1.default
                .get(config.mateoHostUrl + "/api/repository/get-all-hash", queryParams)
                .then(function (response) {
                repoModelsHash = response.data;
            })
                .catch(function (error) {
                console.log("Error during execution: " + error.response.data);
            })
                .then(undefined, (err) => {
                console.log("Something went wrong: " + err);
            });
            return repoModelsHash;
        });
    }
    initializeGlobalRepos() {
        return __awaiter(this, void 0, void 0, function* () {
            let currentRepoHash = yield this.getReposHash();
            if (this.lastReposHash === currentRepoHash) {
                return;
            }
            this.lastReposHash = currentRepoHash;
            let config = vscode.workspace.getConfiguration("mateo");
            let queryParams = {
                auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
                httpsAgent: new https_1.Agent({
                    rejectUnauthorized: config.rejectUnauthorized,
                }),
                params: {},
            };
            let repoModels = [];
            yield axios_1.default
                .get(config.mateoHostUrl + "/api/repository/get-all", queryParams)
                .then(function (response) {
                repoModels = response.data;
            })
                .catch(function (error) {
                console.log("Error during execution: " + error.response.data);
            })
                .then(undefined, (err) => {
                console.log("Something went wrong: " + err);
            });
            this.stepRecommendationsBuffer.initializeGlobalRepos(repoModels);
        });
    }
    bufferSingleRepo(model, key) {
        let snippets = RepositoryProcessor_1.default.convertStepToSnippet(model).map((x) => x.snippet);
        this.stepRecommendationsBuffer.setSnippets(key, snippets, model.name);
    }
    static getInstance() {
        if (!RepoStepRecommender.instance) {
            RepoStepRecommender.instance = new RepoStepRecommender();
        }
        return RepoStepRecommender.instance;
    }
}
exports["default"] = RepoStepRecommender;


/***/ }),
/* 69 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUseLines = exports.generateUseResources = exports.retrieveWorkspacePath = exports.runSnippet = void 0;
const vscode = __webpack_require__(65);
const codeUtils = __webpack_require__(70);
const logger = __webpack_require__(71);
const extensionDataHolder_1 = __webpack_require__(72);
const axiosUtils_1 = __webpack_require__(73);
const axios_1 = __webpack_require__(1);
const responseHandler_1 = __webpack_require__(74);
const https_1 = __webpack_require__(27);
const dataHolder = extensionDataHolder_1.ExtensionDataHolder.getInstance();
exports.runSnippet = vscode.commands.registerCommand('extension.mateo.runSnippet', () => __awaiter(void 0, void 0, void 0, function* () {
    logger.showOutput();
    let code = codeUtils.getSelectedCode();
    if (code === '') {
        return;
    }
    let textEditor = vscode.window.activeTextEditor;
    if (!textEditor) {
        return "";
    }
    code = yield generateSnippet(textEditor, codeUtils.getFileName, code);
    // send validation request
    logger.info("Running: " + code);
    dataHolder.diagnosticCollection.clear();
    vscode.window.showInformationMessage("Running snippet...");
    let config = vscode.workspace.getConfiguration('mateo');
    axios_1.default.post(config.mateoHostUrl + '/dsl/execute', code, {
        auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
        httpsAgent: new https_1.Agent({
            rejectUnauthorized: vscode.workspace.getConfiguration('mateo').rejectUnauthorized
        }),
        timeout: 10000,
        headers: {
            'Content-Type': 'text/plain'
        }
    })
        .then(function (response) {
        // handle success
        logger.info("StatusCode: " + response.status);
        responseHandler_1.ResponseHandler.handleResponseAndOpenInBrowser(response);
    })
        .catch(function (error) {
        // handle error
        let status = error.response.status;
        if (status == 409 || status == 412 || status == 400) {
            responseHandler_1.ResponseHandler.handleResponseAndOpenInBrowser(error.response);
        }
        else {
            responseHandler_1.ResponseHandler.handleValidationErrors(error.response.data, codeUtils.getFileName());
        }
    });
}));
function generateSnippet(textEditor, getFileName, code) {
    return __awaiter(this, void 0, void 0, function* () {
        let workspacePath = retrieveWorkspacePath(textEditor.document.uri.fsPath);
        let fileNameUnixStyle = getFileName().replace(/\\/g, '/');
        let fileFromSub = fileNameUnixStyle.replace(workspacePath + '/', '');
        code = ">>>RESOURCE " + fileFromSub + "\n" + code;
        let useLines = getUseLines(code);
        code = yield generateUseResources(useLines, code, workspacePath);
        return code;
    });
}
function retrieveWorkspacePath(workspaceFolder) {
    let workspacePath = (workspaceFolder).replace(/\\/g, '/');
    return workspacePath.substring(0, workspacePath.lastIndexOf('/'));
}
exports.retrieveWorkspacePath = retrieveWorkspacePath;
function generateUseResources(useLines, code, workspacePath) {
    return __awaiter(this, void 0, void 0, function* () {
        for (let line in useLines) {
            let match = useLines[line].match(/\t*use\s+([^*&%\s]+).*/);
            if (match) {
                let filename = match[1];
                code += ">>>NEW_FILE\n";
                code += ">>>RESOURCE " + filename + "\n";
                let document = yield vscode.workspace.openTextDocument(vscode.Uri.file(workspacePath + "/" + filename));
                let text = document.getText();
                logger.info("Use code: " + text);
                let innerUseLines = getUseLines(text);
                code += text.concat("\n");
                code = yield generateUseResources(innerUseLines, code, workspacePath);
            }
        }
        return code;
    });
}
exports.generateUseResources = generateUseResources;
function getUseLines(text) {
    let codeLineArray = text.split('\n');
    // gather .mrepo files content
    return codeLineArray.filter(function (row) {
        return /^\s*use\s+([^*&%\s]+).*/.test(row);
    });
}
exports.getUseLines = getUseLines;


/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isElementInOpenSQLCommandsArray = exports.getWorkspaceFolderUnixStyle = exports.getStartLine = exports.removeComments = exports.removeLinebreaks = exports.cutUntilCaret = exports.getFileName = exports.getSelectedCode = void 0;
const vscode = __webpack_require__(65);
const getSelectedCode = () => {
    let textEditor = vscode.window.activeTextEditor;
    if (!textEditor) {
        return "";
    }
    let selections = textEditor.selections;
    selections.sort((s1, s2) => {
        return s1.start.line - s2.start.line;
    });
    let text = "";
    selections.forEach((selection) => {
        text += textEditor === null || textEditor === void 0 ? void 0 : textEditor.document.getText(selection);
        text += "\n";
    });
    if (textEditor.selection.isEmpty) {
        text = textEditor.document.lineAt(textEditor.selection.start.line).text;
    }
    return text;
};
exports.getSelectedCode = getSelectedCode;
const getFileName = () => {
    let textEditor = vscode.window.activeTextEditor;
    if (!textEditor) {
        return "";
    }
    return textEditor.document.fileName.trim();
};
exports.getFileName = getFileName;
/**
 * Returns the substring from the beginning of the document until the position where the caret is.
 * @param document The document to be trimmed.
 * @param position Indicates the position (line and character) of the caret within the document.
 * @returns The substring of the document until where the caret is.
 */
const cutUntilCaret = (document, position) => {
    let scriptUntilCaret = "";
    for (let row = 0; row < position.line; row++) {
        scriptUntilCaret += document.lineAt(row).text + "\n";
    }
    scriptUntilCaret += document
        .lineAt(position)
        .text.substring(0, position.character);
    return scriptUntilCaret;
};
exports.cutUntilCaret = cutUntilCaret;
/**
 * Removes mateo-script specific linebreaks that are indicated by the backslash character \.
 * Also removes whitespaces that succeed such a backslash character.
 * @param text A (snippet of) mateo script whose line breaks should be removed.
 * @returns A semantically equivalent mateo script that does not contain any backslash character.
 */
const removeLinebreaks = (text) => {
    return text.split(/\\\s*/).join("");
};
exports.removeLinebreaks = removeLinebreaks;
const removeSingleLineStrings = (text) => {
    let textWithoutSingleLineComments = "";
    for (let line of text.split("\n")) {
        textWithoutSingleLineComments += "\n";
        if (line.includes("#")) {
            textWithoutSingleLineComments += line.substring(0, line.indexOf("#"));
        }
        else {
            textWithoutSingleLineComments += line;
        }
    }
    return textWithoutSingleLineComments;
};
const removeComments = (text) => {
    // this regex matches any string enclosed by three quotation marks 
    // (corresponding to multiline comments in mateo script)
    // e.g. occurences of strings like: """ This is \n a comment \n """ 
    text = removeSingleLineStrings(text);
    return text.split(/\"\"\"(\s|.)*?\"\"\"/).join("\n");
};
exports.removeComments = removeComments;
const getStartLine = () => {
    let textEditor = vscode.window.activeTextEditor;
    if (!textEditor) {
        return "";
    }
    return textEditor.selection.start.line;
};
exports.getStartLine = getStartLine;
const getWorkspaceFolderUnixStyle = () => {
    let textEditor = vscode.window.activeTextEditor;
    if (!textEditor) {
        return "";
    }
    let workspaceFolder = vscode.workspace.getWorkspaceFolder(textEditor.document.uri);
    if (workspaceFolder === undefined) {
        let wsFolder = textEditor.document.uri.fsPath;
        let wsPath = (wsFolder).replace(/\\/g, '/');
        return wsPath.substring(0, wsPath.lastIndexOf('/'));
    }
    let workspacePath = ((workspaceFolder === null || workspaceFolder === void 0 ? void 0 : workspaceFolder.uri.fsPath) || '').replace(/\\/g, '/');
    return workspacePath;
};
exports.getWorkspaceFolderUnixStyle = getWorkspaceFolderUnixStyle;
const isElementInOpenSQLCommandsArray = (pArray = [], searchedConnectionName) => {
    for (let i = 0; i < pArray.length; i++) {
        if (pArray[i][0] == searchedConnectionName) {
            return true;
        }
    }
    return false;
};
exports.isElementInOpenSQLCommandsArray = isElementInOpenSQLCommandsArray;


/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.info = exports.showOutput = void 0;
const vscode = __webpack_require__(65);
let outputChannel = vscode.window.createOutputChannel('mateo');
function showOutput() {
    outputChannel.show(true);
}
exports.showOutput = showOutput;
function info(msg) {
    console.log(new Date().toLocaleString() + ": " + msg);
    outputChannel.appendLine(new Date().toLocaleString() + ": " + msg);
}
exports.info = info;


/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtensionDataHolder = void 0;
const vscode = __webpack_require__(65);
class ExtensionDataHolder {
    constructor() {
        this.diagnosticCollection = vscode.languages.createDiagnosticCollection('mateo');
    }
    static getInstance() {
        if (!ExtensionDataHolder.instance) {
            ExtensionDataHolder.instance = new ExtensionDataHolder();
        }
        return ExtensionDataHolder.instance;
    }
}
exports.ExtensionDataHolder = ExtensionDataHolder;


/***/ }),
/* 73 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AxiosUtils = void 0;
const vscode = __webpack_require__(65);
class AxiosUtils {
    static getAxiosAuth() {
        return __awaiter(this, void 0, void 0, function* () {
            let axiosAuth = { username: "", password: "" };
            let config = vscode.workspace.getConfiguration('mateo');
            if (!config.rejectUnauthorized) {
                process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
            }
            else {
                process.env.NODE_TLS_REJECT_UNAUTHORIZED = '1';
            }
            if (config.mateoAuthEnabled && AxiosUtils.password == undefined) {
                AxiosUtils.password = yield vscode.window.showInputBox({ password: true, placeHolder: "PASSWORD" });
            }
            axiosAuth.username = config.user;
            axiosAuth.password = AxiosUtils.password || "";
            return axiosAuth;
        });
    }
}
exports.AxiosUtils = AxiosUtils;


/***/ }),
/* 74 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResponseHandler = void 0;
const logger = __webpack_require__(71);
const vscode = __webpack_require__(65);
const codeUtils = __webpack_require__(70);
const extensionDataHolder_1 = __webpack_require__(72);
class ResponseHandler {
    static handleResponseAndOpenInBrowser(response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (vscode.workspace.getConfiguration('mateo').openWebReport) {
                let reportWebUrl = vscode.workspace.getConfiguration('mateo').mateoHostUrl + "/frontend/#/report";
                vscode.env.openExternal(vscode.Uri.parse(reportWebUrl));
            }
            else if (response.data.xmlFilepath) {
                const reportFilename = response.data.xmlFilepath.slice(0, response.data.xmlFilepath.length - 3) + "html";
                logger.info("Opening report: " + reportFilename);
                vscode.env.openExternal(vscode.Uri.file(reportFilename));
                vscode.window.showInformationMessage("Result: " + response.data.testSetResults.default.longDescription);
            }
            if (response.data.parserErrors) {
                ResponseHandler.handleValidationErrors(response.data.parserErrors, codeUtils.getFileName());
            }
        });
    }
}
exports.ResponseHandler = ResponseHandler;
ResponseHandler.dataHolder = extensionDataHolder_1.ExtensionDataHolder.getInstance();
ResponseHandler.handleValidationErrors = function (errorData, scriptFileName) {
    logger.info("ErrorData: " + JSON.stringify(errorData));
    logger.info("ScriptFileName: " + scriptFileName);
    let diagnosticMap = new Map();
    for (const [key, val] of Object.entries(errorData)) {
        let filename = key.substring(0, key.lastIndexOf(":"));
        let lineNumber = +key.substring(key.lastIndexOf(":") + 1);
        filename = filename.replace(/^.*(\\|\/|\:)/, '');
        let errorText = val;
        // +keySplit means that it is an integer
        if (scriptFileName.includes(filename)) {
            filename = codeUtils.getWorkspaceFolderUnixStyle() + '/' + filename;
        }
        let canonicalFile = vscode.Uri.file(filename).toString();
        let range = new vscode.Range(lineNumber - 1, 0, lineNumber - 1, 100);
        let diagnostics = diagnosticMap.get(canonicalFile);
        if (!diagnostics) {
            diagnostics = [];
        }
        diagnostics.push(new vscode.Diagnostic(range, errorText, vscode.DiagnosticSeverity.Error));
        diagnosticMap.set(canonicalFile, diagnostics);
    }
    diagnosticMap.forEach((diags, file) => {
        ResponseHandler.dataHolder.diagnosticCollection.set(vscode.Uri.parse(file), diags);
    });
    if (Object.keys(errorData).length > 0) {
        vscode.window.showWarningMessage("Found validation errors");
        vscode.commands.executeCommand("workbench.actions.view.problems");
    }
};


/***/ }),
/* 75 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const snippetRunner_1 = __webpack_require__(69);
const vscode = __webpack_require__(65);
const axios_1 = __webpack_require__(1);
const axiosUtils_1 = __webpack_require__(73);
const https_1 = __webpack_require__(27);
class RepoParser {
    static parseUsedRepositories(scriptContent, workspacePath) {
        return __awaiter(this, void 0, void 0, function* () {
            let linesContainingUse = (0, snippetRunner_1.getUseLines)(scriptContent);
            let usedReposSourceCodePromise = (0, snippetRunner_1.generateUseResources)(linesContainingUse, "", workspacePath);
            let usedReposSourceCode = RepoParser.removeFirstLine(yield usedReposSourceCodePromise);
            let config = vscode.workspace.getConfiguration("mateo");
            let queryParams = {
                auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
                httpsAgent: new https_1.Agent({
                    rejectUnauthorized: config.rejectUnauthorized,
                }),
                headers: {
                    "Content-Type": "text/plain",
                },
                params: {},
            };
            let repoModels = [];
            yield axios_1.default
                .post(config.mateoHostUrl + "/api/repository/parse-mrepo-files", usedReposSourceCode, queryParams)
                .then(function (response) {
                repoModels = response.data;
                for (let repoModel of repoModels) {
                    repoModel.name = RepoParser.toLocalPath(repoModel.repositoryFilePath);
                }
            })
                .catch(function (error) {
                console.log("Error during execution: " + error.response.data);
            })
                .then(undefined, (err) => {
                console.log("Something went wrong: " + err);
            });
            return repoModels;
        });
    }
    static toLocalPath(path) {
        let localPath = path.split("mateoTmp")[1];
        localPath = localPath.substring(1, localPath.length); // trim redundant folder-separator.
        while (localPath.includes("currentDummy")) {
            localPath = localPath.replace("currentDummy", ".");
        }
        while (localPath.includes("parentDummy")) {
            localPath = localPath.replace("parentDummy", "..");
        }
        while (localPath.includes("\\")) {
            localPath = localPath.replace("\\", "/");
        }
        return localPath;
    }
    static removeFirstLine(text) {
        let lines = text.split("\n");
        // remove one line, starting at the first position
        lines.splice(0, 1);
        // join the array back into a single string
        return lines.join("\n");
    }
}
exports["default"] = RepoParser;


/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StepRecommendationsBuffer = void 0;
const vscode = __webpack_require__(65);
const RepositoryProcessor_1 = __webpack_require__(77);
class StepRecommendationsBuffer {
    constructor() {
        /**
         * The list of potential code completions for the local repositories.
         */
        this.localRecommendations = [];
        /**
         * The list of potential code completions for the global repositories stored in the backend.
         */
        this.globalRecommendations = [];
    }
    /**
     * Provides code completions based on the given ordered array of repositories.
     * @param repos The list of repositories from which to extract the steps and return as code completion.
     * Note that if a name appears in two distinct repositories,
     * then only the first repositories step is included in the resulting
     * list of code completions.
     * @returns A list of code completions that contains the steps of the repositories.
     */
    getCompletionItemsForPriorizedRepos(repos) {
        let completionItems = [];
        let stepNamesAdded = [];
        for (let repo of repos) {
            for (let recommendation of this.localRecommendations) {
                if (recommendation.repoName === repo &&
                    !stepNamesAdded.includes(recommendation.stepName)) {
                    completionItems.push(this.intellisenseModelToCodeCompletion(recommendation));
                    stepNamesAdded.push(recommendation.stepName);
                }
            }
        }
        return completionItems;
    }
    getCompletionItemsForBackendRepos() {
        return this.globalRecommendations.map((x) => this.intellisenseModelToCodeCompletion(x));
    }
    getSnippetsForKey(key) {
        return this.localRecommendations
            .filter((x) => x.aliasName === key)
            .map((x) => x.snippet);
    }
    /**
     * Regarding global repositories in the backend, we can assume that all step names are distinct.
     * @param models The models that need to be buffered.
     */
    initializeGlobalRepos(models) {
        this.globalRecommendations = [];
        for (let model of models) {
            this.globalRecommendations = this.globalRecommendations.concat(this.backendModelToIntellisenseArray(model));
        }
    }
    backendModelToIntellisenseArray(repoModel) {
        let completionsForRepo = RepositoryProcessor_1.default.convertStepToSnippet(repoModel);
        let intellisenseModels = [];
        for (let completion of completionsForRepo) {
            intellisenseModels.push({
                aliasName: null,
                repoName: repoModel.name,
                snippet: completion.snippet,
                stepName: completion.stepname,
            });
        }
        return intellisenseModels;
    }
    intellisenseModelToCodeCompletion(model) {
        let stepFromRepoCommandCompletion = new vscode.CompletionItem(model.stepName);
        stepFromRepoCommandCompletion.insertText = new vscode.SnippetString(model.snippet);
        stepFromRepoCommandCompletion.kind = vscode.CompletionItemKind.Snippet;
        stepFromRepoCommandCompletion.detail = "Step";
        stepFromRepoCommandCompletion.sortText = "AAABBB";
        return stepFromRepoCommandCompletion;
    }
    setSnippets(alias, snippets, repo) {
        if (this.localRecommendations.filter((x) => x.aliasName === alias && x.repoName === repo).length == 0) {
            for (let currentSnippet of snippets) {
                this.localRecommendations.push({
                    aliasName: alias,
                    repoName: repo,
                    snippet: currentSnippet,
                    stepName: currentSnippet.split("(")[0],
                });
            }
        }
    }
    clearLocalRecommendations() {
        this.localRecommendations = [];
    }
}
exports.StepRecommendationsBuffer = StepRecommendationsBuffer;


/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class RepositoryProcessor {
    static convertStepToSnippet(model) {
        let snippets = [];
        for (let i = 0; i < model.repoItems.length; i++) {
            let step = model.repoItems[i].stepName;
            let snippet = step + "(";
            for (let paramIndex = 0; paramIndex < model.repoItems[i].stepParams.length; paramIndex++) {
                snippet +=
                    model.repoItems[i].stepParams[paramIndex] +
                        ' = "$' +
                        (paramIndex + 1) +
                        '"';
                if (paramIndex + 1 < model.repoItems[i].stepParams.length) {
                    snippet += ",";
                }
            }
            snippet += ")";
            if (snippet) {
                snippets.push({ snippet: snippet, stepname: step });
            }
        }
        return snippets;
    }
}
exports["default"] = RepositoryProcessor;


/***/ }),
/* 78 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantsRecommender = void 0;
const vscode = __webpack_require__(65);
const snippetRunner_1 = __webpack_require__(69);
const RepoParser_1 = __webpack_require__(75);
const https_1 = __webpack_require__(27);
const axiosUtils_1 = __webpack_require__(73);
const axios_1 = __webpack_require__(1);
const codeUtils_1 = __webpack_require__(70);
class ConstantsRecommender {
    provideRecommendation(document, uriFsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let constants = [];
            constants = constants.concat(this.provideConstantsFromLocalScriptFile(document));
            constants = constants.concat(yield this.provideConstantsFromRepos(document, uriFsPath));
            constants = constants.concat(yield this.provideConstantsfromGlobalRepos());
            let vsCompletionItems = [];
            for (let stringCompletion of constants) {
                let item = new vscode.CompletionItem(stringCompletion);
                item.insertText = "%" + stringCompletion + "%";
                item.kind = vscode.CompletionItemKind.Constant;
                item.sortText = "AAACCC";
                vsCompletionItems.push(item);
                item.detail = "Constant";
            }
            let variables = [];
            variables = variables.concat(this.provideLocalVariables(document));
            for (let stringCompletion of variables) {
                let item = new vscode.CompletionItem(stringCompletion);
                item.insertText = "§" + stringCompletion + "§";
                item.kind = vscode.CompletionItemKind.Variable;
                item.sortText = "AAADDD";
                vsCompletionItems.push(item);
                item.detail = "Storage variable";
            }
            return vsCompletionItems;
        });
    }
    /**
     * This method provides only the names of the variables that were defined locally
     * within the mateo script
     * (No check for the storage in backend or variables that were defined in repositories)
     * @param document The currently edited mateo script file.
     */
    provideLocalVariables(document) {
        let localVariables = [];
        let lines = this.extractLines(document);
        for (let line = 0; line < lines.length; line++) {
            let currentLine = lines[line];
            if (this.containsVariableDefinition(currentLine)) {
                localVariables.push(this.extractVariableRecommendation(currentLine));
            }
        }
        return localVariables;
    }
    provideConstantsfromGlobalRepos() {
        return __awaiter(this, void 0, void 0, function* () {
            let config = vscode.workspace.getConfiguration("mateo");
            let queryParams = {
                auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
                httpsAgent: new https_1.Agent({
                    rejectUnauthorized: config.rejectUnauthorized,
                }),
                params: {},
            };
            let constants = [];
            yield axios_1.default
                .get(config.mateoHostUrl + "/api/repository/constants", queryParams)
                .then(function (response) {
                constants = response.data;
            })
                .catch(function (error) {
                console.log("Error during execution: " + error.response.data);
            })
                .then(undefined, (err) => {
                console.log("Something went wrong: " + err);
            });
            let globalConstants = [];
            for (let constant of constants) {
                globalConstants.push(constant.key);
            }
            return globalConstants;
        });
    }
    provideConstantsFromRepos(document, uriFsPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let linesContainingUse = (0, snippetRunner_1.getUseLines)(document);
            let usedReposSourceCodePromise = (0, snippetRunner_1.generateUseResources)(linesContainingUse, "", (0, snippetRunner_1.retrieveWorkspacePath)(uriFsPath));
            let usedReposSourceCode = RepoParser_1.default.removeFirstLine(yield usedReposSourceCodePromise);
            usedReposSourceCode = (0, codeUtils_1.removeComments)((0, codeUtils_1.removeLinebreaks)(usedReposSourceCode));
            let repoSourceCodeLines = usedReposSourceCode.split(/\r?\n/);
            let repoConstants = [];
            for (let lineIndex = 0; lineIndex < repoSourceCodeLines.length; lineIndex++) {
                let currentLine = repoSourceCodeLines[lineIndex];
                if (this.containsConstantDefinition(currentLine)) {
                    repoConstants.push(this.extractConstantRecommendation(currentLine));
                }
            }
            return repoConstants;
        });
    }
    provideConstantsFromLocalScriptFile(document) {
        let localConstants = [];
        let lines = this.extractLines(document);
        for (let line = 0; line < lines.length; line++) {
            let currentLine = lines[line];
            if (this.containsConstantDefinition(currentLine)) {
                localConstants.push(this.extractConstantRecommendation(currentLine));
            }
        }
        return localConstants;
    }
    containsConstantDefinition(line) {
        return line.includes("const ") && line.includes("=");
    }
    containsVariableDefinition(line) {
        return line.includes("set ") && line.includes("=");
    }
    extractConstantRecommendation(line) {
        return line
            .substring(line.indexOf("const ") + "const ".length, line.indexOf("="))
            .trim();
    }
    extractVariableRecommendation(line) {
        return line
            .substring(line.indexOf("set ") + "set ".length, line.indexOf("="))
            .trim();
    }
    extractLines(text) {
        return text.split("\n");
    }
}
exports.ConstantsRecommender = ConstantsRecommender;


/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandAlternativeName = void 0;
class CommandAlternativeName {
    constructor() {
        this.commandAlternativeNames = new Map([
            ["checkCheckboxSelectedWeb", "checkElementSelectedWeb"],
            ["checkElementPresentWeb", "checkElementPresent"],
            ["checkElementNotPresent", "checkElementNotPresentWeb"],
            ["waitForElementVisibleWeb", "waitForElementWebVisible"],
            ["moveFilesOlderThan", "moveFile"],
        ]);
    }
    commandNameHasAlternative(commandName) {
        if (this.commandAlternativeNames.get(commandName) !== undefined) {
            return this.commandAlternativeNames.get(commandName);
        }
        else {
            return commandName;
        }
    }
}
exports.CommandAlternativeName = CommandAlternativeName;


/***/ }),
/* 80 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constantExtractor = void 0;
const vscode = __webpack_require__(65);
exports.constantExtractor = vscode.commands.registerCommand('extension.mateo.constantExtractor', () => __awaiter(void 0, void 0, void 0, function* () {
    const editor = vscode.window.activeTextEditor;
    if (editor === undefined) {
        vscode.window.showErrorMessage("No editor available!");
        return;
    }
    const selectedText = editor.document.getText(editor.selection);
    if (selectedText === undefined || selectedText.length == 0) {
        vscode.window.showErrorMessage("No text selected to extract. Please select some text.");
        return;
    }
    const originalSelection = editor.selection;
    // Retrieve constant name from user
    const constantName = yield vscode.window.showInputBox({
        placeHolder: "Desired constant's name",
        prompt: "Replaces all occurrences of selected text with constant reference. Be sure to use this for elements occurring inside command parameters only.",
        value: ""
    });
    if (constantName == "" || constantName === undefined) {
        vscode.window.showErrorMessage("No constant name entered. Please enter a constant name.");
        return;
    }
    // Replace all instances of selected text with constant name
    let doc = editor.document;
    const docText = doc.getText();
    const replacedText = docText.replaceAll(selectedText, `%${constantName}%`);
    // Append constant to beginning of script
    const constLine = `const ${constantName} = "${selectedText}"\n`;
    // Replaces whole document
    // (There might be more elegant solution to this (i.e. only prepending the newly created line to the document)...)
    editor.edit(editBuilder => {
        editBuilder.replace(new vscode.Range(doc.lineAt(0).range.start, doc.lineAt(doc.lineCount - 1).range.end), constLine + replacedText);
    });
    // Selects newly replaced content
    editor.selection = new vscode.Selection(originalSelection.anchor.line + 1, originalSelection.anchor.character, originalSelection.anchor.line + 1, originalSelection.anchor.character + constantName.length + 2);
}));


/***/ }),
/* 81 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abort = void 0;
const vscode = __webpack_require__(65);
const logger = __webpack_require__(71);
const axiosUtils_1 = __webpack_require__(73);
const axios_1 = __webpack_require__(1);
const https_1 = __webpack_require__(27);
exports.abort = vscode.commands.registerCommand('extension.mateo.abort', () => __awaiter(void 0, void 0, void 0, function* () {
    abortScripts();
}));
const abortScripts = function () {
    return __awaiter(this, void 0, void 0, function* () {
        logger.showOutput();
        let textEditor = vscode.window.activeTextEditor;
        if (!textEditor) {
            return "";
        }
        // send abort request
        logger.info("Send abort request");
        vscode.window.showInformationMessage("Abort script runs");
        let config = vscode.workspace.getConfiguration('mateo');
        let queryParams = {
            auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
            httpsAgent: new https_1.Agent({
                rejectUnauthorized: vscode.workspace.getConfiguration('mateo').rejectUnauthorized
            })
        };
        axios_1.default.get(config.mateoHostUrl + '/api/abort/all-runs', queryParams)
            .then(function (response) {
            // handle success
            logger.info("StatusCode: " + response.status);
            vscode.window.showInformationMessage("Scripts aborted");
        })
            .catch(function (error) {
            // handle error
            if (error.response === undefined) {
                axiosUtils_1.AxiosUtils.password = undefined;
                vscode.window.showErrorMessage("Was not able to abort! mateo not running?");
            }
            else {
                vscode.window.showWarningMessage("Failed to abort scripts");
            }
        });
    });
};


/***/ }),
/* 82 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runFullScript = void 0;
const vscode = __webpack_require__(65);
const codeUtils = __webpack_require__(70);
const axios_1 = __webpack_require__(1);
const axiosUtils_1 = __webpack_require__(73);
const logger = __webpack_require__(71);
const responseHandler_1 = __webpack_require__(74);
const https_1 = __webpack_require__(27);
exports.runFullScript = vscode.commands.registerCommand('extension.mateo.runFullScript', () => __awaiter(void 0, void 0, void 0, function* () {
    logger.showOutput();
    let textEditor = vscode.window.activeTextEditor;
    if (!textEditor) {
        return "";
    }
    let config = vscode.workspace.getConfiguration('mateo');
    let fileName = codeUtils.getFileName();
    //vscode.window.showInformationMessage("Running '" + fileName + "' on: " + config.mateoHostUrl)
    vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Running '" + fileName + "' on: " + config.mateoHostUrl,
        cancellable: false
    }, (progress, token) => {
        return new Promise(resolve => {
            runScript(resolve, fileName, config.mateoHostUrl);
        });
    });
}));
function runScript(resolve, fileName, host) {
    return __awaiter(this, void 0, void 0, function* () {
        let queryParams = {
            auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
            httpsAgent: new https_1.Agent({
                rejectUnauthorized: vscode.workspace.getConfiguration('mateo').rejectUnauthorized
            })
        };
        let filenameEncoded = encodeURIComponent(fileName);
        logger.info("filenameEncoded: " + filenameEncoded);
        axios_1.default.post(host + '/run/filename/json?filename=' + filenameEncoded, {}, queryParams)
            .then(function (response) {
            responseHandler_1.ResponseHandler.handleResponseAndOpenInBrowser(response);
            resolve();
        }).catch(function (error) {
            if (error.response && error.response.data) {
                logger.info(error.response.data);
                if (error.response.data.xmlFilepath) {
                    const reportFilename = error.response.data.xmlFilepath.slice(0, error.response.data.xmlFilepath.length - 3) + "html";
                    logger.info("Opening report: " + reportFilename);
                    vscode.env.openExternal(vscode.Uri.file(reportFilename));
                    vscode.window.showErrorMessage("Result: " + error.response.data.testSetResults.default.longDescription);
                }
                else {
                    // parsing error
                    vscode.window.showErrorMessage("Execution failed: " + error.response.data);
                }
            }
            else {
                vscode.window.showErrorMessage("Failed to connect to mateo. Mateo not running?");
            }
            resolve();
        });
    });
}


/***/ }),
/* 83 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reloadGlobalRepos = void 0;
const vscode = __webpack_require__(65);
const axios_1 = __webpack_require__(1);
const axiosUtils_1 = __webpack_require__(73);
const https_1 = __webpack_require__(27);
exports.reloadGlobalRepos = vscode.commands.registerCommand('extension.mateo.reloadGlobalRepos', () => __awaiter(void 0, void 0, void 0, function* () {
    let config = vscode.workspace.getConfiguration("mateo");
    let queryParams = {
        auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
        httpsAgent: new https_1.Agent({
            rejectUnauthorized: config.rejectUnauthorized,
        }),
        headers: {
            "Content-Type": "text/plain",
        },
        params: {},
    };
    yield axios_1.default
        .post(config.mateoHostUrl + "/api/repository/refresh", queryParams)
        .then(function (response) {
        vscode.window.showInformationMessage("Reloaded repositories in the backend (status: " + response.status + ")");
    })
        .catch(function (error) {
        console.log("Error reloading of backend repos: " + error.response.data);
        vscode.window.showErrorMessage("Error during reload of repos in the backend.");
    })
        .then(undefined, (err) => {
        console.log("error while reloading the repos in the backend " + err);
    });
}));


/***/ }),
/* 84 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validate = void 0;
const vscode = __webpack_require__(65);
const codeUtils = __webpack_require__(70);
const logger = __webpack_require__(71);
const extensionDataHolder_1 = __webpack_require__(72);
const axiosUtils_1 = __webpack_require__(73);
const responseHandler_1 = __webpack_require__(74);
const axios_1 = __webpack_require__(1);
const https_1 = __webpack_require__(27);
const dataHolder = extensionDataHolder_1.ExtensionDataHolder.getInstance();
exports.validate = vscode.commands.registerCommand('extension.mateo.validate', () => __awaiter(void 0, void 0, void 0, function* () {
    // determine mode from selection (snippet/complete file)
    validateScript();
}));
let validateOnSave = vscode.commands.registerCommand('extension.mateo.validateOnSave', () => __awaiter(void 0, void 0, void 0, function* () {
    validateScript();
}));
const validateScript = function () {
    return __awaiter(this, void 0, void 0, function* () {
        logger.showOutput();
        let textEditor = vscode.window.activeTextEditor;
        if (!textEditor) {
            return "";
        }
        // send validation request
        logger.info("Validating: " + textEditor.document.fileName);
        dataHolder.diagnosticCollection.clear();
        vscode.window.showInformationMessage("Validating file " + textEditor.document.fileName);
        let config = vscode.workspace.getConfiguration('mateo');
        let queryParams = {
            auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
            httpsAgent: new https_1.Agent({
                rejectUnauthorized: vscode.workspace.getConfiguration('mateo').rejectUnauthorized
            })
        };
        axios_1.default.post(config.mateoHostUrl + '/dsl/validateFile?filename=' + encodeURIComponent(textEditor.document.fileName), {}, queryParams)
            .then(function (response) {
            // handle success
            logger.info("StatusCode: " + response.status);
            const errorData = response.data;
            if (errorData && Object.keys(errorData).length > 0) {
                responseHandler_1.ResponseHandler.handleValidationErrors(errorData, codeUtils.getFileName());
            }
            else {
                vscode.window.showInformationMessage("No validation errors.");
            }
        })
            .catch(function (error) {
            // handle error
            let filename = vscode.Uri.file(codeUtils.getFileName()).toString();
            let diagnostics = [];
            let range = new vscode.Range(0, 0, 0, 100);
            if (error.response === undefined) {
                axiosUtils_1.AxiosUtils.password = undefined;
                vscode.window.showErrorMessage("Was not able to validate! mateo not running?");
            }
            else {
                vscode.window.showWarningMessage("Had validation errors");
                diagnostics.push(new vscode.Diagnostic(range, error.response.data, vscode.DiagnosticSeverity.Error));
                dataHolder.diagnosticCollection.set(vscode.Uri.parse(filename), diagnostics);
            }
        });
    });
};


/***/ }),
/* 85 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runSingleCommand = void 0;
const vscode = __webpack_require__(65);
const codeUtils = __webpack_require__(70);
const axios_1 = __webpack_require__(1);
const logger = __webpack_require__(71);
const https_1 = __webpack_require__(27);
const axiosUtils_1 = __webpack_require__(73);
exports.runSingleCommand = vscode.commands.registerCommand('extension.mateo.runSingleCommand', () => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    logger.showOutput();
    logger.info(((_a = vscode.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document.fileName) || "");
    let code = codeUtils.getSelectedCode();
    if (code === '') {
        return;
    }
    let textEditor = vscode.window.activeTextEditor;
    if (!textEditor) {
        return "";
    }
    let baseDir = (_b = vscode.window.activeTextEditor) === null || _b === void 0 ? void 0 : _b.document.fileName;
    let codeSplit = code.split(/(?:\r)?\n/);
    //vscode.window.showInformationMessage("Running '" + fileName + "' on: " + config.mateoHostUrl)
    yield executeLineByLine(codeSplit, baseDir);
}));
function executeLineByLine(lines, baseDir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (lines === undefined || lines.length == 0) {
            return;
        }
        let codeLine = lines[0];
        let COMMAND_PATTERN = "^(\\s*)([a-z][a-zA-Z0-9\\s\\-_]*)\\((.*)\\)\\s*";
        let STEP_PATTERN = "^(\\s*)([A-Z][a-zA-Z0-9\\s\\-_]*)\\((.*)\\)\\s*";
        let REF_STEP_PATTERN = "^(\\s*)([a-zA-Z0-9\\s\\-_]*)\\.([A-Z][a-zA-Z0-9\\s\\-_]*)\\((.*)\\)\\s*";
        let PARAMETER_VALUES_PATTERN = /,(?=([^"]*"[^"]*")*[^"]*$)/;
        let commandName;
        let commandParameters = {};
        let codeLineMatch = codeLine.match(COMMAND_PATTERN);
        let config = vscode.workspace.getConfiguration('mateo');
        if (codeLineMatch) {
            commandName = codeLineMatch[2];
            let paramSplit = codeLineMatch[3].split(PARAMETER_VALUES_PATTERN);
            paramSplit.forEach(param => {
                let paramKey = param.substring(0, param.indexOf('=')).trim();
                let paramValue = param.substring(param.indexOf('=') + 1).trim().substring(1);
                paramValue = paramValue.substring(0, paramValue.length - 1);
                commandParameters[paramKey] = paramValue;
            });
            let commandObject = {
                "localizedCommandName": commandName,
                "commandParameters": commandParameters
            };
            let queryParams = {
                auth: yield axiosUtils_1.AxiosUtils.getAxiosAuth(),
                httpsAgent: new https_1.Agent({
                    rejectUnauthorized: vscode.workspace.getConfiguration('mateo').rejectUnauthorized
                }),
            };
            logger.info("Executing: " + JSON.stringify(commandObject));
            let filenameEncoded = encodeURIComponent(baseDir + "");
            axios_1.default.post(config.mateoHostUrl + '/command?fileName=' + filenameEncoded, commandObject, queryParams)
                .then(function (response) {
                var _a;
                logger.info("Result: " + response.data);
                lines.shift();
                executeLineByLine(lines, ((_a = vscode.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document.fileName) || "");
            }).catch(function (error) {
                logger.info("Error during execution: " + error.response.data);
                vscode.window.showWarningMessage(error.response.data + " [ " + codeLine.trim() + " ]");
            }).then(undefined, err => {
                logger.info("Something went wrong: " + err);
            });
        }
        else {
            if (codeLine.match(STEP_PATTERN) || codeLine.match(REF_STEP_PATTERN)) {
                vscode.window.showErrorMessage("Steps cannot be executed via 'execute command(s)'. To execute steps, please use 'execute snippet'");
            }
            else {
                vscode.window.showErrorMessage("Command could not be executed. Please make sure that it is a valid mateo command");
            }
            logger.info("ERROR: Command could not be executed. Please note error message");
            lines.shift();
            executeLineByLine(lines, baseDir);
        }
    });
}


/***/ }),
/* 86 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lintBP = void 0;
const vscode = __webpack_require__(65);
const codeUtils = __webpack_require__(70);
const decorationErrorType = vscode.window.createTextEditorDecorationType({
    textDecoration: 'underline dotted red',
    overviewRulerColor: 'red',
    overviewRulerLane: vscode.OverviewRulerLane.Left
});
const decorationWarningType = vscode.window.createTextEditorDecorationType({
    textDecoration: 'underline dotted orange',
    overviewRulerColor: 'orange',
    overviewRulerLane: vscode.OverviewRulerLane.Left
});
const decorationInfoType = vscode.window.createTextEditorDecorationType({
    textDecoration: 'underline dotted yellow',
    overviewRulerColor: 'yellow',
    overviewRulerLane: vscode.OverviewRulerLane.Left
});
let arrErrorDecorations = [];
let arrWarningDecorations = [];
let arrInfoDecorations = [];
exports.lintBP = vscode.commands.registerCommand('extension.mateo.lintBP', () => __awaiter(void 0, void 0, void 0, function* () {
    decorate();
}));
const decorate = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const activeEditor = vscode.window.activeTextEditor;
        if (!activeEditor) {
            return;
        }
        let sourceCode = activeEditor.document.getText();
        const sourceCodeArr = sourceCode.split('\n');
        arrErrorDecorations = [];
        arrWarningDecorations = [];
        arrInfoDecorations = [];
        if (vscode.workspace.getConfiguration('mateo').bestPracticesLinter.CheckForCorrectNamingOfConstants) {
            bpConstantsNamingConvention(sourceCodeArr);
        }
        if (vscode.workspace.getConfiguration('mateo').bestPracticesLinter.CheckForCorrectNamingOfVariables) {
            bpVariablesNamingConvention(sourceCodeArr);
        }
        if (vscode.workspace.getConfiguration('mateo').bestPracticesLinter.CommentCommandBeforeControlStructure) {
            bpCommentBeforeControlStructure(activeEditor, sourceCodeArr);
        }
        if (vscode.workspace.getConfiguration('mateo').bestPracticesLinter.CorrectSQLCommandsOrder) {
            bpOrderOfSqlCommands(activeEditor, sourceCodeArr);
        }
        activeEditor.setDecorations(decorationErrorType, arrErrorDecorations);
        activeEditor.setDecorations(decorationWarningType, arrWarningDecorations);
        activeEditor.setDecorations(decorationInfoType, arrInfoDecorations);
    });
};
function bpConstantsNamingConvention(sourceCodeArr) {
    /*  Die Funktion prüft die Benennung von Konstanten: Es sollten nur Großbuchstaben, Zahlen und die Zeichen '-' und '_' genutzt werden.
     */
    const regConstantDeclarationActual = new RegExp("^\\s*const\\s+(?<ConstantName>[a-zA-Z0-9\\-_]+)\\s*=[\\s\\S]*");
    const regConstantDeclarationTarget = new RegExp("^\\s*const\\s+(?<ConstantName>[A-Z0-9\\-_]+)\\s*=[\\s\\S]*");
    const regIgnoreLine = new RegExp(".*(#NoLinter|#NOLINTER)\\r?$");
    for (let line = 0; line < sourceCodeArr.length; line++) {
        if (regConstantDeclarationActual.test(sourceCodeArr[line]) == true && // es wurde eine Deklaration einer Konstante mithilfe der const-Anweisung in der aktuellen Zeile erkannt
            regConstantDeclarationTarget.test(sourceCodeArr[line]) == false && // der Name der Variable entspricht nicht der Konvention
            regIgnoreLine.test(sourceCodeArr[line]) == false) { // die Zeile soll nicht ignoriert werden
            let match = sourceCodeArr[line].match(regConstantDeclarationActual);
            let matchConstantName = sourceCodeArr[line].match(match.groups.ConstantName);
            let beginPos = matchConstantName.index;
            let endPos = beginPos + matchConstantName[0].length;
            let range = new vscode.Range(new vscode.Position(line, beginPos), new vscode.Position(line, endPos));
            let markdown = new vscode.MarkdownString('## Best Practice Linter \n');
            markdown.appendMarkdown('Die Bezeichnung einer Konstante sollte nur Großbuchstaben, Zahlen und die Zeichen \"-\" oder \"_\" enthalten! \n \n');
            markdown.appendMarkdown('Diese Regel kann mit dem Kommentar \"#NoLinter\" oder \"#NOLINTER\" in dieser Zeile ignoriert werden. \n \n');
            let decoration = { range, hoverMessage: markdown };
            arrWarningDecorations.push(decoration);
        }
    }
}
function bpVariablesNamingConvention(sourceCodeArr) {
    /*  Die Funktion prüft die Benennung von Variablen: Diese sollte der lowerCamelCase-Konvention folgen und erlaubt neben einem führenden Klein- auch Großbuchstaben und Zahlen.
        Der reguläre Ausdruck für die lowerCamelCase Konvention lautet: [a-z]([A-Z0-9]*[a-z][a-z0-9]*[A-Z]|[a-z0-9]*[A-Z][A-Z0-9]*[a-z])[A-Za-z0-9]*
     */
    const regVariableDeclarationActual = new RegExp("^\\s*set\\s+(?<VariableName>[a-zA-Z0-9\\-_]+)\\s*=[\\s\\S]*");
    const regVariableDeclarationTarget = new RegExp("^\\s*set\\s+(?<VariableName>[a-z]([A-Z0-9]*[a-z][a-z0-9]*[A-Z]|[a-z0-9]*[A-Z][A-Z0-9]*[a-z])[A-Za-z0-9]*)\\s*=[\\s\\S]*");
    const regVariableCommandActual = new RegExp("^\\s*setStorageValue\\(.*(?:TARGET_STORAGE_KEY\\s+=\\s+)[\"|'](?<VariableName>[a-zA-Z0-9\\-_]+)[\"|'].*\\)\\s*");
    const regVariableCommandTarget = new RegExp("^\\s*setStorageValue\\(.*(?:TARGET_STORAGE_KEY\\s+=\\s+)[\"|'](?<VariableName>[a-z](?:[A-Z0-9]*[a-z][a-z0-9]*[A-Z]|[a-z0-9]*[A-Z][A-Z0-9]*[a-z])[A-Za-z0-9]*)[\"|'].*\\)\\s*");
    const regIgnoreLine = new RegExp(".*(#NoLinter|#NOLINTER)\\r$");
    for (let line = 0; line < sourceCodeArr.length; line++) {
        if (regVariableDeclarationActual.test(sourceCodeArr[line]) == true && // es wurde eine Deklaration einer Variable mithilfe der set-Anweisung in der aktuellen Zeile erkannt
            regVariableDeclarationTarget.test(sourceCodeArr[line]) == false && // der Name der Variable entspricht nicht der Konvention
            regIgnoreLine.test(sourceCodeArr[line]) == false) { // die Zeile soll nicht ignoriert werden
            let match = sourceCodeArr[line].match(regVariableDeclarationActual);
            let matchVariableName = sourceCodeArr[line].match(match.groups.VariableName);
            let beginPos = matchVariableName.index;
            let endPos = beginPos + matchVariableName[0].length;
            let range = new vscode.Range(new vscode.Position(line, beginPos), new vscode.Position(line, endPos));
            let markdown = new vscode.MarkdownString('## Best Practice Linter \n');
            markdown.appendMarkdown('Die Bezeichnung einer Variablen sollte der lowerCamelCase-Konvention folgen! \n \n');
            markdown.appendMarkdown('Diese Regel kann mit dem Kommentar \"#NoLinter\" oder \"#NOLINTER\" in dieser Zeile ignoriert werden.');
            let decoration = { range, hoverMessage: markdown };
            arrWarningDecorations.push(decoration);
        }
        else if (regVariableCommandActual.test(sourceCodeArr[line]) == true && // es wurde eine Deklaration einer Variable mithilfe eines setStorageValue()-Kommandos in der aktuellen Zeile erkannt
            regVariableCommandTarget.test(sourceCodeArr[line]) == false && // der Name der Variable entspricht nicht der Konvention
            regIgnoreLine.test(sourceCodeArr[line]) == false) { // die Zeile soll nicht ignoriert werden
            let match = sourceCodeArr[line].match(regVariableCommandActual);
            let matchVariableName = sourceCodeArr[line].match(match.groups.VariableName);
            let beginPos = matchVariableName.index;
            let endPos = beginPos + matchVariableName[0].length;
            let range = new vscode.Range(new vscode.Position(line, beginPos), new vscode.Position(line, endPos));
            let markdown = new vscode.MarkdownString('## Best Practice Linter \n');
            markdown.appendMarkdown('Die Bezeichnung einer Variablen sollte der lowerCamelCase-Konvention folgen! \n \n');
            markdown.appendMarkdown('Diese Regel kann mit dem Kommentar \"#NoLinter\" oder \"#NOLINTER\" in dieser Zeile ignoriert werden.');
            let decoration = { range, hoverMessage: markdown };
            arrWarningDecorations.push(decoration);
        }
    }
}
function bpCommentBeforeControlStructure(editor, sourceCodeArr) {
    /*  Diese Funktion überprüft, ob ein Comment()-Kommando vor einer Kontrollstruktur steht.
        Hintergrund: Laut den Testern (Hannes & Sven) ist es gute Praxis, da man so einem Fach'ler kurz informiert,
        welche Funktion die Kontrollstruktur an dieser Stelle erfüllt.
     */
    const regControlStructure = new RegExp("^\\s*\\b(?:if|if[n|N]ot|while|while[n|N]ot|for)\\b\\s*(?:\\((.*)\\))?\\s*:\\s*");
    const regCommentCommand = new RegExp("^\\s*(?:comment|#|\"\"\"\\s*\\r$)");
    const regIgnoreLine = new RegExp(".*(#NoLinter|#NOLINTER)\\r$");
    for (let line = 0; line < sourceCodeArr.length; line++) {
        if (regControlStructure.test(sourceCodeArr[line]) == true && // es wurde der Beginn einer Kontrollstruktur in der aktuellen Zeile erkannt
            regCommentCommand.test(sourceCodeArr[line - 1]) == false && // in der vorangegangenen Zeile befindet sich kein Kommentar 
            regIgnoreLine.test(sourceCodeArr[line]) == false) {
            let beginPos = editor.document.lineAt(line).firstNonWhitespaceCharacterIndex;
            let endPos = editor.document.lineAt(line).text.length;
            let range = new vscode.Range(new vscode.Position(line, beginPos), new vscode.Position(line, endPos));
            let markdown = new vscode.MarkdownString('## Best Practice Linter \n');
            markdown.appendMarkdown('Vor einer Kontrollstruktur sollte ein Kommentar oder ein **comment()**-Kommando stehen, in dem der Grund für eine Fallunterscheidung kurz erklärt wird. \n \n');
            markdown.appendMarkdown('Diese Regel kann mit dem Kommentar \"#NoLinter\" oder \"#NOLINTER\" in dieser Zeile ignoriert werden.');
            let decoration = { range, hoverMessage: markdown };
            arrWarningDecorations.push(decoration);
        }
    }
}
function bpOrderOfSqlCommands(editor, sourceCodeArr) {
    /*  Diese Funktion überprüft die richtige Reihenfolge der SQL-Befehle und die Übereinstimmung von openSQL()- und closeSQL()-Kommandos.
        Ein SQL-Befehl (nicht gemeint: openSQL() und closeSQL()) muss während einer passenden, aktiven Datenbankverbindung aufgebaut werden.
        Außerdem muss zu jedem openSQL()- ein übereinstimmender closeSQL()-Befehl existieren. Ansonsten werden die openSql()-Befehle, zu denen
        am Ende des Testskriptes noch offene Datenbankverbindungen bestehen, mit Codedekorationen versehen.
     */
    var arrOpenSqlCommands = [];
    const regOpenSqlCommand = new RegExp("^\\s*openSql\\(.*CONNECTION_NAME\\s*=\\s*[\"|'](?<ConnectionName>[a-zA-Z0-9\\s\\-_]+)[\"|'].*\\)");
    const regOtherSqlCommand = new RegExp("^\\s*(?:compareChangeSql|executeSql|loadCsvSql|querySql)\\(.*CONNECTION_NAME\\s*=\\s*[\"|'](?<ConnectionName>[a-zA-Z0-9\\s\\-_]+)[\"|'].*\\)");
    const regCloseSqlCommand = new RegExp("^\\s*closeSql\\(.*CONNECTION_NAME\\s*=\\s*[\"|'](?<ConnectionName>[a-zA-Z0-9\\s\\-_]+)[\"|'].*\\)");
    for (let line = 0; line < sourceCodeArr.length; line++) {
        if (regOpenSqlCommand.test(sourceCodeArr[line]) == true) {
            // es wurde ein openSql()-Kommando in der aktuellen Zeile erkannt
            let match = sourceCodeArr[line].match(regOpenSqlCommand);
            let beginPos = editor.document.lineAt(line).firstNonWhitespaceCharacterIndex;
            let endPos = editor.document.lineAt(line).text.length;
            let range = new vscode.Range(new vscode.Position(line, beginPos), new vscode.Position(line, endPos));
            if (codeUtils.isElementInOpenSQLCommandsArray(arrOpenSqlCommands, match[1])) {
                // es existiert bereits eine Verbindung mit dem aktuellen CONNECTION_NAME-Parameter
                let markdown = new vscode.MarkdownString('## Best Practice Linter \n');
                markdown.appendMarkdown('Es besteht bereits eine aktive Datenbankverbindung mit dem CONNECTION_NAME ' + match[1] + '.');
                let decoration = { range, hoverMessage: markdown };
                arrErrorDecorations.push(decoration);
            }
            else {
                // es besteht noch keine aktive Datenverbindung mit dem übergebenen Wert des Parameters CONNECTION_NAME
                let openSqlCommandInfo = [match[1], range];
                arrOpenSqlCommands.push(openSqlCommandInfo);
            }
        }
        else if (regCloseSqlCommand.test(sourceCodeArr[line]) == true) {
            // es wurde ein closeSql()-Befehl in der aktuellen Zeile erkannt
            let match = sourceCodeArr[line].match(regCloseSqlCommand);
            if (codeUtils.isElementInOpenSQLCommandsArray(arrOpenSqlCommands, match[1])) {
                // es gibt eine passende, aktive Datenverbindung zum closeSql()-Befehl, die geschlossen werden kann
                arrOpenSqlCommands.forEach(function (element, index) {
                    if (element[0] == match[1]) {
                        arrOpenSqlCommands.splice(index, 1);
                    }
                });
            }
            else {
                // es besteht keine aktive Datenbankverbindung zu der das closeSql()-Kommando passt
                let beginPos = editor.document.lineAt(line).firstNonWhitespaceCharacterIndex;
                let endPos = editor.document.lineAt(line).text.length;
                let range = new vscode.Range(new vscode.Position(line, beginPos), new vscode.Position(line, endPos));
                let markdown = new vscode.MarkdownString('## Best Practice Linter \n');
                markdown.appendMarkdown('Es besteht keine passende, aktive Datenbankverbindung, die geschlossen werden kann.');
                let decoration = { range, hoverMessage: markdown };
                arrErrorDecorations.push(decoration);
            }
        }
        else if (regOtherSqlCommand.test(sourceCodeArr[line]) == true) {
            // es wurde ein ausführender SQL-Befehl in der aktuellen Zeile erkannt
            let match = sourceCodeArr[line].match(regOtherSqlCommand);
            if (!codeUtils.isElementInOpenSQLCommandsArray(arrOpenSqlCommands, match[1])) {
                // es gibt keine passende, aktive Datenbankverbindung auf der das Kommando angewandt werden kann
                let beginPos = editor.document.lineAt(line).firstNonWhitespaceCharacterIndex;
                let endPos = editor.document.lineAt(line).text.length;
                let range = new vscode.Range(new vscode.Position(line, beginPos), new vscode.Position(line, endPos));
                let markdown = new vscode.MarkdownString('## Best Practice Linter \n');
                markdown.appendMarkdown('Dieses SQL-Kommando soll auf eine Datenbank ausgeführt werden, zu der keine aktive Verbindung besteht.');
                let decoration = { range, hoverMessage: markdown };
                arrErrorDecorations.push(decoration);
            }
        }
    }
    while (arrOpenSqlCommands.length > 0) {
        // für jedes verbleibende Element im Array, wird eine Fehlermeldung erstellt
        let markdown = new vscode.MarkdownString('## Best Practice Linter \n');
        markdown.appendMarkdown('Das openSql()-Kommando mit dem CONNECTION_NAME ' + arrOpenSqlCommands[0][0] + ' wurde nicht geschlossen.');
        let decoration = { range: arrOpenSqlCommands[0][1], hoverMessage: markdown };
        arrErrorDecorations.push(decoration);
        arrOpenSqlCommands.splice(0, 1);
    }
}


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(0);
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;
//# sourceMappingURL=extension.js.map